#![feature(prelude_import)]
#[prelude_import]
use std::prelude::v1::*;
#[macro_use]
extern crate std;
#[macro_use]
extern crate serde_derive;
pub mod applications {
    use crate::permissions::Resource;
    use std::fmt;
    pub struct AppIdentity {
        name: String,
        version: String,
        api_key: String,
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::fmt::Debug for AppIdentity {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            match *self {
                AppIdentity {
                    name: ref __self_0_0,
                    version: ref __self_0_1,
                    api_key: ref __self_0_2,
                } => {
                    let mut debug_trait_builder = f.debug_struct("AppIdentity");
                    let _ = debug_trait_builder.field("name", &&(*__self_0_0));
                    let _ = debug_trait_builder.field("version", &&(*__self_0_1));
                    let _ = debug_trait_builder.field("api_key", &&(*__self_0_2));
                    debug_trait_builder.finish()
                }
            }
        }
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::clone::Clone for AppIdentity {
        #[inline]
        fn clone(&self) -> AppIdentity {
            match *self {
                AppIdentity {
                    name: ref __self_0_0,
                    version: ref __self_0_1,
                    api_key: ref __self_0_2,
                } => AppIdentity {
                    name: ::core::clone::Clone::clone(&(*__self_0_0)),
                    version: ::core::clone::Clone::clone(&(*__self_0_1)),
                    api_key: ::core::clone::Clone::clone(&(*__self_0_2)),
                },
            }
        }
    }
    #[doc(hidden)]
    #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
    const _: () = {
        #[allow(rust_2018_idioms, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl _serde::Serialize for AppIdentity {
            fn serialize<__S>(
                &self,
                __serializer: __S,
            ) -> _serde::export::Result<__S::Ok, __S::Error>
            where
                __S: _serde::Serializer,
            {
                let mut __serde_state = match _serde::Serializer::serialize_struct(
                    __serializer,
                    "AppIdentity",
                    false as usize + 1 + 1 + 1,
                ) {
                    _serde::export::Ok(__val) => __val,
                    _serde::export::Err(__err) => {
                        return _serde::export::Err(__err);
                    }
                };
                match _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "name",
                    &self.name,
                ) {
                    _serde::export::Ok(__val) => __val,
                    _serde::export::Err(__err) => {
                        return _serde::export::Err(__err);
                    }
                };
                match _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "version",
                    &self.version,
                ) {
                    _serde::export::Ok(__val) => __val,
                    _serde::export::Err(__err) => {
                        return _serde::export::Err(__err);
                    }
                };
                match _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "api_key",
                    &self.api_key,
                ) {
                    _serde::export::Ok(__val) => __val,
                    _serde::export::Err(__err) => {
                        return _serde::export::Err(__err);
                    }
                };
                _serde::ser::SerializeStruct::end(__serde_state)
            }
        }
    };
    #[doc(hidden)]
    #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
    const _: () = {
        #[allow(rust_2018_idioms, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl<'de> _serde::Deserialize<'de> for AppIdentity {
            fn deserialize<__D>(__deserializer: __D) -> _serde::export::Result<Self, __D::Error>
            where
                __D: _serde::Deserializer<'de>,
            {
                #[allow(non_camel_case_types)]
                enum __Field {
                    __field0,
                    __field1,
                    __field2,
                    __ignore,
                }
                struct __FieldVisitor;
                impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                    type Value = __Field;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::export::Formatter,
                    ) -> _serde::export::fmt::Result {
                        _serde::export::Formatter::write_str(__formatter, "field identifier")
                    }
                    fn visit_u64<__E>(
                        self,
                        __value: u64,
                    ) -> _serde::export::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            0u64 => _serde::export::Ok(__Field::__field0),
                            1u64 => _serde::export::Ok(__Field::__field1),
                            2u64 => _serde::export::Ok(__Field::__field2),
                            _ => _serde::export::Err(_serde::de::Error::invalid_value(
                                _serde::de::Unexpected::Unsigned(__value),
                                &"field index 0 <= i < 3",
                            )),
                        }
                    }
                    fn visit_str<__E>(
                        self,
                        __value: &str,
                    ) -> _serde::export::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            "name" => _serde::export::Ok(__Field::__field0),
                            "version" => _serde::export::Ok(__Field::__field1),
                            "api_key" => _serde::export::Ok(__Field::__field2),
                            _ => _serde::export::Ok(__Field::__ignore),
                        }
                    }
                    fn visit_bytes<__E>(
                        self,
                        __value: &[u8],
                    ) -> _serde::export::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            b"name" => _serde::export::Ok(__Field::__field0),
                            b"version" => _serde::export::Ok(__Field::__field1),
                            b"api_key" => _serde::export::Ok(__Field::__field2),
                            _ => _serde::export::Ok(__Field::__ignore),
                        }
                    }
                }
                impl<'de> _serde::Deserialize<'de> for __Field {
                    #[inline]
                    fn deserialize<__D>(
                        __deserializer: __D,
                    ) -> _serde::export::Result<Self, __D::Error>
                    where
                        __D: _serde::Deserializer<'de>,
                    {
                        _serde::Deserializer::deserialize_identifier(__deserializer, __FieldVisitor)
                    }
                }
                struct __Visitor<'de> {
                    marker: _serde::export::PhantomData<AppIdentity>,
                    lifetime: _serde::export::PhantomData<&'de ()>,
                }
                impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                    type Value = AppIdentity;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::export::Formatter,
                    ) -> _serde::export::fmt::Result {
                        _serde::export::Formatter::write_str(__formatter, "struct AppIdentity")
                    }
                    #[inline]
                    fn visit_seq<__A>(
                        self,
                        mut __seq: __A,
                    ) -> _serde::export::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::SeqAccess<'de>,
                    {
                        let __field0 =
                            match match _serde::de::SeqAccess::next_element::<String>(&mut __seq) {
                                _serde::export::Ok(__val) => __val,
                                _serde::export::Err(__err) => {
                                    return _serde::export::Err(__err);
                                }
                            } {
                                _serde::export::Some(__value) => __value,
                                _serde::export::None => {
                                    return _serde::export::Err(_serde::de::Error::invalid_length(
                                        0usize,
                                        &"struct AppIdentity with 3 elements",
                                    ));
                                }
                            };
                        let __field1 =
                            match match _serde::de::SeqAccess::next_element::<String>(&mut __seq) {
                                _serde::export::Ok(__val) => __val,
                                _serde::export::Err(__err) => {
                                    return _serde::export::Err(__err);
                                }
                            } {
                                _serde::export::Some(__value) => __value,
                                _serde::export::None => {
                                    return _serde::export::Err(_serde::de::Error::invalid_length(
                                        1usize,
                                        &"struct AppIdentity with 3 elements",
                                    ));
                                }
                            };
                        let __field2 =
                            match match _serde::de::SeqAccess::next_element::<String>(&mut __seq) {
                                _serde::export::Ok(__val) => __val,
                                _serde::export::Err(__err) => {
                                    return _serde::export::Err(__err);
                                }
                            } {
                                _serde::export::Some(__value) => __value,
                                _serde::export::None => {
                                    return _serde::export::Err(_serde::de::Error::invalid_length(
                                        2usize,
                                        &"struct AppIdentity with 3 elements",
                                    ));
                                }
                            };
                        _serde::export::Ok(AppIdentity {
                            name: __field0,
                            version: __field1,
                            api_key: __field2,
                        })
                    }
                    #[inline]
                    fn visit_map<__A>(
                        self,
                        mut __map: __A,
                    ) -> _serde::export::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::MapAccess<'de>,
                    {
                        let mut __field0: _serde::export::Option<String> = _serde::export::None;
                        let mut __field1: _serde::export::Option<String> = _serde::export::None;
                        let mut __field2: _serde::export::Option<String> = _serde::export::None;
                        while let _serde::export::Some(__key) =
                            match _serde::de::MapAccess::next_key::<__Field>(&mut __map) {
                                _serde::export::Ok(__val) => __val,
                                _serde::export::Err(__err) => {
                                    return _serde::export::Err(__err);
                                }
                            }
                        {
                            match __key {
                                __Field::__field0 => {
                                    if _serde::export::Option::is_some(&__field0) {
                                        return _serde::export::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "name",
                                            ),
                                        );
                                    }
                                    __field0 = _serde::export::Some(
                                        match _serde::de::MapAccess::next_value::<String>(
                                            &mut __map,
                                        ) {
                                            _serde::export::Ok(__val) => __val,
                                            _serde::export::Err(__err) => {
                                                return _serde::export::Err(__err);
                                            }
                                        },
                                    );
                                }
                                __Field::__field1 => {
                                    if _serde::export::Option::is_some(&__field1) {
                                        return _serde::export::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "version",
                                            ),
                                        );
                                    }
                                    __field1 = _serde::export::Some(
                                        match _serde::de::MapAccess::next_value::<String>(
                                            &mut __map,
                                        ) {
                                            _serde::export::Ok(__val) => __val,
                                            _serde::export::Err(__err) => {
                                                return _serde::export::Err(__err);
                                            }
                                        },
                                    );
                                }
                                __Field::__field2 => {
                                    if _serde::export::Option::is_some(&__field2) {
                                        return _serde::export::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "api_key",
                                            ),
                                        );
                                    }
                                    __field2 = _serde::export::Some(
                                        match _serde::de::MapAccess::next_value::<String>(
                                            &mut __map,
                                        ) {
                                            _serde::export::Ok(__val) => __val,
                                            _serde::export::Err(__err) => {
                                                return _serde::export::Err(__err);
                                            }
                                        },
                                    );
                                }
                                _ => {
                                    let _ = match _serde::de::MapAccess::next_value::<
                                        _serde::de::IgnoredAny,
                                    >(&mut __map)
                                    {
                                        _serde::export::Ok(__val) => __val,
                                        _serde::export::Err(__err) => {
                                            return _serde::export::Err(__err);
                                        }
                                    };
                                }
                            }
                        }
                        let __field0 = match __field0 {
                            _serde::export::Some(__field0) => __field0,
                            _serde::export::None => {
                                match _serde::private::de::missing_field("name") {
                                    _serde::export::Ok(__val) => __val,
                                    _serde::export::Err(__err) => {
                                        return _serde::export::Err(__err);
                                    }
                                }
                            }
                        };
                        let __field1 = match __field1 {
                            _serde::export::Some(__field1) => __field1,
                            _serde::export::None => {
                                match _serde::private::de::missing_field("version") {
                                    _serde::export::Ok(__val) => __val,
                                    _serde::export::Err(__err) => {
                                        return _serde::export::Err(__err);
                                    }
                                }
                            }
                        };
                        let __field2 = match __field2 {
                            _serde::export::Some(__field2) => __field2,
                            _serde::export::None => {
                                match _serde::private::de::missing_field("api_key") {
                                    _serde::export::Ok(__val) => __val,
                                    _serde::export::Err(__err) => {
                                        return _serde::export::Err(__err);
                                    }
                                }
                            }
                        };
                        _serde::export::Ok(AppIdentity {
                            name: __field0,
                            version: __field1,
                            api_key: __field2,
                        })
                    }
                }
                const FIELDS: &'static [&'static str] = &["name", "version", "api_key"];
                _serde::Deserializer::deserialize_struct(
                    __deserializer,
                    "AppIdentity",
                    FIELDS,
                    __Visitor {
                        marker: _serde::export::PhantomData::<AppIdentity>,
                        lifetime: _serde::export::PhantomData,
                    },
                )
            }
        }
    };
    impl ::core::marker::StructuralPartialEq for AppIdentity {}
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::cmp::PartialEq for AppIdentity {
        #[inline]
        fn eq(&self, other: &AppIdentity) -> bool {
            match *other {
                AppIdentity {
                    name: ref __self_1_0,
                    version: ref __self_1_1,
                    api_key: ref __self_1_2,
                } => match *self {
                    AppIdentity {
                        name: ref __self_0_0,
                        version: ref __self_0_1,
                        api_key: ref __self_0_2,
                    } => {
                        (*__self_0_0) == (*__self_1_0)
                            && (*__self_0_1) == (*__self_1_1)
                            && (*__self_0_2) == (*__self_1_2)
                    }
                },
            }
        }
        #[inline]
        fn ne(&self, other: &AppIdentity) -> bool {
            match *other {
                AppIdentity {
                    name: ref __self_1_0,
                    version: ref __self_1_1,
                    api_key: ref __self_1_2,
                } => match *self {
                    AppIdentity {
                        name: ref __self_0_0,
                        version: ref __self_0_1,
                        api_key: ref __self_0_2,
                    } => {
                        (*__self_0_0) != (*__self_1_0)
                            || (*__self_0_1) != (*__self_1_1)
                            || (*__self_0_2) != (*__self_1_2)
                    }
                },
            }
        }
    }
    impl ::core::marker::StructuralEq for AppIdentity {}
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::cmp::Eq for AppIdentity {
        #[inline]
        #[doc(hidden)]
        fn assert_receiver_is_total_eq(&self) -> () {
            {
                let _: ::core::cmp::AssertParamIsEq<String>;
                let _: ::core::cmp::AssertParamIsEq<String>;
                let _: ::core::cmp::AssertParamIsEq<String>;
            }
        }
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::hash::Hash for AppIdentity {
        fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {
            match *self {
                AppIdentity {
                    name: ref __self_0_0,
                    version: ref __self_0_1,
                    api_key: ref __self_0_2,
                } => {
                    ::core::hash::Hash::hash(&(*__self_0_0), state);
                    ::core::hash::Hash::hash(&(*__self_0_1), state);
                    ::core::hash::Hash::hash(&(*__self_0_2), state)
                }
            }
        }
    }
    impl AppIdentity {
        pub fn new(name: String, version: String, api_key: String) -> Self {
            Self {
                name,
                version,
                api_key,
            }
        }
    }
    impl fmt::Display for AppIdentity {
        fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
            f.write_fmt(::core::fmt::Arguments::new_v1(
                &["", "-"],
                &match (&self.name, &self.version) {
                    (arg0, arg1) => [
                        ::core::fmt::ArgumentV1::new(arg0, ::core::fmt::Display::fmt),
                        ::core::fmt::ArgumentV1::new(arg1, ::core::fmt::Display::fmt),
                    ],
                },
            ))
        }
    }
    pub struct Application {
        name: String,
        version: String,
        api_key: String,
        owner: String,
        permissions: Vec<Resource>,
        description: Option<String>,
        documentation: Option<String>,
        platform: Option<String>,
        repository: Option<String>,
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::fmt::Debug for Application {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            match *self {
                Application {
                    name: ref __self_0_0,
                    version: ref __self_0_1,
                    api_key: ref __self_0_2,
                    owner: ref __self_0_3,
                    permissions: ref __self_0_4,
                    description: ref __self_0_5,
                    documentation: ref __self_0_6,
                    platform: ref __self_0_7,
                    repository: ref __self_0_8,
                } => {
                    let mut debug_trait_builder = f.debug_struct("Application");
                    let _ = debug_trait_builder.field("name", &&(*__self_0_0));
                    let _ = debug_trait_builder.field("version", &&(*__self_0_1));
                    let _ = debug_trait_builder.field("api_key", &&(*__self_0_2));
                    let _ = debug_trait_builder.field("owner", &&(*__self_0_3));
                    let _ = debug_trait_builder.field("permissions", &&(*__self_0_4));
                    let _ = debug_trait_builder.field("description", &&(*__self_0_5));
                    let _ = debug_trait_builder.field("documentation", &&(*__self_0_6));
                    let _ = debug_trait_builder.field("platform", &&(*__self_0_7));
                    let _ = debug_trait_builder.field("repository", &&(*__self_0_8));
                    debug_trait_builder.finish()
                }
            }
        }
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::clone::Clone for Application {
        #[inline]
        fn clone(&self) -> Application {
            match *self {
                Application {
                    name: ref __self_0_0,
                    version: ref __self_0_1,
                    api_key: ref __self_0_2,
                    owner: ref __self_0_3,
                    permissions: ref __self_0_4,
                    description: ref __self_0_5,
                    documentation: ref __self_0_6,
                    platform: ref __self_0_7,
                    repository: ref __self_0_8,
                } => Application {
                    name: ::core::clone::Clone::clone(&(*__self_0_0)),
                    version: ::core::clone::Clone::clone(&(*__self_0_1)),
                    api_key: ::core::clone::Clone::clone(&(*__self_0_2)),
                    owner: ::core::clone::Clone::clone(&(*__self_0_3)),
                    permissions: ::core::clone::Clone::clone(&(*__self_0_4)),
                    description: ::core::clone::Clone::clone(&(*__self_0_5)),
                    documentation: ::core::clone::Clone::clone(&(*__self_0_6)),
                    platform: ::core::clone::Clone::clone(&(*__self_0_7)),
                    repository: ::core::clone::Clone::clone(&(*__self_0_8)),
                },
            }
        }
    }
    #[doc(hidden)]
    #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
    const _: () = {
        #[allow(rust_2018_idioms, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl _serde::Serialize for Application {
            fn serialize<__S>(
                &self,
                __serializer: __S,
            ) -> _serde::export::Result<__S::Ok, __S::Error>
            where
                __S: _serde::Serializer,
            {
                let mut __serde_state = match _serde::Serializer::serialize_struct(
                    __serializer,
                    "Application",
                    false as usize + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1,
                ) {
                    _serde::export::Ok(__val) => __val,
                    _serde::export::Err(__err) => {
                        return _serde::export::Err(__err);
                    }
                };
                match _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "name",
                    &self.name,
                ) {
                    _serde::export::Ok(__val) => __val,
                    _serde::export::Err(__err) => {
                        return _serde::export::Err(__err);
                    }
                };
                match _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "version",
                    &self.version,
                ) {
                    _serde::export::Ok(__val) => __val,
                    _serde::export::Err(__err) => {
                        return _serde::export::Err(__err);
                    }
                };
                match _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "api_key",
                    &self.api_key,
                ) {
                    _serde::export::Ok(__val) => __val,
                    _serde::export::Err(__err) => {
                        return _serde::export::Err(__err);
                    }
                };
                match _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "owner",
                    &self.owner,
                ) {
                    _serde::export::Ok(__val) => __val,
                    _serde::export::Err(__err) => {
                        return _serde::export::Err(__err);
                    }
                };
                match _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "permissions",
                    &self.permissions,
                ) {
                    _serde::export::Ok(__val) => __val,
                    _serde::export::Err(__err) => {
                        return _serde::export::Err(__err);
                    }
                };
                match _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "description",
                    &self.description,
                ) {
                    _serde::export::Ok(__val) => __val,
                    _serde::export::Err(__err) => {
                        return _serde::export::Err(__err);
                    }
                };
                match _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "documentation",
                    &self.documentation,
                ) {
                    _serde::export::Ok(__val) => __val,
                    _serde::export::Err(__err) => {
                        return _serde::export::Err(__err);
                    }
                };
                match _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "platform",
                    &self.platform,
                ) {
                    _serde::export::Ok(__val) => __val,
                    _serde::export::Err(__err) => {
                        return _serde::export::Err(__err);
                    }
                };
                match _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "repository",
                    &self.repository,
                ) {
                    _serde::export::Ok(__val) => __val,
                    _serde::export::Err(__err) => {
                        return _serde::export::Err(__err);
                    }
                };
                _serde::ser::SerializeStruct::end(__serde_state)
            }
        }
    };
    #[doc(hidden)]
    #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
    const _: () = {
        #[allow(rust_2018_idioms, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl<'de> _serde::Deserialize<'de> for Application {
            fn deserialize<__D>(__deserializer: __D) -> _serde::export::Result<Self, __D::Error>
            where
                __D: _serde::Deserializer<'de>,
            {
                #[allow(non_camel_case_types)]
                enum __Field {
                    __field0,
                    __field1,
                    __field2,
                    __field3,
                    __field4,
                    __field5,
                    __field6,
                    __field7,
                    __field8,
                    __ignore,
                }
                struct __FieldVisitor;
                impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                    type Value = __Field;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::export::Formatter,
                    ) -> _serde::export::fmt::Result {
                        _serde::export::Formatter::write_str(__formatter, "field identifier")
                    }
                    fn visit_u64<__E>(
                        self,
                        __value: u64,
                    ) -> _serde::export::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            0u64 => _serde::export::Ok(__Field::__field0),
                            1u64 => _serde::export::Ok(__Field::__field1),
                            2u64 => _serde::export::Ok(__Field::__field2),
                            3u64 => _serde::export::Ok(__Field::__field3),
                            4u64 => _serde::export::Ok(__Field::__field4),
                            5u64 => _serde::export::Ok(__Field::__field5),
                            6u64 => _serde::export::Ok(__Field::__field6),
                            7u64 => _serde::export::Ok(__Field::__field7),
                            8u64 => _serde::export::Ok(__Field::__field8),
                            _ => _serde::export::Err(_serde::de::Error::invalid_value(
                                _serde::de::Unexpected::Unsigned(__value),
                                &"field index 0 <= i < 9",
                            )),
                        }
                    }
                    fn visit_str<__E>(
                        self,
                        __value: &str,
                    ) -> _serde::export::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            "name" => _serde::export::Ok(__Field::__field0),
                            "version" => _serde::export::Ok(__Field::__field1),
                            "api_key" => _serde::export::Ok(__Field::__field2),
                            "owner" => _serde::export::Ok(__Field::__field3),
                            "permissions" => _serde::export::Ok(__Field::__field4),
                            "description" => _serde::export::Ok(__Field::__field5),
                            "documentation" => _serde::export::Ok(__Field::__field6),
                            "platform" => _serde::export::Ok(__Field::__field7),
                            "repository" => _serde::export::Ok(__Field::__field8),
                            _ => _serde::export::Ok(__Field::__ignore),
                        }
                    }
                    fn visit_bytes<__E>(
                        self,
                        __value: &[u8],
                    ) -> _serde::export::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            b"name" => _serde::export::Ok(__Field::__field0),
                            b"version" => _serde::export::Ok(__Field::__field1),
                            b"api_key" => _serde::export::Ok(__Field::__field2),
                            b"owner" => _serde::export::Ok(__Field::__field3),
                            b"permissions" => _serde::export::Ok(__Field::__field4),
                            b"description" => _serde::export::Ok(__Field::__field5),
                            b"documentation" => _serde::export::Ok(__Field::__field6),
                            b"platform" => _serde::export::Ok(__Field::__field7),
                            b"repository" => _serde::export::Ok(__Field::__field8),
                            _ => _serde::export::Ok(__Field::__ignore),
                        }
                    }
                }
                impl<'de> _serde::Deserialize<'de> for __Field {
                    #[inline]
                    fn deserialize<__D>(
                        __deserializer: __D,
                    ) -> _serde::export::Result<Self, __D::Error>
                    where
                        __D: _serde::Deserializer<'de>,
                    {
                        _serde::Deserializer::deserialize_identifier(__deserializer, __FieldVisitor)
                    }
                }
                struct __Visitor<'de> {
                    marker: _serde::export::PhantomData<Application>,
                    lifetime: _serde::export::PhantomData<&'de ()>,
                }
                impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                    type Value = Application;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::export::Formatter,
                    ) -> _serde::export::fmt::Result {
                        _serde::export::Formatter::write_str(__formatter, "struct Application")
                    }
                    #[inline]
                    fn visit_seq<__A>(
                        self,
                        mut __seq: __A,
                    ) -> _serde::export::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::SeqAccess<'de>,
                    {
                        let __field0 =
                            match match _serde::de::SeqAccess::next_element::<String>(&mut __seq) {
                                _serde::export::Ok(__val) => __val,
                                _serde::export::Err(__err) => {
                                    return _serde::export::Err(__err);
                                }
                            } {
                                _serde::export::Some(__value) => __value,
                                _serde::export::None => {
                                    return _serde::export::Err(_serde::de::Error::invalid_length(
                                        0usize,
                                        &"struct Application with 9 elements",
                                    ));
                                }
                            };
                        let __field1 =
                            match match _serde::de::SeqAccess::next_element::<String>(&mut __seq) {
                                _serde::export::Ok(__val) => __val,
                                _serde::export::Err(__err) => {
                                    return _serde::export::Err(__err);
                                }
                            } {
                                _serde::export::Some(__value) => __value,
                                _serde::export::None => {
                                    return _serde::export::Err(_serde::de::Error::invalid_length(
                                        1usize,
                                        &"struct Application with 9 elements",
                                    ));
                                }
                            };
                        let __field2 =
                            match match _serde::de::SeqAccess::next_element::<String>(&mut __seq) {
                                _serde::export::Ok(__val) => __val,
                                _serde::export::Err(__err) => {
                                    return _serde::export::Err(__err);
                                }
                            } {
                                _serde::export::Some(__value) => __value,
                                _serde::export::None => {
                                    return _serde::export::Err(_serde::de::Error::invalid_length(
                                        2usize,
                                        &"struct Application with 9 elements",
                                    ));
                                }
                            };
                        let __field3 =
                            match match _serde::de::SeqAccess::next_element::<String>(&mut __seq) {
                                _serde::export::Ok(__val) => __val,
                                _serde::export::Err(__err) => {
                                    return _serde::export::Err(__err);
                                }
                            } {
                                _serde::export::Some(__value) => __value,
                                _serde::export::None => {
                                    return _serde::export::Err(_serde::de::Error::invalid_length(
                                        3usize,
                                        &"struct Application with 9 elements",
                                    ));
                                }
                            };
                        let __field4 = match match _serde::de::SeqAccess::next_element::<
                            Vec<Resource>,
                        >(&mut __seq)
                        {
                            _serde::export::Ok(__val) => __val,
                            _serde::export::Err(__err) => {
                                return _serde::export::Err(__err);
                            }
                        } {
                            _serde::export::Some(__value) => __value,
                            _serde::export::None => {
                                return _serde::export::Err(_serde::de::Error::invalid_length(
                                    4usize,
                                    &"struct Application with 9 elements",
                                ));
                            }
                        };
                        let __field5 = match match _serde::de::SeqAccess::next_element::<
                            Option<String>,
                        >(&mut __seq)
                        {
                            _serde::export::Ok(__val) => __val,
                            _serde::export::Err(__err) => {
                                return _serde::export::Err(__err);
                            }
                        } {
                            _serde::export::Some(__value) => __value,
                            _serde::export::None => {
                                return _serde::export::Err(_serde::de::Error::invalid_length(
                                    5usize,
                                    &"struct Application with 9 elements",
                                ));
                            }
                        };
                        let __field6 = match match _serde::de::SeqAccess::next_element::<
                            Option<String>,
                        >(&mut __seq)
                        {
                            _serde::export::Ok(__val) => __val,
                            _serde::export::Err(__err) => {
                                return _serde::export::Err(__err);
                            }
                        } {
                            _serde::export::Some(__value) => __value,
                            _serde::export::None => {
                                return _serde::export::Err(_serde::de::Error::invalid_length(
                                    6usize,
                                    &"struct Application with 9 elements",
                                ));
                            }
                        };
                        let __field7 = match match _serde::de::SeqAccess::next_element::<
                            Option<String>,
                        >(&mut __seq)
                        {
                            _serde::export::Ok(__val) => __val,
                            _serde::export::Err(__err) => {
                                return _serde::export::Err(__err);
                            }
                        } {
                            _serde::export::Some(__value) => __value,
                            _serde::export::None => {
                                return _serde::export::Err(_serde::de::Error::invalid_length(
                                    7usize,
                                    &"struct Application with 9 elements",
                                ));
                            }
                        };
                        let __field8 = match match _serde::de::SeqAccess::next_element::<
                            Option<String>,
                        >(&mut __seq)
                        {
                            _serde::export::Ok(__val) => __val,
                            _serde::export::Err(__err) => {
                                return _serde::export::Err(__err);
                            }
                        } {
                            _serde::export::Some(__value) => __value,
                            _serde::export::None => {
                                return _serde::export::Err(_serde::de::Error::invalid_length(
                                    8usize,
                                    &"struct Application with 9 elements",
                                ));
                            }
                        };
                        _serde::export::Ok(Application {
                            name: __field0,
                            version: __field1,
                            api_key: __field2,
                            owner: __field3,
                            permissions: __field4,
                            description: __field5,
                            documentation: __field6,
                            platform: __field7,
                            repository: __field8,
                        })
                    }
                    #[inline]
                    fn visit_map<__A>(
                        self,
                        mut __map: __A,
                    ) -> _serde::export::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::MapAccess<'de>,
                    {
                        let mut __field0: _serde::export::Option<String> = _serde::export::None;
                        let mut __field1: _serde::export::Option<String> = _serde::export::None;
                        let mut __field2: _serde::export::Option<String> = _serde::export::None;
                        let mut __field3: _serde::export::Option<String> = _serde::export::None;
                        let mut __field4: _serde::export::Option<Vec<Resource>> =
                            _serde::export::None;
                        let mut __field5: _serde::export::Option<Option<String>> =
                            _serde::export::None;
                        let mut __field6: _serde::export::Option<Option<String>> =
                            _serde::export::None;
                        let mut __field7: _serde::export::Option<Option<String>> =
                            _serde::export::None;
                        let mut __field8: _serde::export::Option<Option<String>> =
                            _serde::export::None;
                        while let _serde::export::Some(__key) =
                            match _serde::de::MapAccess::next_key::<__Field>(&mut __map) {
                                _serde::export::Ok(__val) => __val,
                                _serde::export::Err(__err) => {
                                    return _serde::export::Err(__err);
                                }
                            }
                        {
                            match __key {
                                __Field::__field0 => {
                                    if _serde::export::Option::is_some(&__field0) {
                                        return _serde::export::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "name",
                                            ),
                                        );
                                    }
                                    __field0 = _serde::export::Some(
                                        match _serde::de::MapAccess::next_value::<String>(
                                            &mut __map,
                                        ) {
                                            _serde::export::Ok(__val) => __val,
                                            _serde::export::Err(__err) => {
                                                return _serde::export::Err(__err);
                                            }
                                        },
                                    );
                                }
                                __Field::__field1 => {
                                    if _serde::export::Option::is_some(&__field1) {
                                        return _serde::export::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "version",
                                            ),
                                        );
                                    }
                                    __field1 = _serde::export::Some(
                                        match _serde::de::MapAccess::next_value::<String>(
                                            &mut __map,
                                        ) {
                                            _serde::export::Ok(__val) => __val,
                                            _serde::export::Err(__err) => {
                                                return _serde::export::Err(__err);
                                            }
                                        },
                                    );
                                }
                                __Field::__field2 => {
                                    if _serde::export::Option::is_some(&__field2) {
                                        return _serde::export::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "api_key",
                                            ),
                                        );
                                    }
                                    __field2 = _serde::export::Some(
                                        match _serde::de::MapAccess::next_value::<String>(
                                            &mut __map,
                                        ) {
                                            _serde::export::Ok(__val) => __val,
                                            _serde::export::Err(__err) => {
                                                return _serde::export::Err(__err);
                                            }
                                        },
                                    );
                                }
                                __Field::__field3 => {
                                    if _serde::export::Option::is_some(&__field3) {
                                        return _serde::export::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "owner",
                                            ),
                                        );
                                    }
                                    __field3 = _serde::export::Some(
                                        match _serde::de::MapAccess::next_value::<String>(
                                            &mut __map,
                                        ) {
                                            _serde::export::Ok(__val) => __val,
                                            _serde::export::Err(__err) => {
                                                return _serde::export::Err(__err);
                                            }
                                        },
                                    );
                                }
                                __Field::__field4 => {
                                    if _serde::export::Option::is_some(&__field4) {
                                        return _serde::export::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "permissions",
                                            ),
                                        );
                                    }
                                    __field4 = _serde::export::Some(
                                        match _serde::de::MapAccess::next_value::<Vec<Resource>>(
                                            &mut __map,
                                        ) {
                                            _serde::export::Ok(__val) => __val,
                                            _serde::export::Err(__err) => {
                                                return _serde::export::Err(__err);
                                            }
                                        },
                                    );
                                }
                                __Field::__field5 => {
                                    if _serde::export::Option::is_some(&__field5) {
                                        return _serde::export::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "description",
                                            ),
                                        );
                                    }
                                    __field5 = _serde::export::Some(
                                        match _serde::de::MapAccess::next_value::<Option<String>>(
                                            &mut __map,
                                        ) {
                                            _serde::export::Ok(__val) => __val,
                                            _serde::export::Err(__err) => {
                                                return _serde::export::Err(__err);
                                            }
                                        },
                                    );
                                }
                                __Field::__field6 => {
                                    if _serde::export::Option::is_some(&__field6) {
                                        return _serde::export::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "documentation",
                                            ),
                                        );
                                    }
                                    __field6 = _serde::export::Some(
                                        match _serde::de::MapAccess::next_value::<Option<String>>(
                                            &mut __map,
                                        ) {
                                            _serde::export::Ok(__val) => __val,
                                            _serde::export::Err(__err) => {
                                                return _serde::export::Err(__err);
                                            }
                                        },
                                    );
                                }
                                __Field::__field7 => {
                                    if _serde::export::Option::is_some(&__field7) {
                                        return _serde::export::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "platform",
                                            ),
                                        );
                                    }
                                    __field7 = _serde::export::Some(
                                        match _serde::de::MapAccess::next_value::<Option<String>>(
                                            &mut __map,
                                        ) {
                                            _serde::export::Ok(__val) => __val,
                                            _serde::export::Err(__err) => {
                                                return _serde::export::Err(__err);
                                            }
                                        },
                                    );
                                }
                                __Field::__field8 => {
                                    if _serde::export::Option::is_some(&__field8) {
                                        return _serde::export::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "repository",
                                            ),
                                        );
                                    }
                                    __field8 = _serde::export::Some(
                                        match _serde::de::MapAccess::next_value::<Option<String>>(
                                            &mut __map,
                                        ) {
                                            _serde::export::Ok(__val) => __val,
                                            _serde::export::Err(__err) => {
                                                return _serde::export::Err(__err);
                                            }
                                        },
                                    );
                                }
                                _ => {
                                    let _ = match _serde::de::MapAccess::next_value::<
                                        _serde::de::IgnoredAny,
                                    >(&mut __map)
                                    {
                                        _serde::export::Ok(__val) => __val,
                                        _serde::export::Err(__err) => {
                                            return _serde::export::Err(__err);
                                        }
                                    };
                                }
                            }
                        }
                        let __field0 = match __field0 {
                            _serde::export::Some(__field0) => __field0,
                            _serde::export::None => {
                                match _serde::private::de::missing_field("name") {
                                    _serde::export::Ok(__val) => __val,
                                    _serde::export::Err(__err) => {
                                        return _serde::export::Err(__err);
                                    }
                                }
                            }
                        };
                        let __field1 = match __field1 {
                            _serde::export::Some(__field1) => __field1,
                            _serde::export::None => {
                                match _serde::private::de::missing_field("version") {
                                    _serde::export::Ok(__val) => __val,
                                    _serde::export::Err(__err) => {
                                        return _serde::export::Err(__err);
                                    }
                                }
                            }
                        };
                        let __field2 = match __field2 {
                            _serde::export::Some(__field2) => __field2,
                            _serde::export::None => {
                                match _serde::private::de::missing_field("api_key") {
                                    _serde::export::Ok(__val) => __val,
                                    _serde::export::Err(__err) => {
                                        return _serde::export::Err(__err);
                                    }
                                }
                            }
                        };
                        let __field3 = match __field3 {
                            _serde::export::Some(__field3) => __field3,
                            _serde::export::None => {
                                match _serde::private::de::missing_field("owner") {
                                    _serde::export::Ok(__val) => __val,
                                    _serde::export::Err(__err) => {
                                        return _serde::export::Err(__err);
                                    }
                                }
                            }
                        };
                        let __field4 = match __field4 {
                            _serde::export::Some(__field4) => __field4,
                            _serde::export::None => {
                                match _serde::private::de::missing_field("permissions") {
                                    _serde::export::Ok(__val) => __val,
                                    _serde::export::Err(__err) => {
                                        return _serde::export::Err(__err);
                                    }
                                }
                            }
                        };
                        let __field5 = match __field5 {
                            _serde::export::Some(__field5) => __field5,
                            _serde::export::None => {
                                match _serde::private::de::missing_field("description") {
                                    _serde::export::Ok(__val) => __val,
                                    _serde::export::Err(__err) => {
                                        return _serde::export::Err(__err);
                                    }
                                }
                            }
                        };
                        let __field6 = match __field6 {
                            _serde::export::Some(__field6) => __field6,
                            _serde::export::None => {
                                match _serde::private::de::missing_field("documentation") {
                                    _serde::export::Ok(__val) => __val,
                                    _serde::export::Err(__err) => {
                                        return _serde::export::Err(__err);
                                    }
                                }
                            }
                        };
                        let __field7 = match __field7 {
                            _serde::export::Some(__field7) => __field7,
                            _serde::export::None => {
                                match _serde::private::de::missing_field("platform") {
                                    _serde::export::Ok(__val) => __val,
                                    _serde::export::Err(__err) => {
                                        return _serde::export::Err(__err);
                                    }
                                }
                            }
                        };
                        let __field8 = match __field8 {
                            _serde::export::Some(__field8) => __field8,
                            _serde::export::None => {
                                match _serde::private::de::missing_field("repository") {
                                    _serde::export::Ok(__val) => __val,
                                    _serde::export::Err(__err) => {
                                        return _serde::export::Err(__err);
                                    }
                                }
                            }
                        };
                        _serde::export::Ok(Application {
                            name: __field0,
                            version: __field1,
                            api_key: __field2,
                            owner: __field3,
                            permissions: __field4,
                            description: __field5,
                            documentation: __field6,
                            platform: __field7,
                            repository: __field8,
                        })
                    }
                }
                const FIELDS: &'static [&'static str] = &[
                    "name",
                    "version",
                    "api_key",
                    "owner",
                    "permissions",
                    "description",
                    "documentation",
                    "platform",
                    "repository",
                ];
                _serde::Deserializer::deserialize_struct(
                    __deserializer,
                    "Application",
                    FIELDS,
                    __Visitor {
                        marker: _serde::export::PhantomData::<Application>,
                        lifetime: _serde::export::PhantomData,
                    },
                )
            }
        }
    };
    impl Application {
        pub fn new(name: String, version: String, api_key: String, owner: String) -> Self {
            Self {
                name,
                version,
                api_key,
                owner,
                permissions: Vec::new(),
                description: None,
                documentation: None,
                platform: None,
                repository: None,
            }
        }
        pub fn description(mut self, description: String) -> Self {
            self.description = Some(description);
            self
        }
        pub fn permissions(mut self, resources: &[Resource]) -> Self {
            self.permissions.extend_from_slice(resources);
            self
        }
        pub fn documentation(mut self, docs: String) -> Self {
            self.documentation = Some(docs);
            self
        }
        pub fn platform(mut self, platform: String) -> Self {
            self.platform = Some(platform);
            self
        }
        pub fn repository(mut self, repo: String) -> Self {
            self.repository = Some(repo);
            self
        }
        pub fn identity(&self) -> AppIdentity {
            AppIdentity::new(
                self.name.clone(),
                self.version.clone(),
                self.api_key.clone(),
            )
        }
    }
}
pub mod permissions {
    use ipnetwork::IpNetwork;
    use std::fmt;
    use std::path::PathBuf;
    pub enum Resource {
        Read(PathBuf),
        Write(PathBuf),
        Execute(PathBuf),
        ReadWrite(PathBuf),
        WriteExecute(PathBuf),
        ReadExecute(PathBuf),
        ReadWriteExecute(PathBuf),
        Network(IpNetwork),
    }
    #[doc(hidden)]
    #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
    const _: () = {
        #[allow(rust_2018_idioms, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl _serde::Serialize for Resource {
            fn serialize<__S>(
                &self,
                __serializer: __S,
            ) -> _serde::export::Result<__S::Ok, __S::Error>
            where
                __S: _serde::Serializer,
            {
                match *self {
                    Resource::Read(ref __field0) => _serde::Serializer::serialize_newtype_variant(
                        __serializer,
                        "Resource",
                        0u32,
                        "Read",
                        __field0,
                    ),
                    Resource::Write(ref __field0) => _serde::Serializer::serialize_newtype_variant(
                        __serializer,
                        "Resource",
                        1u32,
                        "Write",
                        __field0,
                    ),
                    Resource::Execute(ref __field0) => {
                        _serde::Serializer::serialize_newtype_variant(
                            __serializer,
                            "Resource",
                            2u32,
                            "Execute",
                            __field0,
                        )
                    }
                    Resource::ReadWrite(ref __field0) => {
                        _serde::Serializer::serialize_newtype_variant(
                            __serializer,
                            "Resource",
                            3u32,
                            "ReadWrite",
                            __field0,
                        )
                    }
                    Resource::WriteExecute(ref __field0) => {
                        _serde::Serializer::serialize_newtype_variant(
                            __serializer,
                            "Resource",
                            4u32,
                            "WriteExecute",
                            __field0,
                        )
                    }
                    Resource::ReadExecute(ref __field0) => {
                        _serde::Serializer::serialize_newtype_variant(
                            __serializer,
                            "Resource",
                            5u32,
                            "ReadExecute",
                            __field0,
                        )
                    }
                    Resource::ReadWriteExecute(ref __field0) => {
                        _serde::Serializer::serialize_newtype_variant(
                            __serializer,
                            "Resource",
                            6u32,
                            "ReadWriteExecute",
                            __field0,
                        )
                    }
                    Resource::Network(ref __field0) => {
                        _serde::Serializer::serialize_newtype_variant(
                            __serializer,
                            "Resource",
                            7u32,
                            "Network",
                            __field0,
                        )
                    }
                }
            }
        }
    };
    #[doc(hidden)]
    #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
    const _: () = {
        #[allow(rust_2018_idioms, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl<'de> _serde::Deserialize<'de> for Resource {
            fn deserialize<__D>(__deserializer: __D) -> _serde::export::Result<Self, __D::Error>
            where
                __D: _serde::Deserializer<'de>,
            {
                #[allow(non_camel_case_types)]
                enum __Field {
                    __field0,
                    __field1,
                    __field2,
                    __field3,
                    __field4,
                    __field5,
                    __field6,
                    __field7,
                }
                struct __FieldVisitor;
                impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                    type Value = __Field;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::export::Formatter,
                    ) -> _serde::export::fmt::Result {
                        _serde::export::Formatter::write_str(__formatter, "variant identifier")
                    }
                    fn visit_u64<__E>(
                        self,
                        __value: u64,
                    ) -> _serde::export::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            0u64 => _serde::export::Ok(__Field::__field0),
                            1u64 => _serde::export::Ok(__Field::__field1),
                            2u64 => _serde::export::Ok(__Field::__field2),
                            3u64 => _serde::export::Ok(__Field::__field3),
                            4u64 => _serde::export::Ok(__Field::__field4),
                            5u64 => _serde::export::Ok(__Field::__field5),
                            6u64 => _serde::export::Ok(__Field::__field6),
                            7u64 => _serde::export::Ok(__Field::__field7),
                            _ => _serde::export::Err(_serde::de::Error::invalid_value(
                                _serde::de::Unexpected::Unsigned(__value),
                                &"variant index 0 <= i < 8",
                            )),
                        }
                    }
                    fn visit_str<__E>(
                        self,
                        __value: &str,
                    ) -> _serde::export::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            "Read" => _serde::export::Ok(__Field::__field0),
                            "Write" => _serde::export::Ok(__Field::__field1),
                            "Execute" => _serde::export::Ok(__Field::__field2),
                            "ReadWrite" => _serde::export::Ok(__Field::__field3),
                            "WriteExecute" => _serde::export::Ok(__Field::__field4),
                            "ReadExecute" => _serde::export::Ok(__Field::__field5),
                            "ReadWriteExecute" => _serde::export::Ok(__Field::__field6),
                            "Network" => _serde::export::Ok(__Field::__field7),
                            _ => _serde::export::Err(_serde::de::Error::unknown_variant(
                                __value, VARIANTS,
                            )),
                        }
                    }
                    fn visit_bytes<__E>(
                        self,
                        __value: &[u8],
                    ) -> _serde::export::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            b"Read" => _serde::export::Ok(__Field::__field0),
                            b"Write" => _serde::export::Ok(__Field::__field1),
                            b"Execute" => _serde::export::Ok(__Field::__field2),
                            b"ReadWrite" => _serde::export::Ok(__Field::__field3),
                            b"WriteExecute" => _serde::export::Ok(__Field::__field4),
                            b"ReadExecute" => _serde::export::Ok(__Field::__field5),
                            b"ReadWriteExecute" => _serde::export::Ok(__Field::__field6),
                            b"Network" => _serde::export::Ok(__Field::__field7),
                            _ => {
                                let __value = &_serde::export::from_utf8_lossy(__value);
                                _serde::export::Err(_serde::de::Error::unknown_variant(
                                    __value, VARIANTS,
                                ))
                            }
                        }
                    }
                }
                impl<'de> _serde::Deserialize<'de> for __Field {
                    #[inline]
                    fn deserialize<__D>(
                        __deserializer: __D,
                    ) -> _serde::export::Result<Self, __D::Error>
                    where
                        __D: _serde::Deserializer<'de>,
                    {
                        _serde::Deserializer::deserialize_identifier(__deserializer, __FieldVisitor)
                    }
                }
                struct __Visitor<'de> {
                    marker: _serde::export::PhantomData<Resource>,
                    lifetime: _serde::export::PhantomData<&'de ()>,
                }
                impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                    type Value = Resource;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::export::Formatter,
                    ) -> _serde::export::fmt::Result {
                        _serde::export::Formatter::write_str(__formatter, "enum Resource")
                    }
                    fn visit_enum<__A>(
                        self,
                        __data: __A,
                    ) -> _serde::export::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::EnumAccess<'de>,
                    {
                        match match _serde::de::EnumAccess::variant(__data) {
                            _serde::export::Ok(__val) => __val,
                            _serde::export::Err(__err) => {
                                return _serde::export::Err(__err);
                            }
                        } {
                            (__Field::__field0, __variant) => _serde::export::Result::map(
                                _serde::de::VariantAccess::newtype_variant::<PathBuf>(__variant),
                                Resource::Read,
                            ),
                            (__Field::__field1, __variant) => _serde::export::Result::map(
                                _serde::de::VariantAccess::newtype_variant::<PathBuf>(__variant),
                                Resource::Write,
                            ),
                            (__Field::__field2, __variant) => _serde::export::Result::map(
                                _serde::de::VariantAccess::newtype_variant::<PathBuf>(__variant),
                                Resource::Execute,
                            ),
                            (__Field::__field3, __variant) => _serde::export::Result::map(
                                _serde::de::VariantAccess::newtype_variant::<PathBuf>(__variant),
                                Resource::ReadWrite,
                            ),
                            (__Field::__field4, __variant) => _serde::export::Result::map(
                                _serde::de::VariantAccess::newtype_variant::<PathBuf>(__variant),
                                Resource::WriteExecute,
                            ),
                            (__Field::__field5, __variant) => _serde::export::Result::map(
                                _serde::de::VariantAccess::newtype_variant::<PathBuf>(__variant),
                                Resource::ReadExecute,
                            ),
                            (__Field::__field6, __variant) => _serde::export::Result::map(
                                _serde::de::VariantAccess::newtype_variant::<PathBuf>(__variant),
                                Resource::ReadWriteExecute,
                            ),
                            (__Field::__field7, __variant) => _serde::export::Result::map(
                                _serde::de::VariantAccess::newtype_variant::<IpNetwork>(__variant),
                                Resource::Network,
                            ),
                        }
                    }
                }
                const VARIANTS: &'static [&'static str] = &[
                    "Read",
                    "Write",
                    "Execute",
                    "ReadWrite",
                    "WriteExecute",
                    "ReadExecute",
                    "ReadWriteExecute",
                    "Network",
                ];
                _serde::Deserializer::deserialize_enum(
                    __deserializer,
                    "Resource",
                    VARIANTS,
                    __Visitor {
                        marker: _serde::export::PhantomData::<Resource>,
                        lifetime: _serde::export::PhantomData,
                    },
                )
            }
        }
    };
    impl ::core::marker::StructuralPartialEq for Resource {}
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::cmp::PartialEq for Resource {
        #[inline]
        fn eq(&self, other: &Resource) -> bool {
            {
                let __self_vi = unsafe { ::core::intrinsics::discriminant_value(&*self) };
                let __arg_1_vi = unsafe { ::core::intrinsics::discriminant_value(&*other) };
                if true && __self_vi == __arg_1_vi {
                    match (&*self, &*other) {
                        (&Resource::Read(ref __self_0), &Resource::Read(ref __arg_1_0)) => {
                            (*__self_0) == (*__arg_1_0)
                        }
                        (&Resource::Write(ref __self_0), &Resource::Write(ref __arg_1_0)) => {
                            (*__self_0) == (*__arg_1_0)
                        }
                        (&Resource::Execute(ref __self_0), &Resource::Execute(ref __arg_1_0)) => {
                            (*__self_0) == (*__arg_1_0)
                        }
                        (
                            &Resource::ReadWrite(ref __self_0),
                            &Resource::ReadWrite(ref __arg_1_0),
                        ) => (*__self_0) == (*__arg_1_0),
                        (
                            &Resource::WriteExecute(ref __self_0),
                            &Resource::WriteExecute(ref __arg_1_0),
                        ) => (*__self_0) == (*__arg_1_0),
                        (
                            &Resource::ReadExecute(ref __self_0),
                            &Resource::ReadExecute(ref __arg_1_0),
                        ) => (*__self_0) == (*__arg_1_0),
                        (
                            &Resource::ReadWriteExecute(ref __self_0),
                            &Resource::ReadWriteExecute(ref __arg_1_0),
                        ) => (*__self_0) == (*__arg_1_0),
                        (&Resource::Network(ref __self_0), &Resource::Network(ref __arg_1_0)) => {
                            (*__self_0) == (*__arg_1_0)
                        }
                        _ => unsafe { ::core::intrinsics::unreachable() },
                    }
                } else {
                    false
                }
            }
        }
        #[inline]
        fn ne(&self, other: &Resource) -> bool {
            {
                let __self_vi = unsafe { ::core::intrinsics::discriminant_value(&*self) };
                let __arg_1_vi = unsafe { ::core::intrinsics::discriminant_value(&*other) };
                if true && __self_vi == __arg_1_vi {
                    match (&*self, &*other) {
                        (&Resource::Read(ref __self_0), &Resource::Read(ref __arg_1_0)) => {
                            (*__self_0) != (*__arg_1_0)
                        }
                        (&Resource::Write(ref __self_0), &Resource::Write(ref __arg_1_0)) => {
                            (*__self_0) != (*__arg_1_0)
                        }
                        (&Resource::Execute(ref __self_0), &Resource::Execute(ref __arg_1_0)) => {
                            (*__self_0) != (*__arg_1_0)
                        }
                        (
                            &Resource::ReadWrite(ref __self_0),
                            &Resource::ReadWrite(ref __arg_1_0),
                        ) => (*__self_0) != (*__arg_1_0),
                        (
                            &Resource::WriteExecute(ref __self_0),
                            &Resource::WriteExecute(ref __arg_1_0),
                        ) => (*__self_0) != (*__arg_1_0),
                        (
                            &Resource::ReadExecute(ref __self_0),
                            &Resource::ReadExecute(ref __arg_1_0),
                        ) => (*__self_0) != (*__arg_1_0),
                        (
                            &Resource::ReadWriteExecute(ref __self_0),
                            &Resource::ReadWriteExecute(ref __arg_1_0),
                        ) => (*__self_0) != (*__arg_1_0),
                        (&Resource::Network(ref __self_0), &Resource::Network(ref __arg_1_0)) => {
                            (*__self_0) != (*__arg_1_0)
                        }
                        _ => unsafe { ::core::intrinsics::unreachable() },
                    }
                } else {
                    true
                }
            }
        }
    }
    impl ::core::marker::StructuralEq for Resource {}
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::cmp::Eq for Resource {
        #[inline]
        #[doc(hidden)]
        fn assert_receiver_is_total_eq(&self) -> () {
            {
                let _: ::core::cmp::AssertParamIsEq<PathBuf>;
                let _: ::core::cmp::AssertParamIsEq<PathBuf>;
                let _: ::core::cmp::AssertParamIsEq<PathBuf>;
                let _: ::core::cmp::AssertParamIsEq<PathBuf>;
                let _: ::core::cmp::AssertParamIsEq<PathBuf>;
                let _: ::core::cmp::AssertParamIsEq<PathBuf>;
                let _: ::core::cmp::AssertParamIsEq<PathBuf>;
                let _: ::core::cmp::AssertParamIsEq<IpNetwork>;
            }
        }
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::cmp::PartialOrd for Resource {
        #[inline]
        fn partial_cmp(&self, other: &Resource) -> ::core::option::Option<::core::cmp::Ordering> {
            {
                let __self_vi = unsafe { ::core::intrinsics::discriminant_value(&*self) };
                let __arg_1_vi = unsafe { ::core::intrinsics::discriminant_value(&*other) };
                if true && __self_vi == __arg_1_vi {
                    match (&*self, &*other) {
                        (&Resource::Read(ref __self_0), &Resource::Read(ref __arg_1_0)) => {
                            match ::core::cmp::PartialOrd::partial_cmp(&(*__self_0), &(*__arg_1_0))
                            {
                                ::core::option::Option::Some(::core::cmp::Ordering::Equal) => {
                                    ::core::option::Option::Some(::core::cmp::Ordering::Equal)
                                }
                                cmp => cmp,
                            }
                        }
                        (&Resource::Write(ref __self_0), &Resource::Write(ref __arg_1_0)) => {
                            match ::core::cmp::PartialOrd::partial_cmp(&(*__self_0), &(*__arg_1_0))
                            {
                                ::core::option::Option::Some(::core::cmp::Ordering::Equal) => {
                                    ::core::option::Option::Some(::core::cmp::Ordering::Equal)
                                }
                                cmp => cmp,
                            }
                        }
                        (&Resource::Execute(ref __self_0), &Resource::Execute(ref __arg_1_0)) => {
                            match ::core::cmp::PartialOrd::partial_cmp(&(*__self_0), &(*__arg_1_0))
                            {
                                ::core::option::Option::Some(::core::cmp::Ordering::Equal) => {
                                    ::core::option::Option::Some(::core::cmp::Ordering::Equal)
                                }
                                cmp => cmp,
                            }
                        }
                        (
                            &Resource::ReadWrite(ref __self_0),
                            &Resource::ReadWrite(ref __arg_1_0),
                        ) => {
                            match ::core::cmp::PartialOrd::partial_cmp(&(*__self_0), &(*__arg_1_0))
                            {
                                ::core::option::Option::Some(::core::cmp::Ordering::Equal) => {
                                    ::core::option::Option::Some(::core::cmp::Ordering::Equal)
                                }
                                cmp => cmp,
                            }
                        }
                        (
                            &Resource::WriteExecute(ref __self_0),
                            &Resource::WriteExecute(ref __arg_1_0),
                        ) => {
                            match ::core::cmp::PartialOrd::partial_cmp(&(*__self_0), &(*__arg_1_0))
                            {
                                ::core::option::Option::Some(::core::cmp::Ordering::Equal) => {
                                    ::core::option::Option::Some(::core::cmp::Ordering::Equal)
                                }
                                cmp => cmp,
                            }
                        }
                        (
                            &Resource::ReadExecute(ref __self_0),
                            &Resource::ReadExecute(ref __arg_1_0),
                        ) => {
                            match ::core::cmp::PartialOrd::partial_cmp(&(*__self_0), &(*__arg_1_0))
                            {
                                ::core::option::Option::Some(::core::cmp::Ordering::Equal) => {
                                    ::core::option::Option::Some(::core::cmp::Ordering::Equal)
                                }
                                cmp => cmp,
                            }
                        }
                        (
                            &Resource::ReadWriteExecute(ref __self_0),
                            &Resource::ReadWriteExecute(ref __arg_1_0),
                        ) => {
                            match ::core::cmp::PartialOrd::partial_cmp(&(*__self_0), &(*__arg_1_0))
                            {
                                ::core::option::Option::Some(::core::cmp::Ordering::Equal) => {
                                    ::core::option::Option::Some(::core::cmp::Ordering::Equal)
                                }
                                cmp => cmp,
                            }
                        }
                        (&Resource::Network(ref __self_0), &Resource::Network(ref __arg_1_0)) => {
                            match ::core::cmp::PartialOrd::partial_cmp(&(*__self_0), &(*__arg_1_0))
                            {
                                ::core::option::Option::Some(::core::cmp::Ordering::Equal) => {
                                    ::core::option::Option::Some(::core::cmp::Ordering::Equal)
                                }
                                cmp => cmp,
                            }
                        }
                        _ => unsafe { ::core::intrinsics::unreachable() },
                    }
                } else {
                    __self_vi.partial_cmp(&__arg_1_vi)
                }
            }
        }
        #[inline]
        fn lt(&self, other: &Resource) -> bool {
            {
                let __self_vi = unsafe { ::core::intrinsics::discriminant_value(&*self) };
                let __arg_1_vi = unsafe { ::core::intrinsics::discriminant_value(&*other) };
                if true && __self_vi == __arg_1_vi {
                    match (&*self, &*other) {
                        (&Resource::Read(ref __self_0), &Resource::Read(ref __arg_1_0)) => {
                            ::core::option::Option::unwrap_or(
                                ::core::cmp::PartialOrd::partial_cmp(&(*__self_0), &(*__arg_1_0)),
                                ::core::cmp::Ordering::Greater,
                            ) == ::core::cmp::Ordering::Less
                        }
                        (&Resource::Write(ref __self_0), &Resource::Write(ref __arg_1_0)) => {
                            ::core::option::Option::unwrap_or(
                                ::core::cmp::PartialOrd::partial_cmp(&(*__self_0), &(*__arg_1_0)),
                                ::core::cmp::Ordering::Greater,
                            ) == ::core::cmp::Ordering::Less
                        }
                        (&Resource::Execute(ref __self_0), &Resource::Execute(ref __arg_1_0)) => {
                            ::core::option::Option::unwrap_or(
                                ::core::cmp::PartialOrd::partial_cmp(&(*__self_0), &(*__arg_1_0)),
                                ::core::cmp::Ordering::Greater,
                            ) == ::core::cmp::Ordering::Less
                        }
                        (
                            &Resource::ReadWrite(ref __self_0),
                            &Resource::ReadWrite(ref __arg_1_0),
                        ) => {
                            ::core::option::Option::unwrap_or(
                                ::core::cmp::PartialOrd::partial_cmp(&(*__self_0), &(*__arg_1_0)),
                                ::core::cmp::Ordering::Greater,
                            ) == ::core::cmp::Ordering::Less
                        }
                        (
                            &Resource::WriteExecute(ref __self_0),
                            &Resource::WriteExecute(ref __arg_1_0),
                        ) => {
                            ::core::option::Option::unwrap_or(
                                ::core::cmp::PartialOrd::partial_cmp(&(*__self_0), &(*__arg_1_0)),
                                ::core::cmp::Ordering::Greater,
                            ) == ::core::cmp::Ordering::Less
                        }
                        (
                            &Resource::ReadExecute(ref __self_0),
                            &Resource::ReadExecute(ref __arg_1_0),
                        ) => {
                            ::core::option::Option::unwrap_or(
                                ::core::cmp::PartialOrd::partial_cmp(&(*__self_0), &(*__arg_1_0)),
                                ::core::cmp::Ordering::Greater,
                            ) == ::core::cmp::Ordering::Less
                        }
                        (
                            &Resource::ReadWriteExecute(ref __self_0),
                            &Resource::ReadWriteExecute(ref __arg_1_0),
                        ) => {
                            ::core::option::Option::unwrap_or(
                                ::core::cmp::PartialOrd::partial_cmp(&(*__self_0), &(*__arg_1_0)),
                                ::core::cmp::Ordering::Greater,
                            ) == ::core::cmp::Ordering::Less
                        }
                        (&Resource::Network(ref __self_0), &Resource::Network(ref __arg_1_0)) => {
                            ::core::option::Option::unwrap_or(
                                ::core::cmp::PartialOrd::partial_cmp(&(*__self_0), &(*__arg_1_0)),
                                ::core::cmp::Ordering::Greater,
                            ) == ::core::cmp::Ordering::Less
                        }
                        _ => unsafe { ::core::intrinsics::unreachable() },
                    }
                } else {
                    __self_vi.lt(&__arg_1_vi)
                }
            }
        }
        #[inline]
        fn le(&self, other: &Resource) -> bool {
            {
                let __self_vi = unsafe { ::core::intrinsics::discriminant_value(&*self) };
                let __arg_1_vi = unsafe { ::core::intrinsics::discriminant_value(&*other) };
                if true && __self_vi == __arg_1_vi {
                    match (&*self, &*other) {
                        (&Resource::Read(ref __self_0), &Resource::Read(ref __arg_1_0)) => {
                            ::core::option::Option::unwrap_or(
                                ::core::cmp::PartialOrd::partial_cmp(&(*__self_0), &(*__arg_1_0)),
                                ::core::cmp::Ordering::Greater,
                            ) != ::core::cmp::Ordering::Greater
                        }
                        (&Resource::Write(ref __self_0), &Resource::Write(ref __arg_1_0)) => {
                            ::core::option::Option::unwrap_or(
                                ::core::cmp::PartialOrd::partial_cmp(&(*__self_0), &(*__arg_1_0)),
                                ::core::cmp::Ordering::Greater,
                            ) != ::core::cmp::Ordering::Greater
                        }
                        (&Resource::Execute(ref __self_0), &Resource::Execute(ref __arg_1_0)) => {
                            ::core::option::Option::unwrap_or(
                                ::core::cmp::PartialOrd::partial_cmp(&(*__self_0), &(*__arg_1_0)),
                                ::core::cmp::Ordering::Greater,
                            ) != ::core::cmp::Ordering::Greater
                        }
                        (
                            &Resource::ReadWrite(ref __self_0),
                            &Resource::ReadWrite(ref __arg_1_0),
                        ) => {
                            ::core::option::Option::unwrap_or(
                                ::core::cmp::PartialOrd::partial_cmp(&(*__self_0), &(*__arg_1_0)),
                                ::core::cmp::Ordering::Greater,
                            ) != ::core::cmp::Ordering::Greater
                        }
                        (
                            &Resource::WriteExecute(ref __self_0),
                            &Resource::WriteExecute(ref __arg_1_0),
                        ) => {
                            ::core::option::Option::unwrap_or(
                                ::core::cmp::PartialOrd::partial_cmp(&(*__self_0), &(*__arg_1_0)),
                                ::core::cmp::Ordering::Greater,
                            ) != ::core::cmp::Ordering::Greater
                        }
                        (
                            &Resource::ReadExecute(ref __self_0),
                            &Resource::ReadExecute(ref __arg_1_0),
                        ) => {
                            ::core::option::Option::unwrap_or(
                                ::core::cmp::PartialOrd::partial_cmp(&(*__self_0), &(*__arg_1_0)),
                                ::core::cmp::Ordering::Greater,
                            ) != ::core::cmp::Ordering::Greater
                        }
                        (
                            &Resource::ReadWriteExecute(ref __self_0),
                            &Resource::ReadWriteExecute(ref __arg_1_0),
                        ) => {
                            ::core::option::Option::unwrap_or(
                                ::core::cmp::PartialOrd::partial_cmp(&(*__self_0), &(*__arg_1_0)),
                                ::core::cmp::Ordering::Greater,
                            ) != ::core::cmp::Ordering::Greater
                        }
                        (&Resource::Network(ref __self_0), &Resource::Network(ref __arg_1_0)) => {
                            ::core::option::Option::unwrap_or(
                                ::core::cmp::PartialOrd::partial_cmp(&(*__self_0), &(*__arg_1_0)),
                                ::core::cmp::Ordering::Greater,
                            ) != ::core::cmp::Ordering::Greater
                        }
                        _ => unsafe { ::core::intrinsics::unreachable() },
                    }
                } else {
                    __self_vi.le(&__arg_1_vi)
                }
            }
        }
        #[inline]
        fn gt(&self, other: &Resource) -> bool {
            {
                let __self_vi = unsafe { ::core::intrinsics::discriminant_value(&*self) };
                let __arg_1_vi = unsafe { ::core::intrinsics::discriminant_value(&*other) };
                if true && __self_vi == __arg_1_vi {
                    match (&*self, &*other) {
                        (&Resource::Read(ref __self_0), &Resource::Read(ref __arg_1_0)) => {
                            ::core::option::Option::unwrap_or(
                                ::core::cmp::PartialOrd::partial_cmp(&(*__self_0), &(*__arg_1_0)),
                                ::core::cmp::Ordering::Less,
                            ) == ::core::cmp::Ordering::Greater
                        }
                        (&Resource::Write(ref __self_0), &Resource::Write(ref __arg_1_0)) => {
                            ::core::option::Option::unwrap_or(
                                ::core::cmp::PartialOrd::partial_cmp(&(*__self_0), &(*__arg_1_0)),
                                ::core::cmp::Ordering::Less,
                            ) == ::core::cmp::Ordering::Greater
                        }
                        (&Resource::Execute(ref __self_0), &Resource::Execute(ref __arg_1_0)) => {
                            ::core::option::Option::unwrap_or(
                                ::core::cmp::PartialOrd::partial_cmp(&(*__self_0), &(*__arg_1_0)),
                                ::core::cmp::Ordering::Less,
                            ) == ::core::cmp::Ordering::Greater
                        }
                        (
                            &Resource::ReadWrite(ref __self_0),
                            &Resource::ReadWrite(ref __arg_1_0),
                        ) => {
                            ::core::option::Option::unwrap_or(
                                ::core::cmp::PartialOrd::partial_cmp(&(*__self_0), &(*__arg_1_0)),
                                ::core::cmp::Ordering::Less,
                            ) == ::core::cmp::Ordering::Greater
                        }
                        (
                            &Resource::WriteExecute(ref __self_0),
                            &Resource::WriteExecute(ref __arg_1_0),
                        ) => {
                            ::core::option::Option::unwrap_or(
                                ::core::cmp::PartialOrd::partial_cmp(&(*__self_0), &(*__arg_1_0)),
                                ::core::cmp::Ordering::Less,
                            ) == ::core::cmp::Ordering::Greater
                        }
                        (
                            &Resource::ReadExecute(ref __self_0),
                            &Resource::ReadExecute(ref __arg_1_0),
                        ) => {
                            ::core::option::Option::unwrap_or(
                                ::core::cmp::PartialOrd::partial_cmp(&(*__self_0), &(*__arg_1_0)),
                                ::core::cmp::Ordering::Less,
                            ) == ::core::cmp::Ordering::Greater
                        }
                        (
                            &Resource::ReadWriteExecute(ref __self_0),
                            &Resource::ReadWriteExecute(ref __arg_1_0),
                        ) => {
                            ::core::option::Option::unwrap_or(
                                ::core::cmp::PartialOrd::partial_cmp(&(*__self_0), &(*__arg_1_0)),
                                ::core::cmp::Ordering::Less,
                            ) == ::core::cmp::Ordering::Greater
                        }
                        (&Resource::Network(ref __self_0), &Resource::Network(ref __arg_1_0)) => {
                            ::core::option::Option::unwrap_or(
                                ::core::cmp::PartialOrd::partial_cmp(&(*__self_0), &(*__arg_1_0)),
                                ::core::cmp::Ordering::Less,
                            ) == ::core::cmp::Ordering::Greater
                        }
                        _ => unsafe { ::core::intrinsics::unreachable() },
                    }
                } else {
                    __self_vi.gt(&__arg_1_vi)
                }
            }
        }
        #[inline]
        fn ge(&self, other: &Resource) -> bool {
            {
                let __self_vi = unsafe { ::core::intrinsics::discriminant_value(&*self) };
                let __arg_1_vi = unsafe { ::core::intrinsics::discriminant_value(&*other) };
                if true && __self_vi == __arg_1_vi {
                    match (&*self, &*other) {
                        (&Resource::Read(ref __self_0), &Resource::Read(ref __arg_1_0)) => {
                            ::core::option::Option::unwrap_or(
                                ::core::cmp::PartialOrd::partial_cmp(&(*__self_0), &(*__arg_1_0)),
                                ::core::cmp::Ordering::Less,
                            ) != ::core::cmp::Ordering::Less
                        }
                        (&Resource::Write(ref __self_0), &Resource::Write(ref __arg_1_0)) => {
                            ::core::option::Option::unwrap_or(
                                ::core::cmp::PartialOrd::partial_cmp(&(*__self_0), &(*__arg_1_0)),
                                ::core::cmp::Ordering::Less,
                            ) != ::core::cmp::Ordering::Less
                        }
                        (&Resource::Execute(ref __self_0), &Resource::Execute(ref __arg_1_0)) => {
                            ::core::option::Option::unwrap_or(
                                ::core::cmp::PartialOrd::partial_cmp(&(*__self_0), &(*__arg_1_0)),
                                ::core::cmp::Ordering::Less,
                            ) != ::core::cmp::Ordering::Less
                        }
                        (
                            &Resource::ReadWrite(ref __self_0),
                            &Resource::ReadWrite(ref __arg_1_0),
                        ) => {
                            ::core::option::Option::unwrap_or(
                                ::core::cmp::PartialOrd::partial_cmp(&(*__self_0), &(*__arg_1_0)),
                                ::core::cmp::Ordering::Less,
                            ) != ::core::cmp::Ordering::Less
                        }
                        (
                            &Resource::WriteExecute(ref __self_0),
                            &Resource::WriteExecute(ref __arg_1_0),
                        ) => {
                            ::core::option::Option::unwrap_or(
                                ::core::cmp::PartialOrd::partial_cmp(&(*__self_0), &(*__arg_1_0)),
                                ::core::cmp::Ordering::Less,
                            ) != ::core::cmp::Ordering::Less
                        }
                        (
                            &Resource::ReadExecute(ref __self_0),
                            &Resource::ReadExecute(ref __arg_1_0),
                        ) => {
                            ::core::option::Option::unwrap_or(
                                ::core::cmp::PartialOrd::partial_cmp(&(*__self_0), &(*__arg_1_0)),
                                ::core::cmp::Ordering::Less,
                            ) != ::core::cmp::Ordering::Less
                        }
                        (
                            &Resource::ReadWriteExecute(ref __self_0),
                            &Resource::ReadWriteExecute(ref __arg_1_0),
                        ) => {
                            ::core::option::Option::unwrap_or(
                                ::core::cmp::PartialOrd::partial_cmp(&(*__self_0), &(*__arg_1_0)),
                                ::core::cmp::Ordering::Less,
                            ) != ::core::cmp::Ordering::Less
                        }
                        (&Resource::Network(ref __self_0), &Resource::Network(ref __arg_1_0)) => {
                            ::core::option::Option::unwrap_or(
                                ::core::cmp::PartialOrd::partial_cmp(&(*__self_0), &(*__arg_1_0)),
                                ::core::cmp::Ordering::Less,
                            ) != ::core::cmp::Ordering::Less
                        }
                        _ => unsafe { ::core::intrinsics::unreachable() },
                    }
                } else {
                    __self_vi.ge(&__arg_1_vi)
                }
            }
        }
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::cmp::Ord for Resource {
        #[inline]
        fn cmp(&self, other: &Resource) -> ::core::cmp::Ordering {
            {
                let __self_vi = unsafe { ::core::intrinsics::discriminant_value(&*self) };
                let __arg_1_vi = unsafe { ::core::intrinsics::discriminant_value(&*other) };
                if true && __self_vi == __arg_1_vi {
                    match (&*self, &*other) {
                        (&Resource::Read(ref __self_0), &Resource::Read(ref __arg_1_0)) => {
                            match ::core::cmp::Ord::cmp(&(*__self_0), &(*__arg_1_0)) {
                                ::core::cmp::Ordering::Equal => ::core::cmp::Ordering::Equal,
                                cmp => cmp,
                            }
                        }
                        (&Resource::Write(ref __self_0), &Resource::Write(ref __arg_1_0)) => {
                            match ::core::cmp::Ord::cmp(&(*__self_0), &(*__arg_1_0)) {
                                ::core::cmp::Ordering::Equal => ::core::cmp::Ordering::Equal,
                                cmp => cmp,
                            }
                        }
                        (&Resource::Execute(ref __self_0), &Resource::Execute(ref __arg_1_0)) => {
                            match ::core::cmp::Ord::cmp(&(*__self_0), &(*__arg_1_0)) {
                                ::core::cmp::Ordering::Equal => ::core::cmp::Ordering::Equal,
                                cmp => cmp,
                            }
                        }
                        (
                            &Resource::ReadWrite(ref __self_0),
                            &Resource::ReadWrite(ref __arg_1_0),
                        ) => match ::core::cmp::Ord::cmp(&(*__self_0), &(*__arg_1_0)) {
                            ::core::cmp::Ordering::Equal => ::core::cmp::Ordering::Equal,
                            cmp => cmp,
                        },
                        (
                            &Resource::WriteExecute(ref __self_0),
                            &Resource::WriteExecute(ref __arg_1_0),
                        ) => match ::core::cmp::Ord::cmp(&(*__self_0), &(*__arg_1_0)) {
                            ::core::cmp::Ordering::Equal => ::core::cmp::Ordering::Equal,
                            cmp => cmp,
                        },
                        (
                            &Resource::ReadExecute(ref __self_0),
                            &Resource::ReadExecute(ref __arg_1_0),
                        ) => match ::core::cmp::Ord::cmp(&(*__self_0), &(*__arg_1_0)) {
                            ::core::cmp::Ordering::Equal => ::core::cmp::Ordering::Equal,
                            cmp => cmp,
                        },
                        (
                            &Resource::ReadWriteExecute(ref __self_0),
                            &Resource::ReadWriteExecute(ref __arg_1_0),
                        ) => match ::core::cmp::Ord::cmp(&(*__self_0), &(*__arg_1_0)) {
                            ::core::cmp::Ordering::Equal => ::core::cmp::Ordering::Equal,
                            cmp => cmp,
                        },
                        (&Resource::Network(ref __self_0), &Resource::Network(ref __arg_1_0)) => {
                            match ::core::cmp::Ord::cmp(&(*__self_0), &(*__arg_1_0)) {
                                ::core::cmp::Ordering::Equal => ::core::cmp::Ordering::Equal,
                                cmp => cmp,
                            }
                        }
                        _ => unsafe { ::core::intrinsics::unreachable() },
                    }
                } else {
                    __self_vi.cmp(&__arg_1_vi)
                }
            }
        }
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::hash::Hash for Resource {
        fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {
            match (&*self,) {
                (&Resource::Read(ref __self_0),) => {
                    ::core::hash::Hash::hash(
                        &unsafe { ::core::intrinsics::discriminant_value(self) },
                        state,
                    );
                    ::core::hash::Hash::hash(&(*__self_0), state)
                }
                (&Resource::Write(ref __self_0),) => {
                    ::core::hash::Hash::hash(
                        &unsafe { ::core::intrinsics::discriminant_value(self) },
                        state,
                    );
                    ::core::hash::Hash::hash(&(*__self_0), state)
                }
                (&Resource::Execute(ref __self_0),) => {
                    ::core::hash::Hash::hash(
                        &unsafe { ::core::intrinsics::discriminant_value(self) },
                        state,
                    );
                    ::core::hash::Hash::hash(&(*__self_0), state)
                }
                (&Resource::ReadWrite(ref __self_0),) => {
                    ::core::hash::Hash::hash(
                        &unsafe { ::core::intrinsics::discriminant_value(self) },
                        state,
                    );
                    ::core::hash::Hash::hash(&(*__self_0), state)
                }
                (&Resource::WriteExecute(ref __self_0),) => {
                    ::core::hash::Hash::hash(
                        &unsafe { ::core::intrinsics::discriminant_value(self) },
                        state,
                    );
                    ::core::hash::Hash::hash(&(*__self_0), state)
                }
                (&Resource::ReadExecute(ref __self_0),) => {
                    ::core::hash::Hash::hash(
                        &unsafe { ::core::intrinsics::discriminant_value(self) },
                        state,
                    );
                    ::core::hash::Hash::hash(&(*__self_0), state)
                }
                (&Resource::ReadWriteExecute(ref __self_0),) => {
                    ::core::hash::Hash::hash(
                        &unsafe { ::core::intrinsics::discriminant_value(self) },
                        state,
                    );
                    ::core::hash::Hash::hash(&(*__self_0), state)
                }
                (&Resource::Network(ref __self_0),) => {
                    ::core::hash::Hash::hash(
                        &unsafe { ::core::intrinsics::discriminant_value(self) },
                        state,
                    );
                    ::core::hash::Hash::hash(&(*__self_0), state)
                }
            }
        }
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::fmt::Debug for Resource {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            match (&*self,) {
                (&Resource::Read(ref __self_0),) => {
                    let mut debug_trait_builder = f.debug_tuple("Read");
                    let _ = debug_trait_builder.field(&&(*__self_0));
                    debug_trait_builder.finish()
                }
                (&Resource::Write(ref __self_0),) => {
                    let mut debug_trait_builder = f.debug_tuple("Write");
                    let _ = debug_trait_builder.field(&&(*__self_0));
                    debug_trait_builder.finish()
                }
                (&Resource::Execute(ref __self_0),) => {
                    let mut debug_trait_builder = f.debug_tuple("Execute");
                    let _ = debug_trait_builder.field(&&(*__self_0));
                    debug_trait_builder.finish()
                }
                (&Resource::ReadWrite(ref __self_0),) => {
                    let mut debug_trait_builder = f.debug_tuple("ReadWrite");
                    let _ = debug_trait_builder.field(&&(*__self_0));
                    debug_trait_builder.finish()
                }
                (&Resource::WriteExecute(ref __self_0),) => {
                    let mut debug_trait_builder = f.debug_tuple("WriteExecute");
                    let _ = debug_trait_builder.field(&&(*__self_0));
                    debug_trait_builder.finish()
                }
                (&Resource::ReadExecute(ref __self_0),) => {
                    let mut debug_trait_builder = f.debug_tuple("ReadExecute");
                    let _ = debug_trait_builder.field(&&(*__self_0));
                    debug_trait_builder.finish()
                }
                (&Resource::ReadWriteExecute(ref __self_0),) => {
                    let mut debug_trait_builder = f.debug_tuple("ReadWriteExecute");
                    let _ = debug_trait_builder.field(&&(*__self_0));
                    debug_trait_builder.finish()
                }
                (&Resource::Network(ref __self_0),) => {
                    let mut debug_trait_builder = f.debug_tuple("Network");
                    let _ = debug_trait_builder.field(&&(*__self_0));
                    debug_trait_builder.finish()
                }
            }
        }
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::clone::Clone for Resource {
        #[inline]
        fn clone(&self) -> Resource {
            match (&*self,) {
                (&Resource::Read(ref __self_0),) => {
                    Resource::Read(::core::clone::Clone::clone(&(*__self_0)))
                }
                (&Resource::Write(ref __self_0),) => {
                    Resource::Write(::core::clone::Clone::clone(&(*__self_0)))
                }
                (&Resource::Execute(ref __self_0),) => {
                    Resource::Execute(::core::clone::Clone::clone(&(*__self_0)))
                }
                (&Resource::ReadWrite(ref __self_0),) => {
                    Resource::ReadWrite(::core::clone::Clone::clone(&(*__self_0)))
                }
                (&Resource::WriteExecute(ref __self_0),) => {
                    Resource::WriteExecute(::core::clone::Clone::clone(&(*__self_0)))
                }
                (&Resource::ReadExecute(ref __self_0),) => {
                    Resource::ReadExecute(::core::clone::Clone::clone(&(*__self_0)))
                }
                (&Resource::ReadWriteExecute(ref __self_0),) => {
                    Resource::ReadWriteExecute(::core::clone::Clone::clone(&(*__self_0)))
                }
                (&Resource::Network(ref __self_0),) => {
                    Resource::Network(::core::clone::Clone::clone(&(*__self_0)))
                }
            }
        }
    }
    impl fmt::Display for Resource {
        fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
            let value = match self {
                Self::Read(path) => {
                    let res = ::alloc::fmt::format(::core::fmt::Arguments::new_v1(
                        &["r-"],
                        &match (&path.display(),) {
                            (arg0,) => [::core::fmt::ArgumentV1::new(
                                arg0,
                                ::core::fmt::Display::fmt,
                            )],
                        },
                    ));
                    res
                }
                Self::Write(path) => {
                    let res = ::alloc::fmt::format(::core::fmt::Arguments::new_v1(
                        &["w-"],
                        &match (&path.display(),) {
                            (arg0,) => [::core::fmt::ArgumentV1::new(
                                arg0,
                                ::core::fmt::Display::fmt,
                            )],
                        },
                    ));
                    res
                }
                Self::Execute(path) => {
                    let res = ::alloc::fmt::format(::core::fmt::Arguments::new_v1(
                        &["x-"],
                        &match (&path.display(),) {
                            (arg0,) => [::core::fmt::ArgumentV1::new(
                                arg0,
                                ::core::fmt::Display::fmt,
                            )],
                        },
                    ));
                    res
                }
                Self::ReadWrite(path) => {
                    let res = ::alloc::fmt::format(::core::fmt::Arguments::new_v1(
                        &["rw-"],
                        &match (&path.display(),) {
                            (arg0,) => [::core::fmt::ArgumentV1::new(
                                arg0,
                                ::core::fmt::Display::fmt,
                            )],
                        },
                    ));
                    res
                }
                Self::WriteExecute(path) => {
                    let res = ::alloc::fmt::format(::core::fmt::Arguments::new_v1(
                        &["wx-"],
                        &match (&path.display(),) {
                            (arg0,) => [::core::fmt::ArgumentV1::new(
                                arg0,
                                ::core::fmt::Display::fmt,
                            )],
                        },
                    ));
                    res
                }
                Self::ReadExecute(path) => {
                    let res = ::alloc::fmt::format(::core::fmt::Arguments::new_v1(
                        &["rx-"],
                        &match (&path.display(),) {
                            (arg0,) => [::core::fmt::ArgumentV1::new(
                                arg0,
                                ::core::fmt::Display::fmt,
                            )],
                        },
                    ));
                    res
                }
                Self::ReadWriteExecute(path) => {
                    let res = ::alloc::fmt::format(::core::fmt::Arguments::new_v1(
                        &["rwx-"],
                        &match (&path.display(),) {
                            (arg0,) => [::core::fmt::ArgumentV1::new(
                                arg0,
                                ::core::fmt::Display::fmt,
                            )],
                        },
                    ));
                    res
                }
                Self::Network(n) => {
                    let res = ::alloc::fmt::format(::core::fmt::Arguments::new_v1(
                        &["n-"],
                        &match (&n,) {
                            (arg0,) => [::core::fmt::ArgumentV1::new(
                                arg0,
                                ::core::fmt::Display::fmt,
                            )],
                        },
                    ));
                    res
                }
            };
            f.write_fmt(::core::fmt::Arguments::new_v1(
                &[""],
                &match (&value,) {
                    (arg0,) => [::core::fmt::ArgumentV1::new(
                        arg0,
                        ::core::fmt::Display::fmt,
                    )],
                },
            ))
        }
    }
    pub struct ResourceRequest {
        resource: Resource,
        reason: Option<String>,
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::clone::Clone for ResourceRequest {
        #[inline]
        fn clone(&self) -> ResourceRequest {
            match *self {
                ResourceRequest {
                    resource: ref __self_0_0,
                    reason: ref __self_0_1,
                } => ResourceRequest {
                    resource: ::core::clone::Clone::clone(&(*__self_0_0)),
                    reason: ::core::clone::Clone::clone(&(*__self_0_1)),
                },
            }
        }
    }
    #[doc(hidden)]
    #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
    const _: () = {
        #[allow(rust_2018_idioms, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl _serde::Serialize for ResourceRequest {
            fn serialize<__S>(
                &self,
                __serializer: __S,
            ) -> _serde::export::Result<__S::Ok, __S::Error>
            where
                __S: _serde::Serializer,
            {
                let mut __serde_state = match _serde::Serializer::serialize_struct(
                    __serializer,
                    "ResourceRequest",
                    false as usize + 1 + 1,
                ) {
                    _serde::export::Ok(__val) => __val,
                    _serde::export::Err(__err) => {
                        return _serde::export::Err(__err);
                    }
                };
                match _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "resource",
                    &self.resource,
                ) {
                    _serde::export::Ok(__val) => __val,
                    _serde::export::Err(__err) => {
                        return _serde::export::Err(__err);
                    }
                };
                match _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "reason",
                    &self.reason,
                ) {
                    _serde::export::Ok(__val) => __val,
                    _serde::export::Err(__err) => {
                        return _serde::export::Err(__err);
                    }
                };
                _serde::ser::SerializeStruct::end(__serde_state)
            }
        }
    };
    #[doc(hidden)]
    #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
    const _: () = {
        #[allow(rust_2018_idioms, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl<'de> _serde::Deserialize<'de> for ResourceRequest {
            fn deserialize<__D>(__deserializer: __D) -> _serde::export::Result<Self, __D::Error>
            where
                __D: _serde::Deserializer<'de>,
            {
                #[allow(non_camel_case_types)]
                enum __Field {
                    __field0,
                    __field1,
                    __ignore,
                }
                struct __FieldVisitor;
                impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                    type Value = __Field;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::export::Formatter,
                    ) -> _serde::export::fmt::Result {
                        _serde::export::Formatter::write_str(__formatter, "field identifier")
                    }
                    fn visit_u64<__E>(
                        self,
                        __value: u64,
                    ) -> _serde::export::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            0u64 => _serde::export::Ok(__Field::__field0),
                            1u64 => _serde::export::Ok(__Field::__field1),
                            _ => _serde::export::Err(_serde::de::Error::invalid_value(
                                _serde::de::Unexpected::Unsigned(__value),
                                &"field index 0 <= i < 2",
                            )),
                        }
                    }
                    fn visit_str<__E>(
                        self,
                        __value: &str,
                    ) -> _serde::export::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            "resource" => _serde::export::Ok(__Field::__field0),
                            "reason" => _serde::export::Ok(__Field::__field1),
                            _ => _serde::export::Ok(__Field::__ignore),
                        }
                    }
                    fn visit_bytes<__E>(
                        self,
                        __value: &[u8],
                    ) -> _serde::export::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            b"resource" => _serde::export::Ok(__Field::__field0),
                            b"reason" => _serde::export::Ok(__Field::__field1),
                            _ => _serde::export::Ok(__Field::__ignore),
                        }
                    }
                }
                impl<'de> _serde::Deserialize<'de> for __Field {
                    #[inline]
                    fn deserialize<__D>(
                        __deserializer: __D,
                    ) -> _serde::export::Result<Self, __D::Error>
                    where
                        __D: _serde::Deserializer<'de>,
                    {
                        _serde::Deserializer::deserialize_identifier(__deserializer, __FieldVisitor)
                    }
                }
                struct __Visitor<'de> {
                    marker: _serde::export::PhantomData<ResourceRequest>,
                    lifetime: _serde::export::PhantomData<&'de ()>,
                }
                impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                    type Value = ResourceRequest;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::export::Formatter,
                    ) -> _serde::export::fmt::Result {
                        _serde::export::Formatter::write_str(__formatter, "struct ResourceRequest")
                    }
                    #[inline]
                    fn visit_seq<__A>(
                        self,
                        mut __seq: __A,
                    ) -> _serde::export::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::SeqAccess<'de>,
                    {
                        let __field0 =
                            match match _serde::de::SeqAccess::next_element::<Resource>(&mut __seq)
                            {
                                _serde::export::Ok(__val) => __val,
                                _serde::export::Err(__err) => {
                                    return _serde::export::Err(__err);
                                }
                            } {
                                _serde::export::Some(__value) => __value,
                                _serde::export::None => {
                                    return _serde::export::Err(_serde::de::Error::invalid_length(
                                        0usize,
                                        &"struct ResourceRequest with 2 elements",
                                    ));
                                }
                            };
                        let __field1 = match match _serde::de::SeqAccess::next_element::<
                            Option<String>,
                        >(&mut __seq)
                        {
                            _serde::export::Ok(__val) => __val,
                            _serde::export::Err(__err) => {
                                return _serde::export::Err(__err);
                            }
                        } {
                            _serde::export::Some(__value) => __value,
                            _serde::export::None => {
                                return _serde::export::Err(_serde::de::Error::invalid_length(
                                    1usize,
                                    &"struct ResourceRequest with 2 elements",
                                ));
                            }
                        };
                        _serde::export::Ok(ResourceRequest {
                            resource: __field0,
                            reason: __field1,
                        })
                    }
                    #[inline]
                    fn visit_map<__A>(
                        self,
                        mut __map: __A,
                    ) -> _serde::export::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::MapAccess<'de>,
                    {
                        let mut __field0: _serde::export::Option<Resource> = _serde::export::None;
                        let mut __field1: _serde::export::Option<Option<String>> =
                            _serde::export::None;
                        while let _serde::export::Some(__key) =
                            match _serde::de::MapAccess::next_key::<__Field>(&mut __map) {
                                _serde::export::Ok(__val) => __val,
                                _serde::export::Err(__err) => {
                                    return _serde::export::Err(__err);
                                }
                            }
                        {
                            match __key {
                                __Field::__field0 => {
                                    if _serde::export::Option::is_some(&__field0) {
                                        return _serde::export::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "resource",
                                            ),
                                        );
                                    }
                                    __field0 = _serde::export::Some(
                                        match _serde::de::MapAccess::next_value::<Resource>(
                                            &mut __map,
                                        ) {
                                            _serde::export::Ok(__val) => __val,
                                            _serde::export::Err(__err) => {
                                                return _serde::export::Err(__err);
                                            }
                                        },
                                    );
                                }
                                __Field::__field1 => {
                                    if _serde::export::Option::is_some(&__field1) {
                                        return _serde::export::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "reason",
                                            ),
                                        );
                                    }
                                    __field1 = _serde::export::Some(
                                        match _serde::de::MapAccess::next_value::<Option<String>>(
                                            &mut __map,
                                        ) {
                                            _serde::export::Ok(__val) => __val,
                                            _serde::export::Err(__err) => {
                                                return _serde::export::Err(__err);
                                            }
                                        },
                                    );
                                }
                                _ => {
                                    let _ = match _serde::de::MapAccess::next_value::<
                                        _serde::de::IgnoredAny,
                                    >(&mut __map)
                                    {
                                        _serde::export::Ok(__val) => __val,
                                        _serde::export::Err(__err) => {
                                            return _serde::export::Err(__err);
                                        }
                                    };
                                }
                            }
                        }
                        let __field0 = match __field0 {
                            _serde::export::Some(__field0) => __field0,
                            _serde::export::None => {
                                match _serde::private::de::missing_field("resource") {
                                    _serde::export::Ok(__val) => __val,
                                    _serde::export::Err(__err) => {
                                        return _serde::export::Err(__err);
                                    }
                                }
                            }
                        };
                        let __field1 = match __field1 {
                            _serde::export::Some(__field1) => __field1,
                            _serde::export::None => {
                                match _serde::private::de::missing_field("reason") {
                                    _serde::export::Ok(__val) => __val,
                                    _serde::export::Err(__err) => {
                                        return _serde::export::Err(__err);
                                    }
                                }
                            }
                        };
                        _serde::export::Ok(ResourceRequest {
                            resource: __field0,
                            reason: __field1,
                        })
                    }
                }
                const FIELDS: &'static [&'static str] = &["resource", "reason"];
                _serde::Deserializer::deserialize_struct(
                    __deserializer,
                    "ResourceRequest",
                    FIELDS,
                    __Visitor {
                        marker: _serde::export::PhantomData::<ResourceRequest>,
                        lifetime: _serde::export::PhantomData,
                    },
                )
            }
        }
    };
    impl ::core::marker::StructuralPartialEq for ResourceRequest {}
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::cmp::PartialEq for ResourceRequest {
        #[inline]
        fn eq(&self, other: &ResourceRequest) -> bool {
            match *other {
                ResourceRequest {
                    resource: ref __self_1_0,
                    reason: ref __self_1_1,
                } => match *self {
                    ResourceRequest {
                        resource: ref __self_0_0,
                        reason: ref __self_0_1,
                    } => (*__self_0_0) == (*__self_1_0) && (*__self_0_1) == (*__self_1_1),
                },
            }
        }
        #[inline]
        fn ne(&self, other: &ResourceRequest) -> bool {
            match *other {
                ResourceRequest {
                    resource: ref __self_1_0,
                    reason: ref __self_1_1,
                } => match *self {
                    ResourceRequest {
                        resource: ref __self_0_0,
                        reason: ref __self_0_1,
                    } => (*__self_0_0) != (*__self_1_0) || (*__self_0_1) != (*__self_1_1),
                },
            }
        }
    }
    impl ::core::marker::StructuralEq for ResourceRequest {}
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::cmp::Eq for ResourceRequest {
        #[inline]
        #[doc(hidden)]
        fn assert_receiver_is_total_eq(&self) -> () {
            {
                let _: ::core::cmp::AssertParamIsEq<Resource>;
                let _: ::core::cmp::AssertParamIsEq<Option<String>>;
            }
        }
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::cmp::PartialOrd for ResourceRequest {
        #[inline]
        fn partial_cmp(
            &self,
            other: &ResourceRequest,
        ) -> ::core::option::Option<::core::cmp::Ordering> {
            match *other {
                ResourceRequest {
                    resource: ref __self_1_0,
                    reason: ref __self_1_1,
                } => match *self {
                    ResourceRequest {
                        resource: ref __self_0_0,
                        reason: ref __self_0_1,
                    } => match ::core::cmp::PartialOrd::partial_cmp(&(*__self_0_0), &(*__self_1_0))
                    {
                        ::core::option::Option::Some(::core::cmp::Ordering::Equal) => {
                            match ::core::cmp::PartialOrd::partial_cmp(
                                &(*__self_0_1),
                                &(*__self_1_1),
                            ) {
                                ::core::option::Option::Some(::core::cmp::Ordering::Equal) => {
                                    ::core::option::Option::Some(::core::cmp::Ordering::Equal)
                                }
                                cmp => cmp,
                            }
                        }
                        cmp => cmp,
                    },
                },
            }
        }
        #[inline]
        fn lt(&self, other: &ResourceRequest) -> bool {
            match *other {
                ResourceRequest {
                    resource: ref __self_1_0,
                    reason: ref __self_1_1,
                } => match *self {
                    ResourceRequest {
                        resource: ref __self_0_0,
                        reason: ref __self_0_1,
                    } => {
                        ::core::cmp::Ordering::then_with(
                            ::core::option::Option::unwrap_or(
                                ::core::cmp::PartialOrd::partial_cmp(
                                    &(*__self_0_0),
                                    &(*__self_1_0),
                                ),
                                ::core::cmp::Ordering::Equal,
                            ),
                            || {
                                ::core::option::Option::unwrap_or(
                                    ::core::cmp::PartialOrd::partial_cmp(
                                        &(*__self_0_1),
                                        &(*__self_1_1),
                                    ),
                                    ::core::cmp::Ordering::Greater,
                                )
                            },
                        ) == ::core::cmp::Ordering::Less
                    }
                },
            }
        }
        #[inline]
        fn le(&self, other: &ResourceRequest) -> bool {
            match *other {
                ResourceRequest {
                    resource: ref __self_1_0,
                    reason: ref __self_1_1,
                } => match *self {
                    ResourceRequest {
                        resource: ref __self_0_0,
                        reason: ref __self_0_1,
                    } => {
                        ::core::cmp::Ordering::then_with(
                            ::core::option::Option::unwrap_or(
                                ::core::cmp::PartialOrd::partial_cmp(
                                    &(*__self_0_0),
                                    &(*__self_1_0),
                                ),
                                ::core::cmp::Ordering::Equal,
                            ),
                            || {
                                ::core::option::Option::unwrap_or(
                                    ::core::cmp::PartialOrd::partial_cmp(
                                        &(*__self_0_1),
                                        &(*__self_1_1),
                                    ),
                                    ::core::cmp::Ordering::Greater,
                                )
                            },
                        ) != ::core::cmp::Ordering::Greater
                    }
                },
            }
        }
        #[inline]
        fn gt(&self, other: &ResourceRequest) -> bool {
            match *other {
                ResourceRequest {
                    resource: ref __self_1_0,
                    reason: ref __self_1_1,
                } => match *self {
                    ResourceRequest {
                        resource: ref __self_0_0,
                        reason: ref __self_0_1,
                    } => {
                        ::core::cmp::Ordering::then_with(
                            ::core::option::Option::unwrap_or(
                                ::core::cmp::PartialOrd::partial_cmp(
                                    &(*__self_0_0),
                                    &(*__self_1_0),
                                ),
                                ::core::cmp::Ordering::Equal,
                            ),
                            || {
                                ::core::option::Option::unwrap_or(
                                    ::core::cmp::PartialOrd::partial_cmp(
                                        &(*__self_0_1),
                                        &(*__self_1_1),
                                    ),
                                    ::core::cmp::Ordering::Less,
                                )
                            },
                        ) == ::core::cmp::Ordering::Greater
                    }
                },
            }
        }
        #[inline]
        fn ge(&self, other: &ResourceRequest) -> bool {
            match *other {
                ResourceRequest {
                    resource: ref __self_1_0,
                    reason: ref __self_1_1,
                } => match *self {
                    ResourceRequest {
                        resource: ref __self_0_0,
                        reason: ref __self_0_1,
                    } => {
                        ::core::cmp::Ordering::then_with(
                            ::core::option::Option::unwrap_or(
                                ::core::cmp::PartialOrd::partial_cmp(
                                    &(*__self_0_0),
                                    &(*__self_1_0),
                                ),
                                ::core::cmp::Ordering::Equal,
                            ),
                            || {
                                ::core::option::Option::unwrap_or(
                                    ::core::cmp::PartialOrd::partial_cmp(
                                        &(*__self_0_1),
                                        &(*__self_1_1),
                                    ),
                                    ::core::cmp::Ordering::Less,
                                )
                            },
                        ) != ::core::cmp::Ordering::Less
                    }
                },
            }
        }
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::cmp::Ord for ResourceRequest {
        #[inline]
        fn cmp(&self, other: &ResourceRequest) -> ::core::cmp::Ordering {
            match *other {
                ResourceRequest {
                    resource: ref __self_1_0,
                    reason: ref __self_1_1,
                } => match *self {
                    ResourceRequest {
                        resource: ref __self_0_0,
                        reason: ref __self_0_1,
                    } => match ::core::cmp::Ord::cmp(&(*__self_0_0), &(*__self_1_0)) {
                        ::core::cmp::Ordering::Equal => {
                            match ::core::cmp::Ord::cmp(&(*__self_0_1), &(*__self_1_1)) {
                                ::core::cmp::Ordering::Equal => ::core::cmp::Ordering::Equal,
                                cmp => cmp,
                            }
                        }
                        cmp => cmp,
                    },
                },
            }
        }
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::hash::Hash for ResourceRequest {
        fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {
            match *self {
                ResourceRequest {
                    resource: ref __self_0_0,
                    reason: ref __self_0_1,
                } => {
                    ::core::hash::Hash::hash(&(*__self_0_0), state);
                    ::core::hash::Hash::hash(&(*__self_0_1), state)
                }
            }
        }
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::fmt::Debug for ResourceRequest {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            match *self {
                ResourceRequest {
                    resource: ref __self_0_0,
                    reason: ref __self_0_1,
                } => {
                    let mut debug_trait_builder = f.debug_struct("ResourceRequest");
                    let _ = debug_trait_builder.field("resource", &&(*__self_0_0));
                    let _ = debug_trait_builder.field("reason", &&(*__self_0_1));
                    debug_trait_builder.finish()
                }
            }
        }
    }
    impl ResourceRequest {
        pub fn new(resource: Resource, reason: Option<String>) -> Self {
            Self { resource, reason }
        }
        pub fn resource(&self) -> &Resource {
            &self.resource
        }
        pub fn reason(&self) -> &Option<String> {
            &self.reason
        }
    }
    pub enum RequestResult {
        Granted,
        Denied,
    }
    #[doc(hidden)]
    #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
    const _: () = {
        #[allow(rust_2018_idioms, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl _serde::Serialize for RequestResult {
            fn serialize<__S>(
                &self,
                __serializer: __S,
            ) -> _serde::export::Result<__S::Ok, __S::Error>
            where
                __S: _serde::Serializer,
            {
                match *self {
                    RequestResult::Granted => _serde::Serializer::serialize_unit_variant(
                        __serializer,
                        "RequestResult",
                        0u32,
                        "Granted",
                    ),
                    RequestResult::Denied => _serde::Serializer::serialize_unit_variant(
                        __serializer,
                        "RequestResult",
                        1u32,
                        "Denied",
                    ),
                }
            }
        }
    };
    #[doc(hidden)]
    #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
    const _: () = {
        #[allow(rust_2018_idioms, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl<'de> _serde::Deserialize<'de> for RequestResult {
            fn deserialize<__D>(__deserializer: __D) -> _serde::export::Result<Self, __D::Error>
            where
                __D: _serde::Deserializer<'de>,
            {
                #[allow(non_camel_case_types)]
                enum __Field {
                    __field0,
                    __field1,
                }
                struct __FieldVisitor;
                impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                    type Value = __Field;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::export::Formatter,
                    ) -> _serde::export::fmt::Result {
                        _serde::export::Formatter::write_str(__formatter, "variant identifier")
                    }
                    fn visit_u64<__E>(
                        self,
                        __value: u64,
                    ) -> _serde::export::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            0u64 => _serde::export::Ok(__Field::__field0),
                            1u64 => _serde::export::Ok(__Field::__field1),
                            _ => _serde::export::Err(_serde::de::Error::invalid_value(
                                _serde::de::Unexpected::Unsigned(__value),
                                &"variant index 0 <= i < 2",
                            )),
                        }
                    }
                    fn visit_str<__E>(
                        self,
                        __value: &str,
                    ) -> _serde::export::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            "Granted" => _serde::export::Ok(__Field::__field0),
                            "Denied" => _serde::export::Ok(__Field::__field1),
                            _ => _serde::export::Err(_serde::de::Error::unknown_variant(
                                __value, VARIANTS,
                            )),
                        }
                    }
                    fn visit_bytes<__E>(
                        self,
                        __value: &[u8],
                    ) -> _serde::export::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            b"Granted" => _serde::export::Ok(__Field::__field0),
                            b"Denied" => _serde::export::Ok(__Field::__field1),
                            _ => {
                                let __value = &_serde::export::from_utf8_lossy(__value);
                                _serde::export::Err(_serde::de::Error::unknown_variant(
                                    __value, VARIANTS,
                                ))
                            }
                        }
                    }
                }
                impl<'de> _serde::Deserialize<'de> for __Field {
                    #[inline]
                    fn deserialize<__D>(
                        __deserializer: __D,
                    ) -> _serde::export::Result<Self, __D::Error>
                    where
                        __D: _serde::Deserializer<'de>,
                    {
                        _serde::Deserializer::deserialize_identifier(__deserializer, __FieldVisitor)
                    }
                }
                struct __Visitor<'de> {
                    marker: _serde::export::PhantomData<RequestResult>,
                    lifetime: _serde::export::PhantomData<&'de ()>,
                }
                impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                    type Value = RequestResult;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::export::Formatter,
                    ) -> _serde::export::fmt::Result {
                        _serde::export::Formatter::write_str(__formatter, "enum RequestResult")
                    }
                    fn visit_enum<__A>(
                        self,
                        __data: __A,
                    ) -> _serde::export::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::EnumAccess<'de>,
                    {
                        match match _serde::de::EnumAccess::variant(__data) {
                            _serde::export::Ok(__val) => __val,
                            _serde::export::Err(__err) => {
                                return _serde::export::Err(__err);
                            }
                        } {
                            (__Field::__field0, __variant) => {
                                match _serde::de::VariantAccess::unit_variant(__variant) {
                                    _serde::export::Ok(__val) => __val,
                                    _serde::export::Err(__err) => {
                                        return _serde::export::Err(__err);
                                    }
                                };
                                _serde::export::Ok(RequestResult::Granted)
                            }
                            (__Field::__field1, __variant) => {
                                match _serde::de::VariantAccess::unit_variant(__variant) {
                                    _serde::export::Ok(__val) => __val,
                                    _serde::export::Err(__err) => {
                                        return _serde::export::Err(__err);
                                    }
                                };
                                _serde::export::Ok(RequestResult::Denied)
                            }
                        }
                    }
                }
                const VARIANTS: &'static [&'static str] = &["Granted", "Denied"];
                _serde::Deserializer::deserialize_enum(
                    __deserializer,
                    "RequestResult",
                    VARIANTS,
                    __Visitor {
                        marker: _serde::export::PhantomData::<RequestResult>,
                        lifetime: _serde::export::PhantomData,
                    },
                )
            }
        }
    };
    impl ::core::marker::StructuralPartialEq for RequestResult {}
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::cmp::PartialEq for RequestResult {
        #[inline]
        fn eq(&self, other: &RequestResult) -> bool {
            {
                let __self_vi = unsafe { ::core::intrinsics::discriminant_value(&*self) };
                let __arg_1_vi = unsafe { ::core::intrinsics::discriminant_value(&*other) };
                if true && __self_vi == __arg_1_vi {
                    match (&*self, &*other) {
                        _ => true,
                    }
                } else {
                    false
                }
            }
        }
    }
    impl ::core::marker::StructuralEq for RequestResult {}
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::cmp::Eq for RequestResult {
        #[inline]
        #[doc(hidden)]
        fn assert_receiver_is_total_eq(&self) -> () {
            {}
        }
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::cmp::PartialOrd for RequestResult {
        #[inline]
        fn partial_cmp(
            &self,
            other: &RequestResult,
        ) -> ::core::option::Option<::core::cmp::Ordering> {
            {
                let __self_vi = unsafe { ::core::intrinsics::discriminant_value(&*self) };
                let __arg_1_vi = unsafe { ::core::intrinsics::discriminant_value(&*other) };
                if true && __self_vi == __arg_1_vi {
                    match (&*self, &*other) {
                        _ => ::core::option::Option::Some(::core::cmp::Ordering::Equal),
                    }
                } else {
                    __self_vi.partial_cmp(&__arg_1_vi)
                }
            }
        }
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::cmp::Ord for RequestResult {
        #[inline]
        fn cmp(&self, other: &RequestResult) -> ::core::cmp::Ordering {
            {
                let __self_vi = unsafe { ::core::intrinsics::discriminant_value(&*self) };
                let __arg_1_vi = unsafe { ::core::intrinsics::discriminant_value(&*other) };
                if true && __self_vi == __arg_1_vi {
                    match (&*self, &*other) {
                        _ => ::core::cmp::Ordering::Equal,
                    }
                } else {
                    __self_vi.cmp(&__arg_1_vi)
                }
            }
        }
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::hash::Hash for RequestResult {
        fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {
            match (&*self,) {
                _ => ::core::hash::Hash::hash(
                    &unsafe { ::core::intrinsics::discriminant_value(self) },
                    state,
                ),
            }
        }
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::fmt::Debug for RequestResult {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            match (&*self,) {
                (&RequestResult::Granted,) => {
                    let mut debug_trait_builder = f.debug_tuple("Granted");
                    debug_trait_builder.finish()
                }
                (&RequestResult::Denied,) => {
                    let mut debug_trait_builder = f.debug_tuple("Denied");
                    debug_trait_builder.finish()
                }
            }
        }
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::clone::Clone for RequestResult {
        #[inline]
        fn clone(&self) -> RequestResult {
            {
                *self
            }
        }
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::marker::Copy for RequestResult {}
    struct Permission {
        resource: Resource,
        granted: Vec<(String, String)>,
    }
    #[doc(hidden)]
    #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
    const _: () = {
        #[allow(rust_2018_idioms, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl _serde::Serialize for Permission {
            fn serialize<__S>(
                &self,
                __serializer: __S,
            ) -> _serde::export::Result<__S::Ok, __S::Error>
            where
                __S: _serde::Serializer,
            {
                let mut __serde_state = match _serde::Serializer::serialize_struct(
                    __serializer,
                    "Permission",
                    false as usize + 1 + 1,
                ) {
                    _serde::export::Ok(__val) => __val,
                    _serde::export::Err(__err) => {
                        return _serde::export::Err(__err);
                    }
                };
                match _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "resource",
                    &self.resource,
                ) {
                    _serde::export::Ok(__val) => __val,
                    _serde::export::Err(__err) => {
                        return _serde::export::Err(__err);
                    }
                };
                match _serde::ser::SerializeStruct::serialize_field(
                    &mut __serde_state,
                    "granted",
                    &self.granted,
                ) {
                    _serde::export::Ok(__val) => __val,
                    _serde::export::Err(__err) => {
                        return _serde::export::Err(__err);
                    }
                };
                _serde::ser::SerializeStruct::end(__serde_state)
            }
        }
    };
    #[doc(hidden)]
    #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
    const _: () = {
        #[allow(rust_2018_idioms, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl<'de> _serde::Deserialize<'de> for Permission {
            fn deserialize<__D>(__deserializer: __D) -> _serde::export::Result<Self, __D::Error>
            where
                __D: _serde::Deserializer<'de>,
            {
                #[allow(non_camel_case_types)]
                enum __Field {
                    __field0,
                    __field1,
                    __ignore,
                }
                struct __FieldVisitor;
                impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                    type Value = __Field;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::export::Formatter,
                    ) -> _serde::export::fmt::Result {
                        _serde::export::Formatter::write_str(__formatter, "field identifier")
                    }
                    fn visit_u64<__E>(
                        self,
                        __value: u64,
                    ) -> _serde::export::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            0u64 => _serde::export::Ok(__Field::__field0),
                            1u64 => _serde::export::Ok(__Field::__field1),
                            _ => _serde::export::Err(_serde::de::Error::invalid_value(
                                _serde::de::Unexpected::Unsigned(__value),
                                &"field index 0 <= i < 2",
                            )),
                        }
                    }
                    fn visit_str<__E>(
                        self,
                        __value: &str,
                    ) -> _serde::export::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            "resource" => _serde::export::Ok(__Field::__field0),
                            "granted" => _serde::export::Ok(__Field::__field1),
                            _ => _serde::export::Ok(__Field::__ignore),
                        }
                    }
                    fn visit_bytes<__E>(
                        self,
                        __value: &[u8],
                    ) -> _serde::export::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            b"resource" => _serde::export::Ok(__Field::__field0),
                            b"granted" => _serde::export::Ok(__Field::__field1),
                            _ => _serde::export::Ok(__Field::__ignore),
                        }
                    }
                }
                impl<'de> _serde::Deserialize<'de> for __Field {
                    #[inline]
                    fn deserialize<__D>(
                        __deserializer: __D,
                    ) -> _serde::export::Result<Self, __D::Error>
                    where
                        __D: _serde::Deserializer<'de>,
                    {
                        _serde::Deserializer::deserialize_identifier(__deserializer, __FieldVisitor)
                    }
                }
                struct __Visitor<'de> {
                    marker: _serde::export::PhantomData<Permission>,
                    lifetime: _serde::export::PhantomData<&'de ()>,
                }
                impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                    type Value = Permission;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::export::Formatter,
                    ) -> _serde::export::fmt::Result {
                        _serde::export::Formatter::write_str(__formatter, "struct Permission")
                    }
                    #[inline]
                    fn visit_seq<__A>(
                        self,
                        mut __seq: __A,
                    ) -> _serde::export::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::SeqAccess<'de>,
                    {
                        let __field0 =
                            match match _serde::de::SeqAccess::next_element::<Resource>(&mut __seq)
                            {
                                _serde::export::Ok(__val) => __val,
                                _serde::export::Err(__err) => {
                                    return _serde::export::Err(__err);
                                }
                            } {
                                _serde::export::Some(__value) => __value,
                                _serde::export::None => {
                                    return _serde::export::Err(_serde::de::Error::invalid_length(
                                        0usize,
                                        &"struct Permission with 2 elements",
                                    ));
                                }
                            };
                        let __field1 = match match _serde::de::SeqAccess::next_element::<
                            Vec<(String, String)>,
                        >(&mut __seq)
                        {
                            _serde::export::Ok(__val) => __val,
                            _serde::export::Err(__err) => {
                                return _serde::export::Err(__err);
                            }
                        } {
                            _serde::export::Some(__value) => __value,
                            _serde::export::None => {
                                return _serde::export::Err(_serde::de::Error::invalid_length(
                                    1usize,
                                    &"struct Permission with 2 elements",
                                ));
                            }
                        };
                        _serde::export::Ok(Permission {
                            resource: __field0,
                            granted: __field1,
                        })
                    }
                    #[inline]
                    fn visit_map<__A>(
                        self,
                        mut __map: __A,
                    ) -> _serde::export::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::MapAccess<'de>,
                    {
                        let mut __field0: _serde::export::Option<Resource> = _serde::export::None;
                        let mut __field1: _serde::export::Option<Vec<(String, String)>> =
                            _serde::export::None;
                        while let _serde::export::Some(__key) =
                            match _serde::de::MapAccess::next_key::<__Field>(&mut __map) {
                                _serde::export::Ok(__val) => __val,
                                _serde::export::Err(__err) => {
                                    return _serde::export::Err(__err);
                                }
                            }
                        {
                            match __key {
                                __Field::__field0 => {
                                    if _serde::export::Option::is_some(&__field0) {
                                        return _serde::export::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "resource",
                                            ),
                                        );
                                    }
                                    __field0 = _serde::export::Some(
                                        match _serde::de::MapAccess::next_value::<Resource>(
                                            &mut __map,
                                        ) {
                                            _serde::export::Ok(__val) => __val,
                                            _serde::export::Err(__err) => {
                                                return _serde::export::Err(__err);
                                            }
                                        },
                                    );
                                }
                                __Field::__field1 => {
                                    if _serde::export::Option::is_some(&__field1) {
                                        return _serde::export::Err(
                                            <__A::Error as _serde::de::Error>::duplicate_field(
                                                "granted",
                                            ),
                                        );
                                    }
                                    __field1 = _serde::export::Some(
                                        match _serde::de::MapAccess::next_value::<
                                            Vec<(String, String)>,
                                        >(&mut __map)
                                        {
                                            _serde::export::Ok(__val) => __val,
                                            _serde::export::Err(__err) => {
                                                return _serde::export::Err(__err);
                                            }
                                        },
                                    );
                                }
                                _ => {
                                    let _ = match _serde::de::MapAccess::next_value::<
                                        _serde::de::IgnoredAny,
                                    >(&mut __map)
                                    {
                                        _serde::export::Ok(__val) => __val,
                                        _serde::export::Err(__err) => {
                                            return _serde::export::Err(__err);
                                        }
                                    };
                                }
                            }
                        }
                        let __field0 = match __field0 {
                            _serde::export::Some(__field0) => __field0,
                            _serde::export::None => {
                                match _serde::private::de::missing_field("resource") {
                                    _serde::export::Ok(__val) => __val,
                                    _serde::export::Err(__err) => {
                                        return _serde::export::Err(__err);
                                    }
                                }
                            }
                        };
                        let __field1 = match __field1 {
                            _serde::export::Some(__field1) => __field1,
                            _serde::export::None => {
                                match _serde::private::de::missing_field("granted") {
                                    _serde::export::Ok(__val) => __val,
                                    _serde::export::Err(__err) => {
                                        return _serde::export::Err(__err);
                                    }
                                }
                            }
                        };
                        _serde::export::Ok(Permission {
                            resource: __field0,
                            granted: __field1,
                        })
                    }
                }
                const FIELDS: &'static [&'static str] = &["resource", "granted"];
                _serde::Deserializer::deserialize_struct(
                    __deserializer,
                    "Permission",
                    FIELDS,
                    __Visitor {
                        marker: _serde::export::PhantomData::<Permission>,
                        lifetime: _serde::export::PhantomData,
                    },
                )
            }
        }
    };
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::fmt::Debug for Permission {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            match *self {
                Permission {
                    resource: ref __self_0_0,
                    granted: ref __self_0_1,
                } => {
                    let mut debug_trait_builder = f.debug_struct("Permission");
                    let _ = debug_trait_builder.field("resource", &&(*__self_0_0));
                    let _ = debug_trait_builder.field("granted", &&(*__self_0_1));
                    debug_trait_builder.finish()
                }
            }
        }
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::clone::Clone for Permission {
        #[inline]
        fn clone(&self) -> Permission {
            match *self {
                Permission {
                    resource: ref __self_0_0,
                    granted: ref __self_0_1,
                } => Permission {
                    resource: ::core::clone::Clone::clone(&(*__self_0_0)),
                    granted: ::core::clone::Clone::clone(&(*__self_0_1)),
                },
            }
        }
    }
    impl ::core::marker::StructuralPartialEq for Permission {}
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::cmp::PartialEq for Permission {
        #[inline]
        fn eq(&self, other: &Permission) -> bool {
            match *other {
                Permission {
                    resource: ref __self_1_0,
                    granted: ref __self_1_1,
                } => match *self {
                    Permission {
                        resource: ref __self_0_0,
                        granted: ref __self_0_1,
                    } => (*__self_0_0) == (*__self_1_0) && (*__self_0_1) == (*__self_1_1),
                },
            }
        }
        #[inline]
        fn ne(&self, other: &Permission) -> bool {
            match *other {
                Permission {
                    resource: ref __self_1_0,
                    granted: ref __self_1_1,
                } => match *self {
                    Permission {
                        resource: ref __self_0_0,
                        granted: ref __self_0_1,
                    } => (*__self_0_0) != (*__self_1_0) || (*__self_0_1) != (*__self_1_1),
                },
            }
        }
    }
    impl ::core::marker::StructuralEq for Permission {}
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::cmp::Eq for Permission {
        #[inline]
        #[doc(hidden)]
        fn assert_receiver_is_total_eq(&self) -> () {
            {
                let _: ::core::cmp::AssertParamIsEq<Resource>;
                let _: ::core::cmp::AssertParamIsEq<Vec<(String, String)>>;
            }
        }
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::hash::Hash for Permission {
        fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {
            match *self {
                Permission {
                    resource: ref __self_0_0,
                    granted: ref __self_0_1,
                } => {
                    ::core::hash::Hash::hash(&(*__self_0_0), state);
                    ::core::hash::Hash::hash(&(*__self_0_1), state)
                }
            }
        }
    }
}
pub mod runtime {
    #![allow(non_camel_case_types)]
    #[cfg(feature = "kvm")]
    pub mod kvm {
        use std::collections::HashMap;
        use std::error::Error;
        use strong_xml::{XmlRead, XmlWrite};
        use virt::connect::Connect;
        use virt::domain::Domain;
        use crate::runtime::Unit;
        pub struct QEMU {
            connection: Connect,
            active_domains: HashMap<String, Domain>,
        }
        impl QEMU {
            pub fn connect() -> Result<Self, Box<dyn Error>> {
                let connection = Connect::open("qemu:///session")?;
                let active_domains = HashMap::new();
                Ok(Self {
                    connection,
                    active_domains,
                })
            }
            pub fn load_by_name(&mut self, name: &str) -> Result<(), Box<dyn Error>> {
                let domain = Domain::lookup_by_name(&self.connection, name)?;
                self.active_domains.insert(name.to_string(), domain);
                Ok(())
            }
            pub fn load_all_domains(&mut self) -> Result<Vec<String>, Box<dyn Error>> {
                let domain_list = self.connection.list_domains()?;
                let mut names = Vec::new();
                for id in domain_list.into_iter() {
                    let domain = Domain::lookup_by_id(&self.connection, id)?;
                    let name = domain.get_name()?;
                    self.active_domains.insert(name.clone(), domain);
                    names.push(name);
                }
                Ok(names)
            }
            pub fn mut_domain(&mut self, key: &str) -> Option<&mut Domain> {
                self.active_domains.get_mut(key)
            }
            pub fn create_domain(&mut self) {}
        }
        impl Drop for QEMU {
            fn drop(&mut self) {
                for (_name, domain) in self.active_domains.iter_mut() {
                    domain.free().unwrap();
                }
                self.connection.close().unwrap();
            }
        }
        #[xml(tag = "boot")]
        pub struct boot {
            #[xml(attr = "dev")]
            dev: String,
        }
        impl strong_xml::XmlWrite for boot {
            fn to_writer<W: std::io::Write>(
                &self,
                mut writer: &mut strong_xml::XmlWriter<W>,
            ) -> strong_xml::XmlResult<()> {
                let boot { dev: __self_dev } = self;
                writer.write_element_start("boot")?;
                let __value = __self_dev;
                writer.write_attribute("dev", &{
                    let res = ::alloc::fmt::format(::core::fmt::Arguments::new_v1(
                        &[""],
                        &match (&__value,) {
                            (arg0,) => [::core::fmt::ArgumentV1::new(
                                arg0,
                                ::core::fmt::Display::fmt,
                            )],
                        },
                    ));
                    res
                })?;
                writer.write_element_end_empty()?;
                Ok(())
            }
        }
        impl<'__input> strong_xml::XmlRead<'__input> for boot {
            fn from_reader(
                mut reader: &mut strong_xml::XmlReader<'__input>,
            ) -> strong_xml::XmlResult<Self> {
                use strong_xml::xmlparser::{ElementEnd, Token, Tokenizer};
                use strong_xml::XmlError;
                let mut __self_dev = None;
                reader.read_till_element_start("boot")?;
                while let Some((__key, __value)) = reader.find_attribute()? {
                    match __key {
                        "dev" => {
                            __self_dev = Some(
                                <String as std::str::FromStr>::from_str(&__value)
                                    .map_err(|e| XmlError::FromStr(e.into()))?,
                            );
                        }
                        key => {}
                    }
                }
                if let Token::ElementEnd {
                    end: ElementEnd::Empty,
                    ..
                } = reader.next().unwrap()?
                {
                    let __res = boot {
                        dev: __self_dev.ok_or(XmlError::MissingField {
                            name: "boot".to_owned(),
                            field: "dev".to_owned(),
                        })?,
                    };
                    return Ok(__res);
                }
                while let Some(__tag) = reader.find_element_start(Some("boot"))? {
                    match __tag {
                        tag => {
                            reader.next();
                            reader.read_to_end(tag)?;
                        }
                    }
                }
                let __res = boot {
                    dev: __self_dev.ok_or(XmlError::MissingField {
                        name: "boot".to_owned(),
                        field: "dev".to_owned(),
                    })?,
                };
                return Ok(__res);
            }
        }
        impl ::core::marker::StructuralPartialEq for boot {}
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::cmp::PartialEq for boot {
            #[inline]
            fn eq(&self, other: &boot) -> bool {
                match *other {
                    boot {
                        dev: ref __self_1_0,
                    } => match *self {
                        boot {
                            dev: ref __self_0_0,
                        } => (*__self_0_0) == (*__self_1_0),
                    },
                }
            }
            #[inline]
            fn ne(&self, other: &boot) -> bool {
                match *other {
                    boot {
                        dev: ref __self_1_0,
                    } => match *self {
                        boot {
                            dev: ref __self_0_0,
                        } => (*__self_0_0) != (*__self_1_0),
                    },
                }
            }
        }
        impl ::core::marker::StructuralEq for boot {}
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::cmp::Eq for boot {
            #[inline]
            #[doc(hidden)]
            fn assert_receiver_is_total_eq(&self) -> () {
                {
                    let _: ::core::cmp::AssertParamIsEq<String>;
                }
            }
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::fmt::Debug for boot {
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                match *self {
                    boot {
                        dev: ref __self_0_0,
                    } => {
                        let mut debug_trait_builder = f.debug_struct("boot");
                        let _ = debug_trait_builder.field("dev", &&(*__self_0_0));
                        debug_trait_builder.finish()
                    }
                }
            }
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::clone::Clone for boot {
            #[inline]
            fn clone(&self) -> boot {
                match *self {
                    boot {
                        dev: ref __self_0_0,
                    } => boot {
                        dev: ::core::clone::Clone::clone(&(*__self_0_0)),
                    },
                }
            }
        }
        #[doc(hidden)]
        #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
        const _: () = {
            #[allow(rust_2018_idioms, clippy::useless_attribute)]
            extern crate serde as _serde;
            #[automatically_derived]
            impl _serde::Serialize for boot {
                fn serialize<__S>(
                    &self,
                    __serializer: __S,
                ) -> _serde::export::Result<__S::Ok, __S::Error>
                where
                    __S: _serde::Serializer,
                {
                    let mut __serde_state = match _serde::Serializer::serialize_struct(
                        __serializer,
                        "boot",
                        false as usize + 1,
                    ) {
                        _serde::export::Ok(__val) => __val,
                        _serde::export::Err(__err) => {
                            return _serde::export::Err(__err);
                        }
                    };
                    match _serde::ser::SerializeStruct::serialize_field(
                        &mut __serde_state,
                        "dev",
                        &self.dev,
                    ) {
                        _serde::export::Ok(__val) => __val,
                        _serde::export::Err(__err) => {
                            return _serde::export::Err(__err);
                        }
                    };
                    _serde::ser::SerializeStruct::end(__serde_state)
                }
            }
        };
        #[doc(hidden)]
        #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
        const _: () = {
            #[allow(rust_2018_idioms, clippy::useless_attribute)]
            extern crate serde as _serde;
            #[automatically_derived]
            impl<'de> _serde::Deserialize<'de> for boot {
                fn deserialize<__D>(__deserializer: __D) -> _serde::export::Result<Self, __D::Error>
                where
                    __D: _serde::Deserializer<'de>,
                {
                    #[allow(non_camel_case_types)]
                    enum __Field {
                        __field0,
                        __ignore,
                    }
                    struct __FieldVisitor;
                    impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                        type Value = __Field;
                        fn expecting(
                            &self,
                            __formatter: &mut _serde::export::Formatter,
                        ) -> _serde::export::fmt::Result {
                            _serde::export::Formatter::write_str(__formatter, "field identifier")
                        }
                        fn visit_u64<__E>(
                            self,
                            __value: u64,
                        ) -> _serde::export::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                0u64 => _serde::export::Ok(__Field::__field0),
                                _ => _serde::export::Err(_serde::de::Error::invalid_value(
                                    _serde::de::Unexpected::Unsigned(__value),
                                    &"field index 0 <= i < 1",
                                )),
                            }
                        }
                        fn visit_str<__E>(
                            self,
                            __value: &str,
                        ) -> _serde::export::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                "dev" => _serde::export::Ok(__Field::__field0),
                                _ => _serde::export::Ok(__Field::__ignore),
                            }
                        }
                        fn visit_bytes<__E>(
                            self,
                            __value: &[u8],
                        ) -> _serde::export::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                b"dev" => _serde::export::Ok(__Field::__field0),
                                _ => _serde::export::Ok(__Field::__ignore),
                            }
                        }
                    }
                    impl<'de> _serde::Deserialize<'de> for __Field {
                        #[inline]
                        fn deserialize<__D>(
                            __deserializer: __D,
                        ) -> _serde::export::Result<Self, __D::Error>
                        where
                            __D: _serde::Deserializer<'de>,
                        {
                            _serde::Deserializer::deserialize_identifier(
                                __deserializer,
                                __FieldVisitor,
                            )
                        }
                    }
                    struct __Visitor<'de> {
                        marker: _serde::export::PhantomData<boot>,
                        lifetime: _serde::export::PhantomData<&'de ()>,
                    }
                    impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                        type Value = boot;
                        fn expecting(
                            &self,
                            __formatter: &mut _serde::export::Formatter,
                        ) -> _serde::export::fmt::Result {
                            _serde::export::Formatter::write_str(__formatter, "struct boot")
                        }
                        #[inline]
                        fn visit_seq<__A>(
                            self,
                            mut __seq: __A,
                        ) -> _serde::export::Result<Self::Value, __A::Error>
                        where
                            __A: _serde::de::SeqAccess<'de>,
                        {
                            let __field0 = match match _serde::de::SeqAccess::next_element::<String>(
                                &mut __seq,
                            ) {
                                _serde::export::Ok(__val) => __val,
                                _serde::export::Err(__err) => {
                                    return _serde::export::Err(__err);
                                }
                            } {
                                _serde::export::Some(__value) => __value,
                                _serde::export::None => {
                                    return _serde::export::Err(_serde::de::Error::invalid_length(
                                        0usize,
                                        &"struct boot with 1 element",
                                    ));
                                }
                            };
                            _serde::export::Ok(boot { dev: __field0 })
                        }
                        #[inline]
                        fn visit_map<__A>(
                            self,
                            mut __map: __A,
                        ) -> _serde::export::Result<Self::Value, __A::Error>
                        where
                            __A: _serde::de::MapAccess<'de>,
                        {
                            let mut __field0: _serde::export::Option<String> = _serde::export::None;
                            while let _serde::export::Some(__key) =
                                match _serde::de::MapAccess::next_key::<__Field>(&mut __map) {
                                    _serde::export::Ok(__val) => __val,
                                    _serde::export::Err(__err) => {
                                        return _serde::export::Err(__err);
                                    }
                                }
                            {
                                match __key {
                                    __Field::__field0 => {
                                        if _serde::export::Option::is_some(&__field0) {
                                            return _serde::export::Err(
                                                <__A::Error as _serde::de::Error>::duplicate_field(
                                                    "dev",
                                                ),
                                            );
                                        }
                                        __field0 = _serde::export::Some(
                                            match _serde::de::MapAccess::next_value::<String>(
                                                &mut __map,
                                            ) {
                                                _serde::export::Ok(__val) => __val,
                                                _serde::export::Err(__err) => {
                                                    return _serde::export::Err(__err);
                                                }
                                            },
                                        );
                                    }
                                    _ => {
                                        let _ = match _serde::de::MapAccess::next_value::<
                                            _serde::de::IgnoredAny,
                                        >(
                                            &mut __map
                                        ) {
                                            _serde::export::Ok(__val) => __val,
                                            _serde::export::Err(__err) => {
                                                return _serde::export::Err(__err);
                                            }
                                        };
                                    }
                                }
                            }
                            let __field0 = match __field0 {
                                _serde::export::Some(__field0) => __field0,
                                _serde::export::None => {
                                    match _serde::private::de::missing_field("dev") {
                                        _serde::export::Ok(__val) => __val,
                                        _serde::export::Err(__err) => {
                                            return _serde::export::Err(__err);
                                        }
                                    }
                                }
                            };
                            _serde::export::Ok(boot { dev: __field0 })
                        }
                    }
                    const FIELDS: &'static [&'static str] = &["dev"];
                    _serde::Deserializer::deserialize_struct(
                        __deserializer,
                        "boot",
                        FIELDS,
                        __Visitor {
                            marker: _serde::export::PhantomData::<boot>,
                            lifetime: _serde::export::PhantomData,
                        },
                    )
                }
            }
        };
        #[xml(tag = "title")]
        pub struct title {
            #[xml(text)]
            title: String,
        }
        impl strong_xml::XmlWrite for title {
            fn to_writer<W: std::io::Write>(
                &self,
                mut writer: &mut strong_xml::XmlWriter<W>,
            ) -> strong_xml::XmlResult<()> {
                let title {
                    title: __self_title,
                } = self;
                writer.write_element_start("title")?;
                writer.write_element_end_open()?;
                let __value = &__self_title;
                writer.write_text(&{
                    let res = ::alloc::fmt::format(::core::fmt::Arguments::new_v1(
                        &[""],
                        &match (&__value,) {
                            (arg0,) => [::core::fmt::ArgumentV1::new(
                                arg0,
                                ::core::fmt::Display::fmt,
                            )],
                        },
                    ));
                    res
                })?;
                writer.write_element_end_close("title")?;
                Ok(())
            }
        }
        impl<'__input> strong_xml::XmlRead<'__input> for title {
            fn from_reader(
                mut reader: &mut strong_xml::XmlReader<'__input>,
            ) -> strong_xml::XmlResult<Self> {
                use strong_xml::xmlparser::{ElementEnd, Token, Tokenizer};
                use strong_xml::XmlError;
                let __self_title;
                reader.read_till_element_start("title")?;
                while let Some((__key, __value)) = reader.find_attribute()? {
                    match __key {
                        key => {}
                    }
                }
                let __value = reader.read_text("title")?;
                __self_title = Some(
                    <String as std::str::FromStr>::from_str(&__value)
                        .map_err(|e| XmlError::FromStr(e.into()))?,
                );
                let __res = title {
                    title: __self_title.ok_or(XmlError::MissingField {
                        name: "title".to_owned(),
                        field: "title".to_owned(),
                    })?,
                };
                return Ok(__res);
            }
        }
        impl ::core::marker::StructuralPartialEq for title {}
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::cmp::PartialEq for title {
            #[inline]
            fn eq(&self, other: &title) -> bool {
                match *other {
                    title {
                        title: ref __self_1_0,
                    } => match *self {
                        title {
                            title: ref __self_0_0,
                        } => (*__self_0_0) == (*__self_1_0),
                    },
                }
            }
            #[inline]
            fn ne(&self, other: &title) -> bool {
                match *other {
                    title {
                        title: ref __self_1_0,
                    } => match *self {
                        title {
                            title: ref __self_0_0,
                        } => (*__self_0_0) != (*__self_1_0),
                    },
                }
            }
        }
        impl ::core::marker::StructuralEq for title {}
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::cmp::Eq for title {
            #[inline]
            #[doc(hidden)]
            fn assert_receiver_is_total_eq(&self) -> () {
                {
                    let _: ::core::cmp::AssertParamIsEq<String>;
                }
            }
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::fmt::Debug for title {
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                match *self {
                    title {
                        title: ref __self_0_0,
                    } => {
                        let mut debug_trait_builder = f.debug_struct("title");
                        let _ = debug_trait_builder.field("title", &&(*__self_0_0));
                        debug_trait_builder.finish()
                    }
                }
            }
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::clone::Clone for title {
            #[inline]
            fn clone(&self) -> title {
                match *self {
                    title {
                        title: ref __self_0_0,
                    } => title {
                        title: ::core::clone::Clone::clone(&(*__self_0_0)),
                    },
                }
            }
        }
        #[doc(hidden)]
        #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
        const _: () = {
            #[allow(rust_2018_idioms, clippy::useless_attribute)]
            extern crate serde as _serde;
            #[automatically_derived]
            impl _serde::Serialize for title {
                fn serialize<__S>(
                    &self,
                    __serializer: __S,
                ) -> _serde::export::Result<__S::Ok, __S::Error>
                where
                    __S: _serde::Serializer,
                {
                    let mut __serde_state = match _serde::Serializer::serialize_struct(
                        __serializer,
                        "title",
                        false as usize + 1,
                    ) {
                        _serde::export::Ok(__val) => __val,
                        _serde::export::Err(__err) => {
                            return _serde::export::Err(__err);
                        }
                    };
                    match _serde::ser::SerializeStruct::serialize_field(
                        &mut __serde_state,
                        "title",
                        &self.title,
                    ) {
                        _serde::export::Ok(__val) => __val,
                        _serde::export::Err(__err) => {
                            return _serde::export::Err(__err);
                        }
                    };
                    _serde::ser::SerializeStruct::end(__serde_state)
                }
            }
        };
        #[doc(hidden)]
        #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
        const _: () = {
            #[allow(rust_2018_idioms, clippy::useless_attribute)]
            extern crate serde as _serde;
            #[automatically_derived]
            impl<'de> _serde::Deserialize<'de> for title {
                fn deserialize<__D>(__deserializer: __D) -> _serde::export::Result<Self, __D::Error>
                where
                    __D: _serde::Deserializer<'de>,
                {
                    #[allow(non_camel_case_types)]
                    enum __Field {
                        __field0,
                        __ignore,
                    }
                    struct __FieldVisitor;
                    impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                        type Value = __Field;
                        fn expecting(
                            &self,
                            __formatter: &mut _serde::export::Formatter,
                        ) -> _serde::export::fmt::Result {
                            _serde::export::Formatter::write_str(__formatter, "field identifier")
                        }
                        fn visit_u64<__E>(
                            self,
                            __value: u64,
                        ) -> _serde::export::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                0u64 => _serde::export::Ok(__Field::__field0),
                                _ => _serde::export::Err(_serde::de::Error::invalid_value(
                                    _serde::de::Unexpected::Unsigned(__value),
                                    &"field index 0 <= i < 1",
                                )),
                            }
                        }
                        fn visit_str<__E>(
                            self,
                            __value: &str,
                        ) -> _serde::export::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                "title" => _serde::export::Ok(__Field::__field0),
                                _ => _serde::export::Ok(__Field::__ignore),
                            }
                        }
                        fn visit_bytes<__E>(
                            self,
                            __value: &[u8],
                        ) -> _serde::export::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                b"title" => _serde::export::Ok(__Field::__field0),
                                _ => _serde::export::Ok(__Field::__ignore),
                            }
                        }
                    }
                    impl<'de> _serde::Deserialize<'de> for __Field {
                        #[inline]
                        fn deserialize<__D>(
                            __deserializer: __D,
                        ) -> _serde::export::Result<Self, __D::Error>
                        where
                            __D: _serde::Deserializer<'de>,
                        {
                            _serde::Deserializer::deserialize_identifier(
                                __deserializer,
                                __FieldVisitor,
                            )
                        }
                    }
                    struct __Visitor<'de> {
                        marker: _serde::export::PhantomData<title>,
                        lifetime: _serde::export::PhantomData<&'de ()>,
                    }
                    impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                        type Value = title;
                        fn expecting(
                            &self,
                            __formatter: &mut _serde::export::Formatter,
                        ) -> _serde::export::fmt::Result {
                            _serde::export::Formatter::write_str(__formatter, "struct title")
                        }
                        #[inline]
                        fn visit_seq<__A>(
                            self,
                            mut __seq: __A,
                        ) -> _serde::export::Result<Self::Value, __A::Error>
                        where
                            __A: _serde::de::SeqAccess<'de>,
                        {
                            let __field0 = match match _serde::de::SeqAccess::next_element::<String>(
                                &mut __seq,
                            ) {
                                _serde::export::Ok(__val) => __val,
                                _serde::export::Err(__err) => {
                                    return _serde::export::Err(__err);
                                }
                            } {
                                _serde::export::Some(__value) => __value,
                                _serde::export::None => {
                                    return _serde::export::Err(_serde::de::Error::invalid_length(
                                        0usize,
                                        &"struct title with 1 element",
                                    ));
                                }
                            };
                            _serde::export::Ok(title { title: __field0 })
                        }
                        #[inline]
                        fn visit_map<__A>(
                            self,
                            mut __map: __A,
                        ) -> _serde::export::Result<Self::Value, __A::Error>
                        where
                            __A: _serde::de::MapAccess<'de>,
                        {
                            let mut __field0: _serde::export::Option<String> = _serde::export::None;
                            while let _serde::export::Some(__key) =
                                match _serde::de::MapAccess::next_key::<__Field>(&mut __map) {
                                    _serde::export::Ok(__val) => __val,
                                    _serde::export::Err(__err) => {
                                        return _serde::export::Err(__err);
                                    }
                                }
                            {
                                match __key {
                                    __Field::__field0 => {
                                        if _serde::export::Option::is_some(&__field0) {
                                            return _serde::export::Err(
                                                <__A::Error as _serde::de::Error>::duplicate_field(
                                                    "title",
                                                ),
                                            );
                                        }
                                        __field0 = _serde::export::Some(
                                            match _serde::de::MapAccess::next_value::<String>(
                                                &mut __map,
                                            ) {
                                                _serde::export::Ok(__val) => __val,
                                                _serde::export::Err(__err) => {
                                                    return _serde::export::Err(__err);
                                                }
                                            },
                                        );
                                    }
                                    _ => {
                                        let _ = match _serde::de::MapAccess::next_value::<
                                            _serde::de::IgnoredAny,
                                        >(
                                            &mut __map
                                        ) {
                                            _serde::export::Ok(__val) => __val,
                                            _serde::export::Err(__err) => {
                                                return _serde::export::Err(__err);
                                            }
                                        };
                                    }
                                }
                            }
                            let __field0 = match __field0 {
                                _serde::export::Some(__field0) => __field0,
                                _serde::export::None => {
                                    match _serde::private::de::missing_field("title") {
                                        _serde::export::Ok(__val) => __val,
                                        _serde::export::Err(__err) => {
                                            return _serde::export::Err(__err);
                                        }
                                    }
                                }
                            };
                            _serde::export::Ok(title { title: __field0 })
                        }
                    }
                    const FIELDS: &'static [&'static str] = &["title"];
                    _serde::Deserializer::deserialize_struct(
                        __deserializer,
                        "title",
                        FIELDS,
                        __Visitor {
                            marker: _serde::export::PhantomData::<title>,
                            lifetime: _serde::export::PhantomData,
                        },
                    )
                }
            }
        };
        impl title {
            pub fn new(name: String) -> Self {
                Self { title: name }
            }
        }
        #[xml(tag = "description")]
        pub struct description {
            #[xml(text)]
            description: String,
        }
        impl strong_xml::XmlWrite for description {
            fn to_writer<W: std::io::Write>(
                &self,
                mut writer: &mut strong_xml::XmlWriter<W>,
            ) -> strong_xml::XmlResult<()> {
                let description {
                    description: __self_description,
                } = self;
                writer.write_element_start("description")?;
                writer.write_element_end_open()?;
                let __value = &__self_description;
                writer.write_text(&{
                    let res = ::alloc::fmt::format(::core::fmt::Arguments::new_v1(
                        &[""],
                        &match (&__value,) {
                            (arg0,) => [::core::fmt::ArgumentV1::new(
                                arg0,
                                ::core::fmt::Display::fmt,
                            )],
                        },
                    ));
                    res
                })?;
                writer.write_element_end_close("description")?;
                Ok(())
            }
        }
        impl<'__input> strong_xml::XmlRead<'__input> for description {
            fn from_reader(
                mut reader: &mut strong_xml::XmlReader<'__input>,
            ) -> strong_xml::XmlResult<Self> {
                use strong_xml::xmlparser::{ElementEnd, Token, Tokenizer};
                use strong_xml::XmlError;
                let __self_description;
                reader.read_till_element_start("description")?;
                while let Some((__key, __value)) = reader.find_attribute()? {
                    match __key {
                        key => {}
                    }
                }
                let __value = reader.read_text("description")?;
                __self_description = Some(
                    <String as std::str::FromStr>::from_str(&__value)
                        .map_err(|e| XmlError::FromStr(e.into()))?,
                );
                let __res = description {
                    description: __self_description.ok_or(XmlError::MissingField {
                        name: "description".to_owned(),
                        field: "description".to_owned(),
                    })?,
                };
                return Ok(__res);
            }
        }
        impl ::core::marker::StructuralPartialEq for description {}
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::cmp::PartialEq for description {
            #[inline]
            fn eq(&self, other: &description) -> bool {
                match *other {
                    description {
                        description: ref __self_1_0,
                    } => match *self {
                        description {
                            description: ref __self_0_0,
                        } => (*__self_0_0) == (*__self_1_0),
                    },
                }
            }
            #[inline]
            fn ne(&self, other: &description) -> bool {
                match *other {
                    description {
                        description: ref __self_1_0,
                    } => match *self {
                        description {
                            description: ref __self_0_0,
                        } => (*__self_0_0) != (*__self_1_0),
                    },
                }
            }
        }
        impl ::core::marker::StructuralEq for description {}
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::cmp::Eq for description {
            #[inline]
            #[doc(hidden)]
            fn assert_receiver_is_total_eq(&self) -> () {
                {
                    let _: ::core::cmp::AssertParamIsEq<String>;
                }
            }
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::fmt::Debug for description {
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                match *self {
                    description {
                        description: ref __self_0_0,
                    } => {
                        let mut debug_trait_builder = f.debug_struct("description");
                        let _ = debug_trait_builder.field("description", &&(*__self_0_0));
                        debug_trait_builder.finish()
                    }
                }
            }
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::clone::Clone for description {
            #[inline]
            fn clone(&self) -> description {
                match *self {
                    description {
                        description: ref __self_0_0,
                    } => description {
                        description: ::core::clone::Clone::clone(&(*__self_0_0)),
                    },
                }
            }
        }
        #[doc(hidden)]
        #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
        const _: () = {
            #[allow(rust_2018_idioms, clippy::useless_attribute)]
            extern crate serde as _serde;
            #[automatically_derived]
            impl _serde::Serialize for description {
                fn serialize<__S>(
                    &self,
                    __serializer: __S,
                ) -> _serde::export::Result<__S::Ok, __S::Error>
                where
                    __S: _serde::Serializer,
                {
                    let mut __serde_state = match _serde::Serializer::serialize_struct(
                        __serializer,
                        "description",
                        false as usize + 1,
                    ) {
                        _serde::export::Ok(__val) => __val,
                        _serde::export::Err(__err) => {
                            return _serde::export::Err(__err);
                        }
                    };
                    match _serde::ser::SerializeStruct::serialize_field(
                        &mut __serde_state,
                        "description",
                        &self.description,
                    ) {
                        _serde::export::Ok(__val) => __val,
                        _serde::export::Err(__err) => {
                            return _serde::export::Err(__err);
                        }
                    };
                    _serde::ser::SerializeStruct::end(__serde_state)
                }
            }
        };
        #[doc(hidden)]
        #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
        const _: () = {
            #[allow(rust_2018_idioms, clippy::useless_attribute)]
            extern crate serde as _serde;
            #[automatically_derived]
            impl<'de> _serde::Deserialize<'de> for description {
                fn deserialize<__D>(__deserializer: __D) -> _serde::export::Result<Self, __D::Error>
                where
                    __D: _serde::Deserializer<'de>,
                {
                    #[allow(non_camel_case_types)]
                    enum __Field {
                        __field0,
                        __ignore,
                    }
                    struct __FieldVisitor;
                    impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                        type Value = __Field;
                        fn expecting(
                            &self,
                            __formatter: &mut _serde::export::Formatter,
                        ) -> _serde::export::fmt::Result {
                            _serde::export::Formatter::write_str(__formatter, "field identifier")
                        }
                        fn visit_u64<__E>(
                            self,
                            __value: u64,
                        ) -> _serde::export::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                0u64 => _serde::export::Ok(__Field::__field0),
                                _ => _serde::export::Err(_serde::de::Error::invalid_value(
                                    _serde::de::Unexpected::Unsigned(__value),
                                    &"field index 0 <= i < 1",
                                )),
                            }
                        }
                        fn visit_str<__E>(
                            self,
                            __value: &str,
                        ) -> _serde::export::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                "description" => _serde::export::Ok(__Field::__field0),
                                _ => _serde::export::Ok(__Field::__ignore),
                            }
                        }
                        fn visit_bytes<__E>(
                            self,
                            __value: &[u8],
                        ) -> _serde::export::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                b"description" => _serde::export::Ok(__Field::__field0),
                                _ => _serde::export::Ok(__Field::__ignore),
                            }
                        }
                    }
                    impl<'de> _serde::Deserialize<'de> for __Field {
                        #[inline]
                        fn deserialize<__D>(
                            __deserializer: __D,
                        ) -> _serde::export::Result<Self, __D::Error>
                        where
                            __D: _serde::Deserializer<'de>,
                        {
                            _serde::Deserializer::deserialize_identifier(
                                __deserializer,
                                __FieldVisitor,
                            )
                        }
                    }
                    struct __Visitor<'de> {
                        marker: _serde::export::PhantomData<description>,
                        lifetime: _serde::export::PhantomData<&'de ()>,
                    }
                    impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                        type Value = description;
                        fn expecting(
                            &self,
                            __formatter: &mut _serde::export::Formatter,
                        ) -> _serde::export::fmt::Result {
                            _serde::export::Formatter::write_str(__formatter, "struct description")
                        }
                        #[inline]
                        fn visit_seq<__A>(
                            self,
                            mut __seq: __A,
                        ) -> _serde::export::Result<Self::Value, __A::Error>
                        where
                            __A: _serde::de::SeqAccess<'de>,
                        {
                            let __field0 = match match _serde::de::SeqAccess::next_element::<String>(
                                &mut __seq,
                            ) {
                                _serde::export::Ok(__val) => __val,
                                _serde::export::Err(__err) => {
                                    return _serde::export::Err(__err);
                                }
                            } {
                                _serde::export::Some(__value) => __value,
                                _serde::export::None => {
                                    return _serde::export::Err(_serde::de::Error::invalid_length(
                                        0usize,
                                        &"struct description with 1 element",
                                    ));
                                }
                            };
                            _serde::export::Ok(description {
                                description: __field0,
                            })
                        }
                        #[inline]
                        fn visit_map<__A>(
                            self,
                            mut __map: __A,
                        ) -> _serde::export::Result<Self::Value, __A::Error>
                        where
                            __A: _serde::de::MapAccess<'de>,
                        {
                            let mut __field0: _serde::export::Option<String> = _serde::export::None;
                            while let _serde::export::Some(__key) =
                                match _serde::de::MapAccess::next_key::<__Field>(&mut __map) {
                                    _serde::export::Ok(__val) => __val,
                                    _serde::export::Err(__err) => {
                                        return _serde::export::Err(__err);
                                    }
                                }
                            {
                                match __key {
                                    __Field::__field0 => {
                                        if _serde::export::Option::is_some(&__field0) {
                                            return _serde::export::Err(
                                                <__A::Error as _serde::de::Error>::duplicate_field(
                                                    "description",
                                                ),
                                            );
                                        }
                                        __field0 = _serde::export::Some(
                                            match _serde::de::MapAccess::next_value::<String>(
                                                &mut __map,
                                            ) {
                                                _serde::export::Ok(__val) => __val,
                                                _serde::export::Err(__err) => {
                                                    return _serde::export::Err(__err);
                                                }
                                            },
                                        );
                                    }
                                    _ => {
                                        let _ = match _serde::de::MapAccess::next_value::<
                                            _serde::de::IgnoredAny,
                                        >(
                                            &mut __map
                                        ) {
                                            _serde::export::Ok(__val) => __val,
                                            _serde::export::Err(__err) => {
                                                return _serde::export::Err(__err);
                                            }
                                        };
                                    }
                                }
                            }
                            let __field0 = match __field0 {
                                _serde::export::Some(__field0) => __field0,
                                _serde::export::None => {
                                    match _serde::private::de::missing_field("description") {
                                        _serde::export::Ok(__val) => __val,
                                        _serde::export::Err(__err) => {
                                            return _serde::export::Err(__err);
                                        }
                                    }
                                }
                            };
                            _serde::export::Ok(description {
                                description: __field0,
                            })
                        }
                    }
                    const FIELDS: &'static [&'static str] = &["description"];
                    _serde::Deserializer::deserialize_struct(
                        __deserializer,
                        "description",
                        FIELDS,
                        __Visitor {
                            marker: _serde::export::PhantomData::<description>,
                            lifetime: _serde::export::PhantomData,
                        },
                    )
                }
            }
        };
        impl description {
            pub fn new(name: String) -> Self {
                Self { description: name }
            }
        }
        #[xml(tag = "genid")]
        pub struct genid {
            #[xml(text)]
            genid: String,
        }
        impl strong_xml::XmlWrite for genid {
            fn to_writer<W: std::io::Write>(
                &self,
                mut writer: &mut strong_xml::XmlWriter<W>,
            ) -> strong_xml::XmlResult<()> {
                let genid {
                    genid: __self_genid,
                } = self;
                writer.write_element_start("genid")?;
                writer.write_element_end_open()?;
                let __value = &__self_genid;
                writer.write_text(&{
                    let res = ::alloc::fmt::format(::core::fmt::Arguments::new_v1(
                        &[""],
                        &match (&__value,) {
                            (arg0,) => [::core::fmt::ArgumentV1::new(
                                arg0,
                                ::core::fmt::Display::fmt,
                            )],
                        },
                    ));
                    res
                })?;
                writer.write_element_end_close("genid")?;
                Ok(())
            }
        }
        impl<'__input> strong_xml::XmlRead<'__input> for genid {
            fn from_reader(
                mut reader: &mut strong_xml::XmlReader<'__input>,
            ) -> strong_xml::XmlResult<Self> {
                use strong_xml::xmlparser::{ElementEnd, Token, Tokenizer};
                use strong_xml::XmlError;
                let __self_genid;
                reader.read_till_element_start("genid")?;
                while let Some((__key, __value)) = reader.find_attribute()? {
                    match __key {
                        key => {}
                    }
                }
                let __value = reader.read_text("genid")?;
                __self_genid = Some(
                    <String as std::str::FromStr>::from_str(&__value)
                        .map_err(|e| XmlError::FromStr(e.into()))?,
                );
                let __res = genid {
                    genid: __self_genid.ok_or(XmlError::MissingField {
                        name: "genid".to_owned(),
                        field: "genid".to_owned(),
                    })?,
                };
                return Ok(__res);
            }
        }
        impl ::core::marker::StructuralPartialEq for genid {}
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::cmp::PartialEq for genid {
            #[inline]
            fn eq(&self, other: &genid) -> bool {
                match *other {
                    genid {
                        genid: ref __self_1_0,
                    } => match *self {
                        genid {
                            genid: ref __self_0_0,
                        } => (*__self_0_0) == (*__self_1_0),
                    },
                }
            }
            #[inline]
            fn ne(&self, other: &genid) -> bool {
                match *other {
                    genid {
                        genid: ref __self_1_0,
                    } => match *self {
                        genid {
                            genid: ref __self_0_0,
                        } => (*__self_0_0) != (*__self_1_0),
                    },
                }
            }
        }
        impl ::core::marker::StructuralEq for genid {}
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::cmp::Eq for genid {
            #[inline]
            #[doc(hidden)]
            fn assert_receiver_is_total_eq(&self) -> () {
                {
                    let _: ::core::cmp::AssertParamIsEq<String>;
                }
            }
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::fmt::Debug for genid {
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                match *self {
                    genid {
                        genid: ref __self_0_0,
                    } => {
                        let mut debug_trait_builder = f.debug_struct("genid");
                        let _ = debug_trait_builder.field("genid", &&(*__self_0_0));
                        debug_trait_builder.finish()
                    }
                }
            }
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::clone::Clone for genid {
            #[inline]
            fn clone(&self) -> genid {
                match *self {
                    genid {
                        genid: ref __self_0_0,
                    } => genid {
                        genid: ::core::clone::Clone::clone(&(*__self_0_0)),
                    },
                }
            }
        }
        #[doc(hidden)]
        #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
        const _: () = {
            #[allow(rust_2018_idioms, clippy::useless_attribute)]
            extern crate serde as _serde;
            #[automatically_derived]
            impl _serde::Serialize for genid {
                fn serialize<__S>(
                    &self,
                    __serializer: __S,
                ) -> _serde::export::Result<__S::Ok, __S::Error>
                where
                    __S: _serde::Serializer,
                {
                    let mut __serde_state = match _serde::Serializer::serialize_struct(
                        __serializer,
                        "genid",
                        false as usize + 1,
                    ) {
                        _serde::export::Ok(__val) => __val,
                        _serde::export::Err(__err) => {
                            return _serde::export::Err(__err);
                        }
                    };
                    match _serde::ser::SerializeStruct::serialize_field(
                        &mut __serde_state,
                        "genid",
                        &self.genid,
                    ) {
                        _serde::export::Ok(__val) => __val,
                        _serde::export::Err(__err) => {
                            return _serde::export::Err(__err);
                        }
                    };
                    _serde::ser::SerializeStruct::end(__serde_state)
                }
            }
        };
        #[doc(hidden)]
        #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
        const _: () = {
            #[allow(rust_2018_idioms, clippy::useless_attribute)]
            extern crate serde as _serde;
            #[automatically_derived]
            impl<'de> _serde::Deserialize<'de> for genid {
                fn deserialize<__D>(__deserializer: __D) -> _serde::export::Result<Self, __D::Error>
                where
                    __D: _serde::Deserializer<'de>,
                {
                    #[allow(non_camel_case_types)]
                    enum __Field {
                        __field0,
                        __ignore,
                    }
                    struct __FieldVisitor;
                    impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                        type Value = __Field;
                        fn expecting(
                            &self,
                            __formatter: &mut _serde::export::Formatter,
                        ) -> _serde::export::fmt::Result {
                            _serde::export::Formatter::write_str(__formatter, "field identifier")
                        }
                        fn visit_u64<__E>(
                            self,
                            __value: u64,
                        ) -> _serde::export::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                0u64 => _serde::export::Ok(__Field::__field0),
                                _ => _serde::export::Err(_serde::de::Error::invalid_value(
                                    _serde::de::Unexpected::Unsigned(__value),
                                    &"field index 0 <= i < 1",
                                )),
                            }
                        }
                        fn visit_str<__E>(
                            self,
                            __value: &str,
                        ) -> _serde::export::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                "genid" => _serde::export::Ok(__Field::__field0),
                                _ => _serde::export::Ok(__Field::__ignore),
                            }
                        }
                        fn visit_bytes<__E>(
                            self,
                            __value: &[u8],
                        ) -> _serde::export::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                b"genid" => _serde::export::Ok(__Field::__field0),
                                _ => _serde::export::Ok(__Field::__ignore),
                            }
                        }
                    }
                    impl<'de> _serde::Deserialize<'de> for __Field {
                        #[inline]
                        fn deserialize<__D>(
                            __deserializer: __D,
                        ) -> _serde::export::Result<Self, __D::Error>
                        where
                            __D: _serde::Deserializer<'de>,
                        {
                            _serde::Deserializer::deserialize_identifier(
                                __deserializer,
                                __FieldVisitor,
                            )
                        }
                    }
                    struct __Visitor<'de> {
                        marker: _serde::export::PhantomData<genid>,
                        lifetime: _serde::export::PhantomData<&'de ()>,
                    }
                    impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                        type Value = genid;
                        fn expecting(
                            &self,
                            __formatter: &mut _serde::export::Formatter,
                        ) -> _serde::export::fmt::Result {
                            _serde::export::Formatter::write_str(__formatter, "struct genid")
                        }
                        #[inline]
                        fn visit_seq<__A>(
                            self,
                            mut __seq: __A,
                        ) -> _serde::export::Result<Self::Value, __A::Error>
                        where
                            __A: _serde::de::SeqAccess<'de>,
                        {
                            let __field0 = match match _serde::de::SeqAccess::next_element::<String>(
                                &mut __seq,
                            ) {
                                _serde::export::Ok(__val) => __val,
                                _serde::export::Err(__err) => {
                                    return _serde::export::Err(__err);
                                }
                            } {
                                _serde::export::Some(__value) => __value,
                                _serde::export::None => {
                                    return _serde::export::Err(_serde::de::Error::invalid_length(
                                        0usize,
                                        &"struct genid with 1 element",
                                    ));
                                }
                            };
                            _serde::export::Ok(genid { genid: __field0 })
                        }
                        #[inline]
                        fn visit_map<__A>(
                            self,
                            mut __map: __A,
                        ) -> _serde::export::Result<Self::Value, __A::Error>
                        where
                            __A: _serde::de::MapAccess<'de>,
                        {
                            let mut __field0: _serde::export::Option<String> = _serde::export::None;
                            while let _serde::export::Some(__key) =
                                match _serde::de::MapAccess::next_key::<__Field>(&mut __map) {
                                    _serde::export::Ok(__val) => __val,
                                    _serde::export::Err(__err) => {
                                        return _serde::export::Err(__err);
                                    }
                                }
                            {
                                match __key {
                                    __Field::__field0 => {
                                        if _serde::export::Option::is_some(&__field0) {
                                            return _serde::export::Err(
                                                <__A::Error as _serde::de::Error>::duplicate_field(
                                                    "genid",
                                                ),
                                            );
                                        }
                                        __field0 = _serde::export::Some(
                                            match _serde::de::MapAccess::next_value::<String>(
                                                &mut __map,
                                            ) {
                                                _serde::export::Ok(__val) => __val,
                                                _serde::export::Err(__err) => {
                                                    return _serde::export::Err(__err);
                                                }
                                            },
                                        );
                                    }
                                    _ => {
                                        let _ = match _serde::de::MapAccess::next_value::<
                                            _serde::de::IgnoredAny,
                                        >(
                                            &mut __map
                                        ) {
                                            _serde::export::Ok(__val) => __val,
                                            _serde::export::Err(__err) => {
                                                return _serde::export::Err(__err);
                                            }
                                        };
                                    }
                                }
                            }
                            let __field0 = match __field0 {
                                _serde::export::Some(__field0) => __field0,
                                _serde::export::None => {
                                    match _serde::private::de::missing_field("genid") {
                                        _serde::export::Ok(__val) => __val,
                                        _serde::export::Err(__err) => {
                                            return _serde::export::Err(__err);
                                        }
                                    }
                                }
                            };
                            _serde::export::Ok(genid { genid: __field0 })
                        }
                    }
                    const FIELDS: &'static [&'static str] = &["genid"];
                    _serde::Deserializer::deserialize_struct(
                        __deserializer,
                        "genid",
                        FIELDS,
                        __Visitor {
                            marker: _serde::export::PhantomData::<genid>,
                            lifetime: _serde::export::PhantomData,
                        },
                    )
                }
            }
        };
        impl genid {
            pub fn new(name: String) -> Self {
                Self { genid: name }
            }
        }
        #[xml(tag = "uuid")]
        pub struct uuid {
            #[xml(text)]
            uuid: String,
        }
        impl strong_xml::XmlWrite for uuid {
            fn to_writer<W: std::io::Write>(
                &self,
                mut writer: &mut strong_xml::XmlWriter<W>,
            ) -> strong_xml::XmlResult<()> {
                let uuid { uuid: __self_uuid } = self;
                writer.write_element_start("uuid")?;
                writer.write_element_end_open()?;
                let __value = &__self_uuid;
                writer.write_text(&{
                    let res = ::alloc::fmt::format(::core::fmt::Arguments::new_v1(
                        &[""],
                        &match (&__value,) {
                            (arg0,) => [::core::fmt::ArgumentV1::new(
                                arg0,
                                ::core::fmt::Display::fmt,
                            )],
                        },
                    ));
                    res
                })?;
                writer.write_element_end_close("uuid")?;
                Ok(())
            }
        }
        impl<'__input> strong_xml::XmlRead<'__input> for uuid {
            fn from_reader(
                mut reader: &mut strong_xml::XmlReader<'__input>,
            ) -> strong_xml::XmlResult<Self> {
                use strong_xml::xmlparser::{ElementEnd, Token, Tokenizer};
                use strong_xml::XmlError;
                let __self_uuid;
                reader.read_till_element_start("uuid")?;
                while let Some((__key, __value)) = reader.find_attribute()? {
                    match __key {
                        key => {}
                    }
                }
                let __value = reader.read_text("uuid")?;
                __self_uuid = Some(
                    <String as std::str::FromStr>::from_str(&__value)
                        .map_err(|e| XmlError::FromStr(e.into()))?,
                );
                let __res = uuid {
                    uuid: __self_uuid.ok_or(XmlError::MissingField {
                        name: "uuid".to_owned(),
                        field: "uuid".to_owned(),
                    })?,
                };
                return Ok(__res);
            }
        }
        impl ::core::marker::StructuralPartialEq for uuid {}
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::cmp::PartialEq for uuid {
            #[inline]
            fn eq(&self, other: &uuid) -> bool {
                match *other {
                    uuid {
                        uuid: ref __self_1_0,
                    } => match *self {
                        uuid {
                            uuid: ref __self_0_0,
                        } => (*__self_0_0) == (*__self_1_0),
                    },
                }
            }
            #[inline]
            fn ne(&self, other: &uuid) -> bool {
                match *other {
                    uuid {
                        uuid: ref __self_1_0,
                    } => match *self {
                        uuid {
                            uuid: ref __self_0_0,
                        } => (*__self_0_0) != (*__self_1_0),
                    },
                }
            }
        }
        impl ::core::marker::StructuralEq for uuid {}
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::cmp::Eq for uuid {
            #[inline]
            #[doc(hidden)]
            fn assert_receiver_is_total_eq(&self) -> () {
                {
                    let _: ::core::cmp::AssertParamIsEq<String>;
                }
            }
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::fmt::Debug for uuid {
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                match *self {
                    uuid {
                        uuid: ref __self_0_0,
                    } => {
                        let mut debug_trait_builder = f.debug_struct("uuid");
                        let _ = debug_trait_builder.field("uuid", &&(*__self_0_0));
                        debug_trait_builder.finish()
                    }
                }
            }
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::clone::Clone for uuid {
            #[inline]
            fn clone(&self) -> uuid {
                match *self {
                    uuid {
                        uuid: ref __self_0_0,
                    } => uuid {
                        uuid: ::core::clone::Clone::clone(&(*__self_0_0)),
                    },
                }
            }
        }
        #[doc(hidden)]
        #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
        const _: () = {
            #[allow(rust_2018_idioms, clippy::useless_attribute)]
            extern crate serde as _serde;
            #[automatically_derived]
            impl _serde::Serialize for uuid {
                fn serialize<__S>(
                    &self,
                    __serializer: __S,
                ) -> _serde::export::Result<__S::Ok, __S::Error>
                where
                    __S: _serde::Serializer,
                {
                    let mut __serde_state = match _serde::Serializer::serialize_struct(
                        __serializer,
                        "uuid",
                        false as usize + 1,
                    ) {
                        _serde::export::Ok(__val) => __val,
                        _serde::export::Err(__err) => {
                            return _serde::export::Err(__err);
                        }
                    };
                    match _serde::ser::SerializeStruct::serialize_field(
                        &mut __serde_state,
                        "uuid",
                        &self.uuid,
                    ) {
                        _serde::export::Ok(__val) => __val,
                        _serde::export::Err(__err) => {
                            return _serde::export::Err(__err);
                        }
                    };
                    _serde::ser::SerializeStruct::end(__serde_state)
                }
            }
        };
        #[doc(hidden)]
        #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
        const _: () = {
            #[allow(rust_2018_idioms, clippy::useless_attribute)]
            extern crate serde as _serde;
            #[automatically_derived]
            impl<'de> _serde::Deserialize<'de> for uuid {
                fn deserialize<__D>(__deserializer: __D) -> _serde::export::Result<Self, __D::Error>
                where
                    __D: _serde::Deserializer<'de>,
                {
                    #[allow(non_camel_case_types)]
                    enum __Field {
                        __field0,
                        __ignore,
                    }
                    struct __FieldVisitor;
                    impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                        type Value = __Field;
                        fn expecting(
                            &self,
                            __formatter: &mut _serde::export::Formatter,
                        ) -> _serde::export::fmt::Result {
                            _serde::export::Formatter::write_str(__formatter, "field identifier")
                        }
                        fn visit_u64<__E>(
                            self,
                            __value: u64,
                        ) -> _serde::export::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                0u64 => _serde::export::Ok(__Field::__field0),
                                _ => _serde::export::Err(_serde::de::Error::invalid_value(
                                    _serde::de::Unexpected::Unsigned(__value),
                                    &"field index 0 <= i < 1",
                                )),
                            }
                        }
                        fn visit_str<__E>(
                            self,
                            __value: &str,
                        ) -> _serde::export::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                "uuid" => _serde::export::Ok(__Field::__field0),
                                _ => _serde::export::Ok(__Field::__ignore),
                            }
                        }
                        fn visit_bytes<__E>(
                            self,
                            __value: &[u8],
                        ) -> _serde::export::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                b"uuid" => _serde::export::Ok(__Field::__field0),
                                _ => _serde::export::Ok(__Field::__ignore),
                            }
                        }
                    }
                    impl<'de> _serde::Deserialize<'de> for __Field {
                        #[inline]
                        fn deserialize<__D>(
                            __deserializer: __D,
                        ) -> _serde::export::Result<Self, __D::Error>
                        where
                            __D: _serde::Deserializer<'de>,
                        {
                            _serde::Deserializer::deserialize_identifier(
                                __deserializer,
                                __FieldVisitor,
                            )
                        }
                    }
                    struct __Visitor<'de> {
                        marker: _serde::export::PhantomData<uuid>,
                        lifetime: _serde::export::PhantomData<&'de ()>,
                    }
                    impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                        type Value = uuid;
                        fn expecting(
                            &self,
                            __formatter: &mut _serde::export::Formatter,
                        ) -> _serde::export::fmt::Result {
                            _serde::export::Formatter::write_str(__formatter, "struct uuid")
                        }
                        #[inline]
                        fn visit_seq<__A>(
                            self,
                            mut __seq: __A,
                        ) -> _serde::export::Result<Self::Value, __A::Error>
                        where
                            __A: _serde::de::SeqAccess<'de>,
                        {
                            let __field0 = match match _serde::de::SeqAccess::next_element::<String>(
                                &mut __seq,
                            ) {
                                _serde::export::Ok(__val) => __val,
                                _serde::export::Err(__err) => {
                                    return _serde::export::Err(__err);
                                }
                            } {
                                _serde::export::Some(__value) => __value,
                                _serde::export::None => {
                                    return _serde::export::Err(_serde::de::Error::invalid_length(
                                        0usize,
                                        &"struct uuid with 1 element",
                                    ));
                                }
                            };
                            _serde::export::Ok(uuid { uuid: __field0 })
                        }
                        #[inline]
                        fn visit_map<__A>(
                            self,
                            mut __map: __A,
                        ) -> _serde::export::Result<Self::Value, __A::Error>
                        where
                            __A: _serde::de::MapAccess<'de>,
                        {
                            let mut __field0: _serde::export::Option<String> = _serde::export::None;
                            while let _serde::export::Some(__key) =
                                match _serde::de::MapAccess::next_key::<__Field>(&mut __map) {
                                    _serde::export::Ok(__val) => __val,
                                    _serde::export::Err(__err) => {
                                        return _serde::export::Err(__err);
                                    }
                                }
                            {
                                match __key {
                                    __Field::__field0 => {
                                        if _serde::export::Option::is_some(&__field0) {
                                            return _serde::export::Err(
                                                <__A::Error as _serde::de::Error>::duplicate_field(
                                                    "uuid",
                                                ),
                                            );
                                        }
                                        __field0 = _serde::export::Some(
                                            match _serde::de::MapAccess::next_value::<String>(
                                                &mut __map,
                                            ) {
                                                _serde::export::Ok(__val) => __val,
                                                _serde::export::Err(__err) => {
                                                    return _serde::export::Err(__err);
                                                }
                                            },
                                        );
                                    }
                                    _ => {
                                        let _ = match _serde::de::MapAccess::next_value::<
                                            _serde::de::IgnoredAny,
                                        >(
                                            &mut __map
                                        ) {
                                            _serde::export::Ok(__val) => __val,
                                            _serde::export::Err(__err) => {
                                                return _serde::export::Err(__err);
                                            }
                                        };
                                    }
                                }
                            }
                            let __field0 = match __field0 {
                                _serde::export::Some(__field0) => __field0,
                                _serde::export::None => {
                                    match _serde::private::de::missing_field("uuid") {
                                        _serde::export::Ok(__val) => __val,
                                        _serde::export::Err(__err) => {
                                            return _serde::export::Err(__err);
                                        }
                                    }
                                }
                            };
                            _serde::export::Ok(uuid { uuid: __field0 })
                        }
                    }
                    const FIELDS: &'static [&'static str] = &["uuid"];
                    _serde::Deserializer::deserialize_struct(
                        __deserializer,
                        "uuid",
                        FIELDS,
                        __Visitor {
                            marker: _serde::export::PhantomData::<uuid>,
                            lifetime: _serde::export::PhantomData,
                        },
                    )
                }
            }
        };
        impl uuid {
            pub fn new(name: String) -> Self {
                Self { uuid: name }
            }
        }
        #[xml(tag = "name")]
        pub struct name {
            #[xml(text)]
            name: String,
        }
        impl strong_xml::XmlWrite for name {
            fn to_writer<W: std::io::Write>(
                &self,
                mut writer: &mut strong_xml::XmlWriter<W>,
            ) -> strong_xml::XmlResult<()> {
                let name { name: __self_name } = self;
                writer.write_element_start("name")?;
                writer.write_element_end_open()?;
                let __value = &__self_name;
                writer.write_text(&{
                    let res = ::alloc::fmt::format(::core::fmt::Arguments::new_v1(
                        &[""],
                        &match (&__value,) {
                            (arg0,) => [::core::fmt::ArgumentV1::new(
                                arg0,
                                ::core::fmt::Display::fmt,
                            )],
                        },
                    ));
                    res
                })?;
                writer.write_element_end_close("name")?;
                Ok(())
            }
        }
        impl<'__input> strong_xml::XmlRead<'__input> for name {
            fn from_reader(
                mut reader: &mut strong_xml::XmlReader<'__input>,
            ) -> strong_xml::XmlResult<Self> {
                use strong_xml::xmlparser::{ElementEnd, Token, Tokenizer};
                use strong_xml::XmlError;
                let __self_name;
                reader.read_till_element_start("name")?;
                while let Some((__key, __value)) = reader.find_attribute()? {
                    match __key {
                        key => {}
                    }
                }
                let __value = reader.read_text("name")?;
                __self_name = Some(
                    <String as std::str::FromStr>::from_str(&__value)
                        .map_err(|e| XmlError::FromStr(e.into()))?,
                );
                let __res = name {
                    name: __self_name.ok_or(XmlError::MissingField {
                        name: "name".to_owned(),
                        field: "name".to_owned(),
                    })?,
                };
                return Ok(__res);
            }
        }
        impl ::core::marker::StructuralPartialEq for name {}
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::cmp::PartialEq for name {
            #[inline]
            fn eq(&self, other: &name) -> bool {
                match *other {
                    name {
                        name: ref __self_1_0,
                    } => match *self {
                        name {
                            name: ref __self_0_0,
                        } => (*__self_0_0) == (*__self_1_0),
                    },
                }
            }
            #[inline]
            fn ne(&self, other: &name) -> bool {
                match *other {
                    name {
                        name: ref __self_1_0,
                    } => match *self {
                        name {
                            name: ref __self_0_0,
                        } => (*__self_0_0) != (*__self_1_0),
                    },
                }
            }
        }
        impl ::core::marker::StructuralEq for name {}
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::cmp::Eq for name {
            #[inline]
            #[doc(hidden)]
            fn assert_receiver_is_total_eq(&self) -> () {
                {
                    let _: ::core::cmp::AssertParamIsEq<String>;
                }
            }
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::fmt::Debug for name {
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                match *self {
                    name {
                        name: ref __self_0_0,
                    } => {
                        let mut debug_trait_builder = f.debug_struct("name");
                        let _ = debug_trait_builder.field("name", &&(*__self_0_0));
                        debug_trait_builder.finish()
                    }
                }
            }
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::clone::Clone for name {
            #[inline]
            fn clone(&self) -> name {
                match *self {
                    name {
                        name: ref __self_0_0,
                    } => name {
                        name: ::core::clone::Clone::clone(&(*__self_0_0)),
                    },
                }
            }
        }
        #[doc(hidden)]
        #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
        const _: () = {
            #[allow(rust_2018_idioms, clippy::useless_attribute)]
            extern crate serde as _serde;
            #[automatically_derived]
            impl _serde::Serialize for name {
                fn serialize<__S>(
                    &self,
                    __serializer: __S,
                ) -> _serde::export::Result<__S::Ok, __S::Error>
                where
                    __S: _serde::Serializer,
                {
                    let mut __serde_state = match _serde::Serializer::serialize_struct(
                        __serializer,
                        "name",
                        false as usize + 1,
                    ) {
                        _serde::export::Ok(__val) => __val,
                        _serde::export::Err(__err) => {
                            return _serde::export::Err(__err);
                        }
                    };
                    match _serde::ser::SerializeStruct::serialize_field(
                        &mut __serde_state,
                        "name",
                        &self.name,
                    ) {
                        _serde::export::Ok(__val) => __val,
                        _serde::export::Err(__err) => {
                            return _serde::export::Err(__err);
                        }
                    };
                    _serde::ser::SerializeStruct::end(__serde_state)
                }
            }
        };
        #[doc(hidden)]
        #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
        const _: () = {
            #[allow(rust_2018_idioms, clippy::useless_attribute)]
            extern crate serde as _serde;
            #[automatically_derived]
            impl<'de> _serde::Deserialize<'de> for name {
                fn deserialize<__D>(__deserializer: __D) -> _serde::export::Result<Self, __D::Error>
                where
                    __D: _serde::Deserializer<'de>,
                {
                    #[allow(non_camel_case_types)]
                    enum __Field {
                        __field0,
                        __ignore,
                    }
                    struct __FieldVisitor;
                    impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                        type Value = __Field;
                        fn expecting(
                            &self,
                            __formatter: &mut _serde::export::Formatter,
                        ) -> _serde::export::fmt::Result {
                            _serde::export::Formatter::write_str(__formatter, "field identifier")
                        }
                        fn visit_u64<__E>(
                            self,
                            __value: u64,
                        ) -> _serde::export::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                0u64 => _serde::export::Ok(__Field::__field0),
                                _ => _serde::export::Err(_serde::de::Error::invalid_value(
                                    _serde::de::Unexpected::Unsigned(__value),
                                    &"field index 0 <= i < 1",
                                )),
                            }
                        }
                        fn visit_str<__E>(
                            self,
                            __value: &str,
                        ) -> _serde::export::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                "name" => _serde::export::Ok(__Field::__field0),
                                _ => _serde::export::Ok(__Field::__ignore),
                            }
                        }
                        fn visit_bytes<__E>(
                            self,
                            __value: &[u8],
                        ) -> _serde::export::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                b"name" => _serde::export::Ok(__Field::__field0),
                                _ => _serde::export::Ok(__Field::__ignore),
                            }
                        }
                    }
                    impl<'de> _serde::Deserialize<'de> for __Field {
                        #[inline]
                        fn deserialize<__D>(
                            __deserializer: __D,
                        ) -> _serde::export::Result<Self, __D::Error>
                        where
                            __D: _serde::Deserializer<'de>,
                        {
                            _serde::Deserializer::deserialize_identifier(
                                __deserializer,
                                __FieldVisitor,
                            )
                        }
                    }
                    struct __Visitor<'de> {
                        marker: _serde::export::PhantomData<name>,
                        lifetime: _serde::export::PhantomData<&'de ()>,
                    }
                    impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                        type Value = name;
                        fn expecting(
                            &self,
                            __formatter: &mut _serde::export::Formatter,
                        ) -> _serde::export::fmt::Result {
                            _serde::export::Formatter::write_str(__formatter, "struct name")
                        }
                        #[inline]
                        fn visit_seq<__A>(
                            self,
                            mut __seq: __A,
                        ) -> _serde::export::Result<Self::Value, __A::Error>
                        where
                            __A: _serde::de::SeqAccess<'de>,
                        {
                            let __field0 = match match _serde::de::SeqAccess::next_element::<String>(
                                &mut __seq,
                            ) {
                                _serde::export::Ok(__val) => __val,
                                _serde::export::Err(__err) => {
                                    return _serde::export::Err(__err);
                                }
                            } {
                                _serde::export::Some(__value) => __value,
                                _serde::export::None => {
                                    return _serde::export::Err(_serde::de::Error::invalid_length(
                                        0usize,
                                        &"struct name with 1 element",
                                    ));
                                }
                            };
                            _serde::export::Ok(name { name: __field0 })
                        }
                        #[inline]
                        fn visit_map<__A>(
                            self,
                            mut __map: __A,
                        ) -> _serde::export::Result<Self::Value, __A::Error>
                        where
                            __A: _serde::de::MapAccess<'de>,
                        {
                            let mut __field0: _serde::export::Option<String> = _serde::export::None;
                            while let _serde::export::Some(__key) =
                                match _serde::de::MapAccess::next_key::<__Field>(&mut __map) {
                                    _serde::export::Ok(__val) => __val,
                                    _serde::export::Err(__err) => {
                                        return _serde::export::Err(__err);
                                    }
                                }
                            {
                                match __key {
                                    __Field::__field0 => {
                                        if _serde::export::Option::is_some(&__field0) {
                                            return _serde::export::Err(
                                                <__A::Error as _serde::de::Error>::duplicate_field(
                                                    "name",
                                                ),
                                            );
                                        }
                                        __field0 = _serde::export::Some(
                                            match _serde::de::MapAccess::next_value::<String>(
                                                &mut __map,
                                            ) {
                                                _serde::export::Ok(__val) => __val,
                                                _serde::export::Err(__err) => {
                                                    return _serde::export::Err(__err);
                                                }
                                            },
                                        );
                                    }
                                    _ => {
                                        let _ = match _serde::de::MapAccess::next_value::<
                                            _serde::de::IgnoredAny,
                                        >(
                                            &mut __map
                                        ) {
                                            _serde::export::Ok(__val) => __val,
                                            _serde::export::Err(__err) => {
                                                return _serde::export::Err(__err);
                                            }
                                        };
                                    }
                                }
                            }
                            let __field0 = match __field0 {
                                _serde::export::Some(__field0) => __field0,
                                _serde::export::None => {
                                    match _serde::private::de::missing_field("name") {
                                        _serde::export::Ok(__val) => __val,
                                        _serde::export::Err(__err) => {
                                            return _serde::export::Err(__err);
                                        }
                                    }
                                }
                            };
                            _serde::export::Ok(name { name: __field0 })
                        }
                    }
                    const FIELDS: &'static [&'static str] = &["name"];
                    _serde::Deserializer::deserialize_struct(
                        __deserializer,
                        "name",
                        FIELDS,
                        __Visitor {
                            marker: _serde::export::PhantomData::<name>,
                            lifetime: _serde::export::PhantomData,
                        },
                    )
                }
            }
        };
        impl name {
            pub fn new(name: String) -> Self {
                Self { name: name }
            }
        }
        #[xml(tag = "emulator")]
        pub struct emulator {
            #[xml(text)]
            emulator: String,
        }
        impl strong_xml::XmlWrite for emulator {
            fn to_writer<W: std::io::Write>(
                &self,
                mut writer: &mut strong_xml::XmlWriter<W>,
            ) -> strong_xml::XmlResult<()> {
                let emulator {
                    emulator: __self_emulator,
                } = self;
                writer.write_element_start("emulator")?;
                writer.write_element_end_open()?;
                let __value = &__self_emulator;
                writer.write_text(&{
                    let res = ::alloc::fmt::format(::core::fmt::Arguments::new_v1(
                        &[""],
                        &match (&__value,) {
                            (arg0,) => [::core::fmt::ArgumentV1::new(
                                arg0,
                                ::core::fmt::Display::fmt,
                            )],
                        },
                    ));
                    res
                })?;
                writer.write_element_end_close("emulator")?;
                Ok(())
            }
        }
        impl<'__input> strong_xml::XmlRead<'__input> for emulator {
            fn from_reader(
                mut reader: &mut strong_xml::XmlReader<'__input>,
            ) -> strong_xml::XmlResult<Self> {
                use strong_xml::xmlparser::{ElementEnd, Token, Tokenizer};
                use strong_xml::XmlError;
                let __self_emulator;
                reader.read_till_element_start("emulator")?;
                while let Some((__key, __value)) = reader.find_attribute()? {
                    match __key {
                        key => {}
                    }
                }
                let __value = reader.read_text("emulator")?;
                __self_emulator = Some(
                    <String as std::str::FromStr>::from_str(&__value)
                        .map_err(|e| XmlError::FromStr(e.into()))?,
                );
                let __res = emulator {
                    emulator: __self_emulator.ok_or(XmlError::MissingField {
                        name: "emulator".to_owned(),
                        field: "emulator".to_owned(),
                    })?,
                };
                return Ok(__res);
            }
        }
        impl ::core::marker::StructuralPartialEq for emulator {}
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::cmp::PartialEq for emulator {
            #[inline]
            fn eq(&self, other: &emulator) -> bool {
                match *other {
                    emulator {
                        emulator: ref __self_1_0,
                    } => match *self {
                        emulator {
                            emulator: ref __self_0_0,
                        } => (*__self_0_0) == (*__self_1_0),
                    },
                }
            }
            #[inline]
            fn ne(&self, other: &emulator) -> bool {
                match *other {
                    emulator {
                        emulator: ref __self_1_0,
                    } => match *self {
                        emulator {
                            emulator: ref __self_0_0,
                        } => (*__self_0_0) != (*__self_1_0),
                    },
                }
            }
        }
        impl ::core::marker::StructuralEq for emulator {}
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::cmp::Eq for emulator {
            #[inline]
            #[doc(hidden)]
            fn assert_receiver_is_total_eq(&self) -> () {
                {
                    let _: ::core::cmp::AssertParamIsEq<String>;
                }
            }
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::fmt::Debug for emulator {
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                match *self {
                    emulator {
                        emulator: ref __self_0_0,
                    } => {
                        let mut debug_trait_builder = f.debug_struct("emulator");
                        let _ = debug_trait_builder.field("emulator", &&(*__self_0_0));
                        debug_trait_builder.finish()
                    }
                }
            }
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::clone::Clone for emulator {
            #[inline]
            fn clone(&self) -> emulator {
                match *self {
                    emulator {
                        emulator: ref __self_0_0,
                    } => emulator {
                        emulator: ::core::clone::Clone::clone(&(*__self_0_0)),
                    },
                }
            }
        }
        #[doc(hidden)]
        #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
        const _: () = {
            #[allow(rust_2018_idioms, clippy::useless_attribute)]
            extern crate serde as _serde;
            #[automatically_derived]
            impl _serde::Serialize for emulator {
                fn serialize<__S>(
                    &self,
                    __serializer: __S,
                ) -> _serde::export::Result<__S::Ok, __S::Error>
                where
                    __S: _serde::Serializer,
                {
                    let mut __serde_state = match _serde::Serializer::serialize_struct(
                        __serializer,
                        "emulator",
                        false as usize + 1,
                    ) {
                        _serde::export::Ok(__val) => __val,
                        _serde::export::Err(__err) => {
                            return _serde::export::Err(__err);
                        }
                    };
                    match _serde::ser::SerializeStruct::serialize_field(
                        &mut __serde_state,
                        "emulator",
                        &self.emulator,
                    ) {
                        _serde::export::Ok(__val) => __val,
                        _serde::export::Err(__err) => {
                            return _serde::export::Err(__err);
                        }
                    };
                    _serde::ser::SerializeStruct::end(__serde_state)
                }
            }
        };
        #[doc(hidden)]
        #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
        const _: () = {
            #[allow(rust_2018_idioms, clippy::useless_attribute)]
            extern crate serde as _serde;
            #[automatically_derived]
            impl<'de> _serde::Deserialize<'de> for emulator {
                fn deserialize<__D>(__deserializer: __D) -> _serde::export::Result<Self, __D::Error>
                where
                    __D: _serde::Deserializer<'de>,
                {
                    #[allow(non_camel_case_types)]
                    enum __Field {
                        __field0,
                        __ignore,
                    }
                    struct __FieldVisitor;
                    impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                        type Value = __Field;
                        fn expecting(
                            &self,
                            __formatter: &mut _serde::export::Formatter,
                        ) -> _serde::export::fmt::Result {
                            _serde::export::Formatter::write_str(__formatter, "field identifier")
                        }
                        fn visit_u64<__E>(
                            self,
                            __value: u64,
                        ) -> _serde::export::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                0u64 => _serde::export::Ok(__Field::__field0),
                                _ => _serde::export::Err(_serde::de::Error::invalid_value(
                                    _serde::de::Unexpected::Unsigned(__value),
                                    &"field index 0 <= i < 1",
                                )),
                            }
                        }
                        fn visit_str<__E>(
                            self,
                            __value: &str,
                        ) -> _serde::export::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                "emulator" => _serde::export::Ok(__Field::__field0),
                                _ => _serde::export::Ok(__Field::__ignore),
                            }
                        }
                        fn visit_bytes<__E>(
                            self,
                            __value: &[u8],
                        ) -> _serde::export::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                b"emulator" => _serde::export::Ok(__Field::__field0),
                                _ => _serde::export::Ok(__Field::__ignore),
                            }
                        }
                    }
                    impl<'de> _serde::Deserialize<'de> for __Field {
                        #[inline]
                        fn deserialize<__D>(
                            __deserializer: __D,
                        ) -> _serde::export::Result<Self, __D::Error>
                        where
                            __D: _serde::Deserializer<'de>,
                        {
                            _serde::Deserializer::deserialize_identifier(
                                __deserializer,
                                __FieldVisitor,
                            )
                        }
                    }
                    struct __Visitor<'de> {
                        marker: _serde::export::PhantomData<emulator>,
                        lifetime: _serde::export::PhantomData<&'de ()>,
                    }
                    impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                        type Value = emulator;
                        fn expecting(
                            &self,
                            __formatter: &mut _serde::export::Formatter,
                        ) -> _serde::export::fmt::Result {
                            _serde::export::Formatter::write_str(__formatter, "struct emulator")
                        }
                        #[inline]
                        fn visit_seq<__A>(
                            self,
                            mut __seq: __A,
                        ) -> _serde::export::Result<Self::Value, __A::Error>
                        where
                            __A: _serde::de::SeqAccess<'de>,
                        {
                            let __field0 = match match _serde::de::SeqAccess::next_element::<String>(
                                &mut __seq,
                            ) {
                                _serde::export::Ok(__val) => __val,
                                _serde::export::Err(__err) => {
                                    return _serde::export::Err(__err);
                                }
                            } {
                                _serde::export::Some(__value) => __value,
                                _serde::export::None => {
                                    return _serde::export::Err(_serde::de::Error::invalid_length(
                                        0usize,
                                        &"struct emulator with 1 element",
                                    ));
                                }
                            };
                            _serde::export::Ok(emulator { emulator: __field0 })
                        }
                        #[inline]
                        fn visit_map<__A>(
                            self,
                            mut __map: __A,
                        ) -> _serde::export::Result<Self::Value, __A::Error>
                        where
                            __A: _serde::de::MapAccess<'de>,
                        {
                            let mut __field0: _serde::export::Option<String> = _serde::export::None;
                            while let _serde::export::Some(__key) =
                                match _serde::de::MapAccess::next_key::<__Field>(&mut __map) {
                                    _serde::export::Ok(__val) => __val,
                                    _serde::export::Err(__err) => {
                                        return _serde::export::Err(__err);
                                    }
                                }
                            {
                                match __key {
                                    __Field::__field0 => {
                                        if _serde::export::Option::is_some(&__field0) {
                                            return _serde::export::Err(
                                                <__A::Error as _serde::de::Error>::duplicate_field(
                                                    "emulator",
                                                ),
                                            );
                                        }
                                        __field0 = _serde::export::Some(
                                            match _serde::de::MapAccess::next_value::<String>(
                                                &mut __map,
                                            ) {
                                                _serde::export::Ok(__val) => __val,
                                                _serde::export::Err(__err) => {
                                                    return _serde::export::Err(__err);
                                                }
                                            },
                                        );
                                    }
                                    _ => {
                                        let _ = match _serde::de::MapAccess::next_value::<
                                            _serde::de::IgnoredAny,
                                        >(
                                            &mut __map
                                        ) {
                                            _serde::export::Ok(__val) => __val,
                                            _serde::export::Err(__err) => {
                                                return _serde::export::Err(__err);
                                            }
                                        };
                                    }
                                }
                            }
                            let __field0 = match __field0 {
                                _serde::export::Some(__field0) => __field0,
                                _serde::export::None => {
                                    match _serde::private::de::missing_field("emulator") {
                                        _serde::export::Ok(__val) => __val,
                                        _serde::export::Err(__err) => {
                                            return _serde::export::Err(__err);
                                        }
                                    }
                                }
                            };
                            _serde::export::Ok(emulator { emulator: __field0 })
                        }
                    }
                    const FIELDS: &'static [&'static str] = &["emulator"];
                    _serde::Deserializer::deserialize_struct(
                        __deserializer,
                        "emulator",
                        FIELDS,
                        __Visitor {
                            marker: _serde::export::PhantomData::<emulator>,
                            lifetime: _serde::export::PhantomData,
                        },
                    )
                }
            }
        };
        impl emulator {
            pub fn new(name: String) -> Self {
                Self { emulator: name }
            }
        }
        #[xml(tag = "on_powerof")]
        pub struct on_poweroff {
            #[xml(text)]
            on_poweroff: String,
        }
        impl strong_xml::XmlWrite for on_poweroff {
            fn to_writer<W: std::io::Write>(
                &self,
                mut writer: &mut strong_xml::XmlWriter<W>,
            ) -> strong_xml::XmlResult<()> {
                let on_poweroff {
                    on_poweroff: __self_on_poweroff,
                } = self;
                writer.write_element_start("on_powerof")?;
                writer.write_element_end_open()?;
                let __value = &__self_on_poweroff;
                writer.write_text(&{
                    let res = ::alloc::fmt::format(::core::fmt::Arguments::new_v1(
                        &[""],
                        &match (&__value,) {
                            (arg0,) => [::core::fmt::ArgumentV1::new(
                                arg0,
                                ::core::fmt::Display::fmt,
                            )],
                        },
                    ));
                    res
                })?;
                writer.write_element_end_close("on_powerof")?;
                Ok(())
            }
        }
        impl<'__input> strong_xml::XmlRead<'__input> for on_poweroff {
            fn from_reader(
                mut reader: &mut strong_xml::XmlReader<'__input>,
            ) -> strong_xml::XmlResult<Self> {
                use strong_xml::xmlparser::{ElementEnd, Token, Tokenizer};
                use strong_xml::XmlError;
                let __self_on_poweroff;
                reader.read_till_element_start("on_powerof")?;
                while let Some((__key, __value)) = reader.find_attribute()? {
                    match __key {
                        key => {}
                    }
                }
                let __value = reader.read_text("on_powerof")?;
                __self_on_poweroff = Some(
                    <String as std::str::FromStr>::from_str(&__value)
                        .map_err(|e| XmlError::FromStr(e.into()))?,
                );
                let __res = on_poweroff {
                    on_poweroff: __self_on_poweroff.ok_or(XmlError::MissingField {
                        name: "on_poweroff".to_owned(),
                        field: "on_poweroff".to_owned(),
                    })?,
                };
                return Ok(__res);
            }
        }
        impl ::core::marker::StructuralPartialEq for on_poweroff {}
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::cmp::PartialEq for on_poweroff {
            #[inline]
            fn eq(&self, other: &on_poweroff) -> bool {
                match *other {
                    on_poweroff {
                        on_poweroff: ref __self_1_0,
                    } => match *self {
                        on_poweroff {
                            on_poweroff: ref __self_0_0,
                        } => (*__self_0_0) == (*__self_1_0),
                    },
                }
            }
            #[inline]
            fn ne(&self, other: &on_poweroff) -> bool {
                match *other {
                    on_poweroff {
                        on_poweroff: ref __self_1_0,
                    } => match *self {
                        on_poweroff {
                            on_poweroff: ref __self_0_0,
                        } => (*__self_0_0) != (*__self_1_0),
                    },
                }
            }
        }
        impl ::core::marker::StructuralEq for on_poweroff {}
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::cmp::Eq for on_poweroff {
            #[inline]
            #[doc(hidden)]
            fn assert_receiver_is_total_eq(&self) -> () {
                {
                    let _: ::core::cmp::AssertParamIsEq<String>;
                }
            }
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::fmt::Debug for on_poweroff {
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                match *self {
                    on_poweroff {
                        on_poweroff: ref __self_0_0,
                    } => {
                        let mut debug_trait_builder = f.debug_struct("on_poweroff");
                        let _ = debug_trait_builder.field("on_poweroff", &&(*__self_0_0));
                        debug_trait_builder.finish()
                    }
                }
            }
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::clone::Clone for on_poweroff {
            #[inline]
            fn clone(&self) -> on_poweroff {
                match *self {
                    on_poweroff {
                        on_poweroff: ref __self_0_0,
                    } => on_poweroff {
                        on_poweroff: ::core::clone::Clone::clone(&(*__self_0_0)),
                    },
                }
            }
        }
        #[doc(hidden)]
        #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
        const _: () = {
            #[allow(rust_2018_idioms, clippy::useless_attribute)]
            extern crate serde as _serde;
            #[automatically_derived]
            impl _serde::Serialize for on_poweroff {
                fn serialize<__S>(
                    &self,
                    __serializer: __S,
                ) -> _serde::export::Result<__S::Ok, __S::Error>
                where
                    __S: _serde::Serializer,
                {
                    let mut __serde_state = match _serde::Serializer::serialize_struct(
                        __serializer,
                        "on_poweroff",
                        false as usize + 1,
                    ) {
                        _serde::export::Ok(__val) => __val,
                        _serde::export::Err(__err) => {
                            return _serde::export::Err(__err);
                        }
                    };
                    match _serde::ser::SerializeStruct::serialize_field(
                        &mut __serde_state,
                        "on_poweroff",
                        &self.on_poweroff,
                    ) {
                        _serde::export::Ok(__val) => __val,
                        _serde::export::Err(__err) => {
                            return _serde::export::Err(__err);
                        }
                    };
                    _serde::ser::SerializeStruct::end(__serde_state)
                }
            }
        };
        #[doc(hidden)]
        #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
        const _: () = {
            #[allow(rust_2018_idioms, clippy::useless_attribute)]
            extern crate serde as _serde;
            #[automatically_derived]
            impl<'de> _serde::Deserialize<'de> for on_poweroff {
                fn deserialize<__D>(__deserializer: __D) -> _serde::export::Result<Self, __D::Error>
                where
                    __D: _serde::Deserializer<'de>,
                {
                    #[allow(non_camel_case_types)]
                    enum __Field {
                        __field0,
                        __ignore,
                    }
                    struct __FieldVisitor;
                    impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                        type Value = __Field;
                        fn expecting(
                            &self,
                            __formatter: &mut _serde::export::Formatter,
                        ) -> _serde::export::fmt::Result {
                            _serde::export::Formatter::write_str(__formatter, "field identifier")
                        }
                        fn visit_u64<__E>(
                            self,
                            __value: u64,
                        ) -> _serde::export::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                0u64 => _serde::export::Ok(__Field::__field0),
                                _ => _serde::export::Err(_serde::de::Error::invalid_value(
                                    _serde::de::Unexpected::Unsigned(__value),
                                    &"field index 0 <= i < 1",
                                )),
                            }
                        }
                        fn visit_str<__E>(
                            self,
                            __value: &str,
                        ) -> _serde::export::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                "on_poweroff" => _serde::export::Ok(__Field::__field0),
                                _ => _serde::export::Ok(__Field::__ignore),
                            }
                        }
                        fn visit_bytes<__E>(
                            self,
                            __value: &[u8],
                        ) -> _serde::export::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                b"on_poweroff" => _serde::export::Ok(__Field::__field0),
                                _ => _serde::export::Ok(__Field::__ignore),
                            }
                        }
                    }
                    impl<'de> _serde::Deserialize<'de> for __Field {
                        #[inline]
                        fn deserialize<__D>(
                            __deserializer: __D,
                        ) -> _serde::export::Result<Self, __D::Error>
                        where
                            __D: _serde::Deserializer<'de>,
                        {
                            _serde::Deserializer::deserialize_identifier(
                                __deserializer,
                                __FieldVisitor,
                            )
                        }
                    }
                    struct __Visitor<'de> {
                        marker: _serde::export::PhantomData<on_poweroff>,
                        lifetime: _serde::export::PhantomData<&'de ()>,
                    }
                    impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                        type Value = on_poweroff;
                        fn expecting(
                            &self,
                            __formatter: &mut _serde::export::Formatter,
                        ) -> _serde::export::fmt::Result {
                            _serde::export::Formatter::write_str(__formatter, "struct on_poweroff")
                        }
                        #[inline]
                        fn visit_seq<__A>(
                            self,
                            mut __seq: __A,
                        ) -> _serde::export::Result<Self::Value, __A::Error>
                        where
                            __A: _serde::de::SeqAccess<'de>,
                        {
                            let __field0 = match match _serde::de::SeqAccess::next_element::<String>(
                                &mut __seq,
                            ) {
                                _serde::export::Ok(__val) => __val,
                                _serde::export::Err(__err) => {
                                    return _serde::export::Err(__err);
                                }
                            } {
                                _serde::export::Some(__value) => __value,
                                _serde::export::None => {
                                    return _serde::export::Err(_serde::de::Error::invalid_length(
                                        0usize,
                                        &"struct on_poweroff with 1 element",
                                    ));
                                }
                            };
                            _serde::export::Ok(on_poweroff {
                                on_poweroff: __field0,
                            })
                        }
                        #[inline]
                        fn visit_map<__A>(
                            self,
                            mut __map: __A,
                        ) -> _serde::export::Result<Self::Value, __A::Error>
                        where
                            __A: _serde::de::MapAccess<'de>,
                        {
                            let mut __field0: _serde::export::Option<String> = _serde::export::None;
                            while let _serde::export::Some(__key) =
                                match _serde::de::MapAccess::next_key::<__Field>(&mut __map) {
                                    _serde::export::Ok(__val) => __val,
                                    _serde::export::Err(__err) => {
                                        return _serde::export::Err(__err);
                                    }
                                }
                            {
                                match __key {
                                    __Field::__field0 => {
                                        if _serde::export::Option::is_some(&__field0) {
                                            return _serde::export::Err(
                                                <__A::Error as _serde::de::Error>::duplicate_field(
                                                    "on_poweroff",
                                                ),
                                            );
                                        }
                                        __field0 = _serde::export::Some(
                                            match _serde::de::MapAccess::next_value::<String>(
                                                &mut __map,
                                            ) {
                                                _serde::export::Ok(__val) => __val,
                                                _serde::export::Err(__err) => {
                                                    return _serde::export::Err(__err);
                                                }
                                            },
                                        );
                                    }
                                    _ => {
                                        let _ = match _serde::de::MapAccess::next_value::<
                                            _serde::de::IgnoredAny,
                                        >(
                                            &mut __map
                                        ) {
                                            _serde::export::Ok(__val) => __val,
                                            _serde::export::Err(__err) => {
                                                return _serde::export::Err(__err);
                                            }
                                        };
                                    }
                                }
                            }
                            let __field0 = match __field0 {
                                _serde::export::Some(__field0) => __field0,
                                _serde::export::None => {
                                    match _serde::private::de::missing_field("on_poweroff") {
                                        _serde::export::Ok(__val) => __val,
                                        _serde::export::Err(__err) => {
                                            return _serde::export::Err(__err);
                                        }
                                    }
                                }
                            };
                            _serde::export::Ok(on_poweroff {
                                on_poweroff: __field0,
                            })
                        }
                    }
                    const FIELDS: &'static [&'static str] = &["on_poweroff"];
                    _serde::Deserializer::deserialize_struct(
                        __deserializer,
                        "on_poweroff",
                        FIELDS,
                        __Visitor {
                            marker: _serde::export::PhantomData::<on_poweroff>,
                            lifetime: _serde::export::PhantomData,
                        },
                    )
                }
            }
        };
        impl on_poweroff {
            pub fn new(name: String) -> Self {
                Self { on_poweroff: name }
            }
        }
        #[xml(tag = "on_reboot")]
        pub struct on_reboot {
            #[xml(text)]
            on_reboot: String,
        }
        impl strong_xml::XmlWrite for on_reboot {
            fn to_writer<W: std::io::Write>(
                &self,
                mut writer: &mut strong_xml::XmlWriter<W>,
            ) -> strong_xml::XmlResult<()> {
                let on_reboot {
                    on_reboot: __self_on_reboot,
                } = self;
                writer.write_element_start("on_reboot")?;
                writer.write_element_end_open()?;
                let __value = &__self_on_reboot;
                writer.write_text(&{
                    let res = ::alloc::fmt::format(::core::fmt::Arguments::new_v1(
                        &[""],
                        &match (&__value,) {
                            (arg0,) => [::core::fmt::ArgumentV1::new(
                                arg0,
                                ::core::fmt::Display::fmt,
                            )],
                        },
                    ));
                    res
                })?;
                writer.write_element_end_close("on_reboot")?;
                Ok(())
            }
        }
        impl<'__input> strong_xml::XmlRead<'__input> for on_reboot {
            fn from_reader(
                mut reader: &mut strong_xml::XmlReader<'__input>,
            ) -> strong_xml::XmlResult<Self> {
                use strong_xml::xmlparser::{ElementEnd, Token, Tokenizer};
                use strong_xml::XmlError;
                let __self_on_reboot;
                reader.read_till_element_start("on_reboot")?;
                while let Some((__key, __value)) = reader.find_attribute()? {
                    match __key {
                        key => {}
                    }
                }
                let __value = reader.read_text("on_reboot")?;
                __self_on_reboot = Some(
                    <String as std::str::FromStr>::from_str(&__value)
                        .map_err(|e| XmlError::FromStr(e.into()))?,
                );
                let __res = on_reboot {
                    on_reboot: __self_on_reboot.ok_or(XmlError::MissingField {
                        name: "on_reboot".to_owned(),
                        field: "on_reboot".to_owned(),
                    })?,
                };
                return Ok(__res);
            }
        }
        impl ::core::marker::StructuralPartialEq for on_reboot {}
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::cmp::PartialEq for on_reboot {
            #[inline]
            fn eq(&self, other: &on_reboot) -> bool {
                match *other {
                    on_reboot {
                        on_reboot: ref __self_1_0,
                    } => match *self {
                        on_reboot {
                            on_reboot: ref __self_0_0,
                        } => (*__self_0_0) == (*__self_1_0),
                    },
                }
            }
            #[inline]
            fn ne(&self, other: &on_reboot) -> bool {
                match *other {
                    on_reboot {
                        on_reboot: ref __self_1_0,
                    } => match *self {
                        on_reboot {
                            on_reboot: ref __self_0_0,
                        } => (*__self_0_0) != (*__self_1_0),
                    },
                }
            }
        }
        impl ::core::marker::StructuralEq for on_reboot {}
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::cmp::Eq for on_reboot {
            #[inline]
            #[doc(hidden)]
            fn assert_receiver_is_total_eq(&self) -> () {
                {
                    let _: ::core::cmp::AssertParamIsEq<String>;
                }
            }
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::fmt::Debug for on_reboot {
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                match *self {
                    on_reboot {
                        on_reboot: ref __self_0_0,
                    } => {
                        let mut debug_trait_builder = f.debug_struct("on_reboot");
                        let _ = debug_trait_builder.field("on_reboot", &&(*__self_0_0));
                        debug_trait_builder.finish()
                    }
                }
            }
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::clone::Clone for on_reboot {
            #[inline]
            fn clone(&self) -> on_reboot {
                match *self {
                    on_reboot {
                        on_reboot: ref __self_0_0,
                    } => on_reboot {
                        on_reboot: ::core::clone::Clone::clone(&(*__self_0_0)),
                    },
                }
            }
        }
        #[doc(hidden)]
        #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
        const _: () = {
            #[allow(rust_2018_idioms, clippy::useless_attribute)]
            extern crate serde as _serde;
            #[automatically_derived]
            impl _serde::Serialize for on_reboot {
                fn serialize<__S>(
                    &self,
                    __serializer: __S,
                ) -> _serde::export::Result<__S::Ok, __S::Error>
                where
                    __S: _serde::Serializer,
                {
                    let mut __serde_state = match _serde::Serializer::serialize_struct(
                        __serializer,
                        "on_reboot",
                        false as usize + 1,
                    ) {
                        _serde::export::Ok(__val) => __val,
                        _serde::export::Err(__err) => {
                            return _serde::export::Err(__err);
                        }
                    };
                    match _serde::ser::SerializeStruct::serialize_field(
                        &mut __serde_state,
                        "on_reboot",
                        &self.on_reboot,
                    ) {
                        _serde::export::Ok(__val) => __val,
                        _serde::export::Err(__err) => {
                            return _serde::export::Err(__err);
                        }
                    };
                    _serde::ser::SerializeStruct::end(__serde_state)
                }
            }
        };
        #[doc(hidden)]
        #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
        const _: () = {
            #[allow(rust_2018_idioms, clippy::useless_attribute)]
            extern crate serde as _serde;
            #[automatically_derived]
            impl<'de> _serde::Deserialize<'de> for on_reboot {
                fn deserialize<__D>(__deserializer: __D) -> _serde::export::Result<Self, __D::Error>
                where
                    __D: _serde::Deserializer<'de>,
                {
                    #[allow(non_camel_case_types)]
                    enum __Field {
                        __field0,
                        __ignore,
                    }
                    struct __FieldVisitor;
                    impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                        type Value = __Field;
                        fn expecting(
                            &self,
                            __formatter: &mut _serde::export::Formatter,
                        ) -> _serde::export::fmt::Result {
                            _serde::export::Formatter::write_str(__formatter, "field identifier")
                        }
                        fn visit_u64<__E>(
                            self,
                            __value: u64,
                        ) -> _serde::export::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                0u64 => _serde::export::Ok(__Field::__field0),
                                _ => _serde::export::Err(_serde::de::Error::invalid_value(
                                    _serde::de::Unexpected::Unsigned(__value),
                                    &"field index 0 <= i < 1",
                                )),
                            }
                        }
                        fn visit_str<__E>(
                            self,
                            __value: &str,
                        ) -> _serde::export::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                "on_reboot" => _serde::export::Ok(__Field::__field0),
                                _ => _serde::export::Ok(__Field::__ignore),
                            }
                        }
                        fn visit_bytes<__E>(
                            self,
                            __value: &[u8],
                        ) -> _serde::export::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                b"on_reboot" => _serde::export::Ok(__Field::__field0),
                                _ => _serde::export::Ok(__Field::__ignore),
                            }
                        }
                    }
                    impl<'de> _serde::Deserialize<'de> for __Field {
                        #[inline]
                        fn deserialize<__D>(
                            __deserializer: __D,
                        ) -> _serde::export::Result<Self, __D::Error>
                        where
                            __D: _serde::Deserializer<'de>,
                        {
                            _serde::Deserializer::deserialize_identifier(
                                __deserializer,
                                __FieldVisitor,
                            )
                        }
                    }
                    struct __Visitor<'de> {
                        marker: _serde::export::PhantomData<on_reboot>,
                        lifetime: _serde::export::PhantomData<&'de ()>,
                    }
                    impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                        type Value = on_reboot;
                        fn expecting(
                            &self,
                            __formatter: &mut _serde::export::Formatter,
                        ) -> _serde::export::fmt::Result {
                            _serde::export::Formatter::write_str(__formatter, "struct on_reboot")
                        }
                        #[inline]
                        fn visit_seq<__A>(
                            self,
                            mut __seq: __A,
                        ) -> _serde::export::Result<Self::Value, __A::Error>
                        where
                            __A: _serde::de::SeqAccess<'de>,
                        {
                            let __field0 = match match _serde::de::SeqAccess::next_element::<String>(
                                &mut __seq,
                            ) {
                                _serde::export::Ok(__val) => __val,
                                _serde::export::Err(__err) => {
                                    return _serde::export::Err(__err);
                                }
                            } {
                                _serde::export::Some(__value) => __value,
                                _serde::export::None => {
                                    return _serde::export::Err(_serde::de::Error::invalid_length(
                                        0usize,
                                        &"struct on_reboot with 1 element",
                                    ));
                                }
                            };
                            _serde::export::Ok(on_reboot {
                                on_reboot: __field0,
                            })
                        }
                        #[inline]
                        fn visit_map<__A>(
                            self,
                            mut __map: __A,
                        ) -> _serde::export::Result<Self::Value, __A::Error>
                        where
                            __A: _serde::de::MapAccess<'de>,
                        {
                            let mut __field0: _serde::export::Option<String> = _serde::export::None;
                            while let _serde::export::Some(__key) =
                                match _serde::de::MapAccess::next_key::<__Field>(&mut __map) {
                                    _serde::export::Ok(__val) => __val,
                                    _serde::export::Err(__err) => {
                                        return _serde::export::Err(__err);
                                    }
                                }
                            {
                                match __key {
                                    __Field::__field0 => {
                                        if _serde::export::Option::is_some(&__field0) {
                                            return _serde::export::Err(
                                                <__A::Error as _serde::de::Error>::duplicate_field(
                                                    "on_reboot",
                                                ),
                                            );
                                        }
                                        __field0 = _serde::export::Some(
                                            match _serde::de::MapAccess::next_value::<String>(
                                                &mut __map,
                                            ) {
                                                _serde::export::Ok(__val) => __val,
                                                _serde::export::Err(__err) => {
                                                    return _serde::export::Err(__err);
                                                }
                                            },
                                        );
                                    }
                                    _ => {
                                        let _ = match _serde::de::MapAccess::next_value::<
                                            _serde::de::IgnoredAny,
                                        >(
                                            &mut __map
                                        ) {
                                            _serde::export::Ok(__val) => __val,
                                            _serde::export::Err(__err) => {
                                                return _serde::export::Err(__err);
                                            }
                                        };
                                    }
                                }
                            }
                            let __field0 = match __field0 {
                                _serde::export::Some(__field0) => __field0,
                                _serde::export::None => {
                                    match _serde::private::de::missing_field("on_reboot") {
                                        _serde::export::Ok(__val) => __val,
                                        _serde::export::Err(__err) => {
                                            return _serde::export::Err(__err);
                                        }
                                    }
                                }
                            };
                            _serde::export::Ok(on_reboot {
                                on_reboot: __field0,
                            })
                        }
                    }
                    const FIELDS: &'static [&'static str] = &["on_reboot"];
                    _serde::Deserializer::deserialize_struct(
                        __deserializer,
                        "on_reboot",
                        FIELDS,
                        __Visitor {
                            marker: _serde::export::PhantomData::<on_reboot>,
                            lifetime: _serde::export::PhantomData,
                        },
                    )
                }
            }
        };
        impl on_reboot {
            pub fn new(name: String) -> Self {
                Self { on_reboot: name }
            }
        }
        #[xml(tag = "on_crash")]
        pub struct on_crash {
            #[xml(text)]
            on_crash: String,
        }
        impl strong_xml::XmlWrite for on_crash {
            fn to_writer<W: std::io::Write>(
                &self,
                mut writer: &mut strong_xml::XmlWriter<W>,
            ) -> strong_xml::XmlResult<()> {
                let on_crash {
                    on_crash: __self_on_crash,
                } = self;
                writer.write_element_start("on_crash")?;
                writer.write_element_end_open()?;
                let __value = &__self_on_crash;
                writer.write_text(&{
                    let res = ::alloc::fmt::format(::core::fmt::Arguments::new_v1(
                        &[""],
                        &match (&__value,) {
                            (arg0,) => [::core::fmt::ArgumentV1::new(
                                arg0,
                                ::core::fmt::Display::fmt,
                            )],
                        },
                    ));
                    res
                })?;
                writer.write_element_end_close("on_crash")?;
                Ok(())
            }
        }
        impl<'__input> strong_xml::XmlRead<'__input> for on_crash {
            fn from_reader(
                mut reader: &mut strong_xml::XmlReader<'__input>,
            ) -> strong_xml::XmlResult<Self> {
                use strong_xml::xmlparser::{ElementEnd, Token, Tokenizer};
                use strong_xml::XmlError;
                let __self_on_crash;
                reader.read_till_element_start("on_crash")?;
                while let Some((__key, __value)) = reader.find_attribute()? {
                    match __key {
                        key => {}
                    }
                }
                let __value = reader.read_text("on_crash")?;
                __self_on_crash = Some(
                    <String as std::str::FromStr>::from_str(&__value)
                        .map_err(|e| XmlError::FromStr(e.into()))?,
                );
                let __res = on_crash {
                    on_crash: __self_on_crash.ok_or(XmlError::MissingField {
                        name: "on_crash".to_owned(),
                        field: "on_crash".to_owned(),
                    })?,
                };
                return Ok(__res);
            }
        }
        impl ::core::marker::StructuralPartialEq for on_crash {}
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::cmp::PartialEq for on_crash {
            #[inline]
            fn eq(&self, other: &on_crash) -> bool {
                match *other {
                    on_crash {
                        on_crash: ref __self_1_0,
                    } => match *self {
                        on_crash {
                            on_crash: ref __self_0_0,
                        } => (*__self_0_0) == (*__self_1_0),
                    },
                }
            }
            #[inline]
            fn ne(&self, other: &on_crash) -> bool {
                match *other {
                    on_crash {
                        on_crash: ref __self_1_0,
                    } => match *self {
                        on_crash {
                            on_crash: ref __self_0_0,
                        } => (*__self_0_0) != (*__self_1_0),
                    },
                }
            }
        }
        impl ::core::marker::StructuralEq for on_crash {}
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::cmp::Eq for on_crash {
            #[inline]
            #[doc(hidden)]
            fn assert_receiver_is_total_eq(&self) -> () {
                {
                    let _: ::core::cmp::AssertParamIsEq<String>;
                }
            }
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::fmt::Debug for on_crash {
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                match *self {
                    on_crash {
                        on_crash: ref __self_0_0,
                    } => {
                        let mut debug_trait_builder = f.debug_struct("on_crash");
                        let _ = debug_trait_builder.field("on_crash", &&(*__self_0_0));
                        debug_trait_builder.finish()
                    }
                }
            }
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::clone::Clone for on_crash {
            #[inline]
            fn clone(&self) -> on_crash {
                match *self {
                    on_crash {
                        on_crash: ref __self_0_0,
                    } => on_crash {
                        on_crash: ::core::clone::Clone::clone(&(*__self_0_0)),
                    },
                }
            }
        }
        #[doc(hidden)]
        #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
        const _: () = {
            #[allow(rust_2018_idioms, clippy::useless_attribute)]
            extern crate serde as _serde;
            #[automatically_derived]
            impl _serde::Serialize for on_crash {
                fn serialize<__S>(
                    &self,
                    __serializer: __S,
                ) -> _serde::export::Result<__S::Ok, __S::Error>
                where
                    __S: _serde::Serializer,
                {
                    let mut __serde_state = match _serde::Serializer::serialize_struct(
                        __serializer,
                        "on_crash",
                        false as usize + 1,
                    ) {
                        _serde::export::Ok(__val) => __val,
                        _serde::export::Err(__err) => {
                            return _serde::export::Err(__err);
                        }
                    };
                    match _serde::ser::SerializeStruct::serialize_field(
                        &mut __serde_state,
                        "on_crash",
                        &self.on_crash,
                    ) {
                        _serde::export::Ok(__val) => __val,
                        _serde::export::Err(__err) => {
                            return _serde::export::Err(__err);
                        }
                    };
                    _serde::ser::SerializeStruct::end(__serde_state)
                }
            }
        };
        #[doc(hidden)]
        #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
        const _: () = {
            #[allow(rust_2018_idioms, clippy::useless_attribute)]
            extern crate serde as _serde;
            #[automatically_derived]
            impl<'de> _serde::Deserialize<'de> for on_crash {
                fn deserialize<__D>(__deserializer: __D) -> _serde::export::Result<Self, __D::Error>
                where
                    __D: _serde::Deserializer<'de>,
                {
                    #[allow(non_camel_case_types)]
                    enum __Field {
                        __field0,
                        __ignore,
                    }
                    struct __FieldVisitor;
                    impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                        type Value = __Field;
                        fn expecting(
                            &self,
                            __formatter: &mut _serde::export::Formatter,
                        ) -> _serde::export::fmt::Result {
                            _serde::export::Formatter::write_str(__formatter, "field identifier")
                        }
                        fn visit_u64<__E>(
                            self,
                            __value: u64,
                        ) -> _serde::export::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                0u64 => _serde::export::Ok(__Field::__field0),
                                _ => _serde::export::Err(_serde::de::Error::invalid_value(
                                    _serde::de::Unexpected::Unsigned(__value),
                                    &"field index 0 <= i < 1",
                                )),
                            }
                        }
                        fn visit_str<__E>(
                            self,
                            __value: &str,
                        ) -> _serde::export::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                "on_crash" => _serde::export::Ok(__Field::__field0),
                                _ => _serde::export::Ok(__Field::__ignore),
                            }
                        }
                        fn visit_bytes<__E>(
                            self,
                            __value: &[u8],
                        ) -> _serde::export::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                b"on_crash" => _serde::export::Ok(__Field::__field0),
                                _ => _serde::export::Ok(__Field::__ignore),
                            }
                        }
                    }
                    impl<'de> _serde::Deserialize<'de> for __Field {
                        #[inline]
                        fn deserialize<__D>(
                            __deserializer: __D,
                        ) -> _serde::export::Result<Self, __D::Error>
                        where
                            __D: _serde::Deserializer<'de>,
                        {
                            _serde::Deserializer::deserialize_identifier(
                                __deserializer,
                                __FieldVisitor,
                            )
                        }
                    }
                    struct __Visitor<'de> {
                        marker: _serde::export::PhantomData<on_crash>,
                        lifetime: _serde::export::PhantomData<&'de ()>,
                    }
                    impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                        type Value = on_crash;
                        fn expecting(
                            &self,
                            __formatter: &mut _serde::export::Formatter,
                        ) -> _serde::export::fmt::Result {
                            _serde::export::Formatter::write_str(__formatter, "struct on_crash")
                        }
                        #[inline]
                        fn visit_seq<__A>(
                            self,
                            mut __seq: __A,
                        ) -> _serde::export::Result<Self::Value, __A::Error>
                        where
                            __A: _serde::de::SeqAccess<'de>,
                        {
                            let __field0 = match match _serde::de::SeqAccess::next_element::<String>(
                                &mut __seq,
                            ) {
                                _serde::export::Ok(__val) => __val,
                                _serde::export::Err(__err) => {
                                    return _serde::export::Err(__err);
                                }
                            } {
                                _serde::export::Some(__value) => __value,
                                _serde::export::None => {
                                    return _serde::export::Err(_serde::de::Error::invalid_length(
                                        0usize,
                                        &"struct on_crash with 1 element",
                                    ));
                                }
                            };
                            _serde::export::Ok(on_crash { on_crash: __field0 })
                        }
                        #[inline]
                        fn visit_map<__A>(
                            self,
                            mut __map: __A,
                        ) -> _serde::export::Result<Self::Value, __A::Error>
                        where
                            __A: _serde::de::MapAccess<'de>,
                        {
                            let mut __field0: _serde::export::Option<String> = _serde::export::None;
                            while let _serde::export::Some(__key) =
                                match _serde::de::MapAccess::next_key::<__Field>(&mut __map) {
                                    _serde::export::Ok(__val) => __val,
                                    _serde::export::Err(__err) => {
                                        return _serde::export::Err(__err);
                                    }
                                }
                            {
                                match __key {
                                    __Field::__field0 => {
                                        if _serde::export::Option::is_some(&__field0) {
                                            return _serde::export::Err(
                                                <__A::Error as _serde::de::Error>::duplicate_field(
                                                    "on_crash",
                                                ),
                                            );
                                        }
                                        __field0 = _serde::export::Some(
                                            match _serde::de::MapAccess::next_value::<String>(
                                                &mut __map,
                                            ) {
                                                _serde::export::Ok(__val) => __val,
                                                _serde::export::Err(__err) => {
                                                    return _serde::export::Err(__err);
                                                }
                                            },
                                        );
                                    }
                                    _ => {
                                        let _ = match _serde::de::MapAccess::next_value::<
                                            _serde::de::IgnoredAny,
                                        >(
                                            &mut __map
                                        ) {
                                            _serde::export::Ok(__val) => __val,
                                            _serde::export::Err(__err) => {
                                                return _serde::export::Err(__err);
                                            }
                                        };
                                    }
                                }
                            }
                            let __field0 = match __field0 {
                                _serde::export::Some(__field0) => __field0,
                                _serde::export::None => {
                                    match _serde::private::de::missing_field("on_crash") {
                                        _serde::export::Ok(__val) => __val,
                                        _serde::export::Err(__err) => {
                                            return _serde::export::Err(__err);
                                        }
                                    }
                                }
                            };
                            _serde::export::Ok(on_crash { on_crash: __field0 })
                        }
                    }
                    const FIELDS: &'static [&'static str] = &["on_crash"];
                    _serde::Deserializer::deserialize_struct(
                        __deserializer,
                        "on_crash",
                        FIELDS,
                        __Visitor {
                            marker: _serde::export::PhantomData::<on_crash>,
                            lifetime: _serde::export::PhantomData,
                        },
                    )
                }
            }
        };
        impl on_crash {
            pub fn new(name: String) -> Self {
                Self { on_crash: name }
            }
        }
        impl Default for on_poweroff {
            fn default() -> Self {
                Self {
                    on_poweroff: String::from("destroy"),
                }
            }
        }
        impl Default for on_reboot {
            fn default() -> Self {
                Self {
                    on_reboot: String::from("restart"),
                }
            }
        }
        impl Default for on_crash {
            fn default() -> Self {
                Self {
                    on_crash: String::from("destroy"),
                }
            }
        }
        #[xml(tag = "readonly")]
        pub struct readonly {}
        impl strong_xml::XmlWrite for readonly {
            fn to_writer<W: std::io::Write>(
                &self,
                mut writer: &mut strong_xml::XmlWriter<W>,
            ) -> strong_xml::XmlResult<()> {
                let readonly {} = self;
                writer.write_element_start("readonly")?;
                writer.write_element_end_empty()?;
                Ok(())
            }
        }
        impl<'__input> strong_xml::XmlRead<'__input> for readonly {
            fn from_reader(
                mut reader: &mut strong_xml::XmlReader<'__input>,
            ) -> strong_xml::XmlResult<Self> {
                use strong_xml::xmlparser::{ElementEnd, Token, Tokenizer};
                use strong_xml::XmlError;
                reader.read_till_element_start("readonly")?;
                while let Some((__key, __value)) = reader.find_attribute()? {
                    match __key {
                        key => {}
                    }
                }
                if let Token::ElementEnd {
                    end: ElementEnd::Empty,
                    ..
                } = reader.next().unwrap()?
                {
                    let __res = readonly {};
                    return Ok(__res);
                }
                while let Some(__tag) = reader.find_element_start(Some("readonly"))? {
                    match __tag {
                        tag => {
                            reader.next();
                            reader.read_to_end(tag)?;
                        }
                    }
                }
                let __res = readonly {};
                return Ok(__res);
            }
        }
        impl ::core::marker::StructuralPartialEq for readonly {}
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::cmp::PartialEq for readonly {
            #[inline]
            fn eq(&self, other: &readonly) -> bool {
                match *other {
                    readonly {} => match *self {
                        readonly {} => true,
                    },
                }
            }
        }
        impl ::core::marker::StructuralEq for readonly {}
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::cmp::Eq for readonly {
            #[inline]
            #[doc(hidden)]
            fn assert_receiver_is_total_eq(&self) -> () {
                {}
            }
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::fmt::Debug for readonly {
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                match *self {
                    readonly {} => {
                        let mut debug_trait_builder = f.debug_struct("readonly");
                        debug_trait_builder.finish()
                    }
                }
            }
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::clone::Clone for readonly {
            #[inline]
            fn clone(&self) -> readonly {
                match *self {
                    readonly {} => readonly {},
                }
            }
        }
        #[doc(hidden)]
        #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
        const _: () = {
            #[allow(rust_2018_idioms, clippy::useless_attribute)]
            extern crate serde as _serde;
            #[automatically_derived]
            impl _serde::Serialize for readonly {
                fn serialize<__S>(
                    &self,
                    __serializer: __S,
                ) -> _serde::export::Result<__S::Ok, __S::Error>
                where
                    __S: _serde::Serializer,
                {
                    let __serde_state = match _serde::Serializer::serialize_struct(
                        __serializer,
                        "readonly",
                        false as usize,
                    ) {
                        _serde::export::Ok(__val) => __val,
                        _serde::export::Err(__err) => {
                            return _serde::export::Err(__err);
                        }
                    };
                    _serde::ser::SerializeStruct::end(__serde_state)
                }
            }
        };
        #[doc(hidden)]
        #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
        const _: () = {
            #[allow(rust_2018_idioms, clippy::useless_attribute)]
            extern crate serde as _serde;
            #[automatically_derived]
            impl<'de> _serde::Deserialize<'de> for readonly {
                fn deserialize<__D>(__deserializer: __D) -> _serde::export::Result<Self, __D::Error>
                where
                    __D: _serde::Deserializer<'de>,
                {
                    #[allow(non_camel_case_types)]
                    enum __Field {
                        __ignore,
                    }
                    struct __FieldVisitor;
                    impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                        type Value = __Field;
                        fn expecting(
                            &self,
                            __formatter: &mut _serde::export::Formatter,
                        ) -> _serde::export::fmt::Result {
                            _serde::export::Formatter::write_str(__formatter, "field identifier")
                        }
                        fn visit_u64<__E>(
                            self,
                            __value: u64,
                        ) -> _serde::export::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                _ => _serde::export::Err(_serde::de::Error::invalid_value(
                                    _serde::de::Unexpected::Unsigned(__value),
                                    &"field index 0 <= i < 0",
                                )),
                            }
                        }
                        fn visit_str<__E>(
                            self,
                            __value: &str,
                        ) -> _serde::export::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                _ => _serde::export::Ok(__Field::__ignore),
                            }
                        }
                        fn visit_bytes<__E>(
                            self,
                            __value: &[u8],
                        ) -> _serde::export::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                _ => _serde::export::Ok(__Field::__ignore),
                            }
                        }
                    }
                    impl<'de> _serde::Deserialize<'de> for __Field {
                        #[inline]
                        fn deserialize<__D>(
                            __deserializer: __D,
                        ) -> _serde::export::Result<Self, __D::Error>
                        where
                            __D: _serde::Deserializer<'de>,
                        {
                            _serde::Deserializer::deserialize_identifier(
                                __deserializer,
                                __FieldVisitor,
                            )
                        }
                    }
                    struct __Visitor<'de> {
                        marker: _serde::export::PhantomData<readonly>,
                        lifetime: _serde::export::PhantomData<&'de ()>,
                    }
                    impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                        type Value = readonly;
                        fn expecting(
                            &self,
                            __formatter: &mut _serde::export::Formatter,
                        ) -> _serde::export::fmt::Result {
                            _serde::export::Formatter::write_str(__formatter, "struct readonly")
                        }
                        #[inline]
                        fn visit_seq<__A>(
                            self,
                            _: __A,
                        ) -> _serde::export::Result<Self::Value, __A::Error>
                        where
                            __A: _serde::de::SeqAccess<'de>,
                        {
                            _serde::export::Ok(readonly {})
                        }
                        #[inline]
                        fn visit_map<__A>(
                            self,
                            mut __map: __A,
                        ) -> _serde::export::Result<Self::Value, __A::Error>
                        where
                            __A: _serde::de::MapAccess<'de>,
                        {
                            while let _serde::export::Some(__key) =
                                match _serde::de::MapAccess::next_key::<__Field>(&mut __map) {
                                    _serde::export::Ok(__val) => __val,
                                    _serde::export::Err(__err) => {
                                        return _serde::export::Err(__err);
                                    }
                                }
                            {
                                match __key {
                                    _ => {
                                        let _ = match _serde::de::MapAccess::next_value::<
                                            _serde::de::IgnoredAny,
                                        >(
                                            &mut __map
                                        ) {
                                            _serde::export::Ok(__val) => __val,
                                            _serde::export::Err(__err) => {
                                                return _serde::export::Err(__err);
                                            }
                                        };
                                    }
                                }
                            }
                            _serde::export::Ok(readonly {})
                        }
                    }
                    const FIELDS: &'static [&'static str] = &[];
                    _serde::Deserializer::deserialize_struct(
                        __deserializer,
                        "readonly",
                        FIELDS,
                        __Visitor {
                            marker: _serde::export::PhantomData::<readonly>,
                            lifetime: _serde::export::PhantomData,
                        },
                    )
                }
            }
        };
        impl Default for readonly {
            fn default() -> Self {
                Self {}
            }
        }
        #[xml(tag = "acpi")]
        pub struct acpi {}
        impl strong_xml::XmlWrite for acpi {
            fn to_writer<W: std::io::Write>(
                &self,
                mut writer: &mut strong_xml::XmlWriter<W>,
            ) -> strong_xml::XmlResult<()> {
                let acpi {} = self;
                writer.write_element_start("acpi")?;
                writer.write_element_end_empty()?;
                Ok(())
            }
        }
        impl<'__input> strong_xml::XmlRead<'__input> for acpi {
            fn from_reader(
                mut reader: &mut strong_xml::XmlReader<'__input>,
            ) -> strong_xml::XmlResult<Self> {
                use strong_xml::xmlparser::{ElementEnd, Token, Tokenizer};
                use strong_xml::XmlError;
                reader.read_till_element_start("acpi")?;
                while let Some((__key, __value)) = reader.find_attribute()? {
                    match __key {
                        key => {}
                    }
                }
                if let Token::ElementEnd {
                    end: ElementEnd::Empty,
                    ..
                } = reader.next().unwrap()?
                {
                    let __res = acpi {};
                    return Ok(__res);
                }
                while let Some(__tag) = reader.find_element_start(Some("acpi"))? {
                    match __tag {
                        tag => {
                            reader.next();
                            reader.read_to_end(tag)?;
                        }
                    }
                }
                let __res = acpi {};
                return Ok(__res);
            }
        }
        impl ::core::marker::StructuralPartialEq for acpi {}
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::cmp::PartialEq for acpi {
            #[inline]
            fn eq(&self, other: &acpi) -> bool {
                match *other {
                    acpi {} => match *self {
                        acpi {} => true,
                    },
                }
            }
        }
        impl ::core::marker::StructuralEq for acpi {}
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::cmp::Eq for acpi {
            #[inline]
            #[doc(hidden)]
            fn assert_receiver_is_total_eq(&self) -> () {
                {}
            }
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::fmt::Debug for acpi {
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                match *self {
                    acpi {} => {
                        let mut debug_trait_builder = f.debug_struct("acpi");
                        debug_trait_builder.finish()
                    }
                }
            }
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::clone::Clone for acpi {
            #[inline]
            fn clone(&self) -> acpi {
                match *self {
                    acpi {} => acpi {},
                }
            }
        }
        #[doc(hidden)]
        #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
        const _: () = {
            #[allow(rust_2018_idioms, clippy::useless_attribute)]
            extern crate serde as _serde;
            #[automatically_derived]
            impl _serde::Serialize for acpi {
                fn serialize<__S>(
                    &self,
                    __serializer: __S,
                ) -> _serde::export::Result<__S::Ok, __S::Error>
                where
                    __S: _serde::Serializer,
                {
                    let __serde_state = match _serde::Serializer::serialize_struct(
                        __serializer,
                        "acpi",
                        false as usize,
                    ) {
                        _serde::export::Ok(__val) => __val,
                        _serde::export::Err(__err) => {
                            return _serde::export::Err(__err);
                        }
                    };
                    _serde::ser::SerializeStruct::end(__serde_state)
                }
            }
        };
        #[doc(hidden)]
        #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
        const _: () = {
            #[allow(rust_2018_idioms, clippy::useless_attribute)]
            extern crate serde as _serde;
            #[automatically_derived]
            impl<'de> _serde::Deserialize<'de> for acpi {
                fn deserialize<__D>(__deserializer: __D) -> _serde::export::Result<Self, __D::Error>
                where
                    __D: _serde::Deserializer<'de>,
                {
                    #[allow(non_camel_case_types)]
                    enum __Field {
                        __ignore,
                    }
                    struct __FieldVisitor;
                    impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                        type Value = __Field;
                        fn expecting(
                            &self,
                            __formatter: &mut _serde::export::Formatter,
                        ) -> _serde::export::fmt::Result {
                            _serde::export::Formatter::write_str(__formatter, "field identifier")
                        }
                        fn visit_u64<__E>(
                            self,
                            __value: u64,
                        ) -> _serde::export::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                _ => _serde::export::Err(_serde::de::Error::invalid_value(
                                    _serde::de::Unexpected::Unsigned(__value),
                                    &"field index 0 <= i < 0",
                                )),
                            }
                        }
                        fn visit_str<__E>(
                            self,
                            __value: &str,
                        ) -> _serde::export::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                _ => _serde::export::Ok(__Field::__ignore),
                            }
                        }
                        fn visit_bytes<__E>(
                            self,
                            __value: &[u8],
                        ) -> _serde::export::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                _ => _serde::export::Ok(__Field::__ignore),
                            }
                        }
                    }
                    impl<'de> _serde::Deserialize<'de> for __Field {
                        #[inline]
                        fn deserialize<__D>(
                            __deserializer: __D,
                        ) -> _serde::export::Result<Self, __D::Error>
                        where
                            __D: _serde::Deserializer<'de>,
                        {
                            _serde::Deserializer::deserialize_identifier(
                                __deserializer,
                                __FieldVisitor,
                            )
                        }
                    }
                    struct __Visitor<'de> {
                        marker: _serde::export::PhantomData<acpi>,
                        lifetime: _serde::export::PhantomData<&'de ()>,
                    }
                    impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                        type Value = acpi;
                        fn expecting(
                            &self,
                            __formatter: &mut _serde::export::Formatter,
                        ) -> _serde::export::fmt::Result {
                            _serde::export::Formatter::write_str(__formatter, "struct acpi")
                        }
                        #[inline]
                        fn visit_seq<__A>(
                            self,
                            _: __A,
                        ) -> _serde::export::Result<Self::Value, __A::Error>
                        where
                            __A: _serde::de::SeqAccess<'de>,
                        {
                            _serde::export::Ok(acpi {})
                        }
                        #[inline]
                        fn visit_map<__A>(
                            self,
                            mut __map: __A,
                        ) -> _serde::export::Result<Self::Value, __A::Error>
                        where
                            __A: _serde::de::MapAccess<'de>,
                        {
                            while let _serde::export::Some(__key) =
                                match _serde::de::MapAccess::next_key::<__Field>(&mut __map) {
                                    _serde::export::Ok(__val) => __val,
                                    _serde::export::Err(__err) => {
                                        return _serde::export::Err(__err);
                                    }
                                }
                            {
                                match __key {
                                    _ => {
                                        let _ = match _serde::de::MapAccess::next_value::<
                                            _serde::de::IgnoredAny,
                                        >(
                                            &mut __map
                                        ) {
                                            _serde::export::Ok(__val) => __val,
                                            _serde::export::Err(__err) => {
                                                return _serde::export::Err(__err);
                                            }
                                        };
                                    }
                                }
                            }
                            _serde::export::Ok(acpi {})
                        }
                    }
                    const FIELDS: &'static [&'static str] = &[];
                    _serde::Deserializer::deserialize_struct(
                        __deserializer,
                        "acpi",
                        FIELDS,
                        __Visitor {
                            marker: _serde::export::PhantomData::<acpi>,
                            lifetime: _serde::export::PhantomData,
                        },
                    )
                }
            }
        };
        impl Default for acpi {
            fn default() -> Self {
                Self {}
            }
        }
        #[xml(tag = "apic")]
        pub struct apic {}
        impl strong_xml::XmlWrite for apic {
            fn to_writer<W: std::io::Write>(
                &self,
                mut writer: &mut strong_xml::XmlWriter<W>,
            ) -> strong_xml::XmlResult<()> {
                let apic {} = self;
                writer.write_element_start("apic")?;
                writer.write_element_end_empty()?;
                Ok(())
            }
        }
        impl<'__input> strong_xml::XmlRead<'__input> for apic {
            fn from_reader(
                mut reader: &mut strong_xml::XmlReader<'__input>,
            ) -> strong_xml::XmlResult<Self> {
                use strong_xml::xmlparser::{ElementEnd, Token, Tokenizer};
                use strong_xml::XmlError;
                reader.read_till_element_start("apic")?;
                while let Some((__key, __value)) = reader.find_attribute()? {
                    match __key {
                        key => {}
                    }
                }
                if let Token::ElementEnd {
                    end: ElementEnd::Empty,
                    ..
                } = reader.next().unwrap()?
                {
                    let __res = apic {};
                    return Ok(__res);
                }
                while let Some(__tag) = reader.find_element_start(Some("apic"))? {
                    match __tag {
                        tag => {
                            reader.next();
                            reader.read_to_end(tag)?;
                        }
                    }
                }
                let __res = apic {};
                return Ok(__res);
            }
        }
        impl ::core::marker::StructuralPartialEq for apic {}
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::cmp::PartialEq for apic {
            #[inline]
            fn eq(&self, other: &apic) -> bool {
                match *other {
                    apic {} => match *self {
                        apic {} => true,
                    },
                }
            }
        }
        impl ::core::marker::StructuralEq for apic {}
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::cmp::Eq for apic {
            #[inline]
            #[doc(hidden)]
            fn assert_receiver_is_total_eq(&self) -> () {
                {}
            }
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::fmt::Debug for apic {
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                match *self {
                    apic {} => {
                        let mut debug_trait_builder = f.debug_struct("apic");
                        debug_trait_builder.finish()
                    }
                }
            }
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::clone::Clone for apic {
            #[inline]
            fn clone(&self) -> apic {
                match *self {
                    apic {} => apic {},
                }
            }
        }
        #[doc(hidden)]
        #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
        const _: () = {
            #[allow(rust_2018_idioms, clippy::useless_attribute)]
            extern crate serde as _serde;
            #[automatically_derived]
            impl _serde::Serialize for apic {
                fn serialize<__S>(
                    &self,
                    __serializer: __S,
                ) -> _serde::export::Result<__S::Ok, __S::Error>
                where
                    __S: _serde::Serializer,
                {
                    let __serde_state = match _serde::Serializer::serialize_struct(
                        __serializer,
                        "apic",
                        false as usize,
                    ) {
                        _serde::export::Ok(__val) => __val,
                        _serde::export::Err(__err) => {
                            return _serde::export::Err(__err);
                        }
                    };
                    _serde::ser::SerializeStruct::end(__serde_state)
                }
            }
        };
        #[doc(hidden)]
        #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
        const _: () = {
            #[allow(rust_2018_idioms, clippy::useless_attribute)]
            extern crate serde as _serde;
            #[automatically_derived]
            impl<'de> _serde::Deserialize<'de> for apic {
                fn deserialize<__D>(__deserializer: __D) -> _serde::export::Result<Self, __D::Error>
                where
                    __D: _serde::Deserializer<'de>,
                {
                    #[allow(non_camel_case_types)]
                    enum __Field {
                        __ignore,
                    }
                    struct __FieldVisitor;
                    impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                        type Value = __Field;
                        fn expecting(
                            &self,
                            __formatter: &mut _serde::export::Formatter,
                        ) -> _serde::export::fmt::Result {
                            _serde::export::Formatter::write_str(__formatter, "field identifier")
                        }
                        fn visit_u64<__E>(
                            self,
                            __value: u64,
                        ) -> _serde::export::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                _ => _serde::export::Err(_serde::de::Error::invalid_value(
                                    _serde::de::Unexpected::Unsigned(__value),
                                    &"field index 0 <= i < 0",
                                )),
                            }
                        }
                        fn visit_str<__E>(
                            self,
                            __value: &str,
                        ) -> _serde::export::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                _ => _serde::export::Ok(__Field::__ignore),
                            }
                        }
                        fn visit_bytes<__E>(
                            self,
                            __value: &[u8],
                        ) -> _serde::export::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                _ => _serde::export::Ok(__Field::__ignore),
                            }
                        }
                    }
                    impl<'de> _serde::Deserialize<'de> for __Field {
                        #[inline]
                        fn deserialize<__D>(
                            __deserializer: __D,
                        ) -> _serde::export::Result<Self, __D::Error>
                        where
                            __D: _serde::Deserializer<'de>,
                        {
                            _serde::Deserializer::deserialize_identifier(
                                __deserializer,
                                __FieldVisitor,
                            )
                        }
                    }
                    struct __Visitor<'de> {
                        marker: _serde::export::PhantomData<apic>,
                        lifetime: _serde::export::PhantomData<&'de ()>,
                    }
                    impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                        type Value = apic;
                        fn expecting(
                            &self,
                            __formatter: &mut _serde::export::Formatter,
                        ) -> _serde::export::fmt::Result {
                            _serde::export::Formatter::write_str(__formatter, "struct apic")
                        }
                        #[inline]
                        fn visit_seq<__A>(
                            self,
                            _: __A,
                        ) -> _serde::export::Result<Self::Value, __A::Error>
                        where
                            __A: _serde::de::SeqAccess<'de>,
                        {
                            _serde::export::Ok(apic {})
                        }
                        #[inline]
                        fn visit_map<__A>(
                            self,
                            mut __map: __A,
                        ) -> _serde::export::Result<Self::Value, __A::Error>
                        where
                            __A: _serde::de::MapAccess<'de>,
                        {
                            while let _serde::export::Some(__key) =
                                match _serde::de::MapAccess::next_key::<__Field>(&mut __map) {
                                    _serde::export::Ok(__val) => __val,
                                    _serde::export::Err(__err) => {
                                        return _serde::export::Err(__err);
                                    }
                                }
                            {
                                match __key {
                                    _ => {
                                        let _ = match _serde::de::MapAccess::next_value::<
                                            _serde::de::IgnoredAny,
                                        >(
                                            &mut __map
                                        ) {
                                            _serde::export::Ok(__val) => __val,
                                            _serde::export::Err(__err) => {
                                                return _serde::export::Err(__err);
                                            }
                                        };
                                    }
                                }
                            }
                            _serde::export::Ok(apic {})
                        }
                    }
                    const FIELDS: &'static [&'static str] = &[];
                    _serde::Deserializer::deserialize_struct(
                        __deserializer,
                        "apic",
                        FIELDS,
                        __Visitor {
                            marker: _serde::export::PhantomData::<apic>,
                            lifetime: _serde::export::PhantomData,
                        },
                    )
                }
            }
        };
        impl Default for apic {
            fn default() -> Self {
                Self {}
            }
        }
        #[xml(tag = "type")]
        pub struct r#type {
            #[xml(attr = "arch")]
            pub arch: Option<String>,
            #[xml(attr = "machine")]
            pub machine: Option<String>,
            #[xml(text)]
            text: String,
        }
        impl<'__input> strong_xml::XmlRead<'__input> for r#type {
            fn from_reader(
                mut reader: &mut strong_xml::XmlReader<'__input>,
            ) -> strong_xml::XmlResult<Self> {
                use strong_xml::xmlparser::{ElementEnd, Token, Tokenizer};
                use strong_xml::XmlError;
                let mut __self_arch = None;
                let mut __self_machine = None;
                let __self_text;
                reader.read_till_element_start("type")?;
                while let Some((__key, __value)) = reader.find_attribute()? {
                    match __key {
                        "arch" => {
                            __self_arch = Some(
                                <String as std::str::FromStr>::from_str(&__value)
                                    .map_err(|e| XmlError::FromStr(e.into()))?,
                            );
                        }
                        "machine" => {
                            __self_machine = Some(
                                <String as std::str::FromStr>::from_str(&__value)
                                    .map_err(|e| XmlError::FromStr(e.into()))?,
                            );
                        }
                        key => {}
                    }
                }
                let __value = reader.read_text("type")?;
                __self_text = Some(
                    <String as std::str::FromStr>::from_str(&__value)
                        .map_err(|e| XmlError::FromStr(e.into()))?,
                );
                let __res = r#type {
                    arch: __self_arch,
                    machine: __self_machine,
                    text: __self_text.ok_or(XmlError::MissingField {
                        name: "r#type".to_owned(),
                        field: "text".to_owned(),
                    })?,
                };
                return Ok(__res);
            }
        }
        impl strong_xml::XmlWrite for r#type {
            fn to_writer<W: std::io::Write>(
                &self,
                mut writer: &mut strong_xml::XmlWriter<W>,
            ) -> strong_xml::XmlResult<()> {
                let r#type {
                    arch: __self_arch,
                    machine: __self_machine,
                    text: __self_text,
                } = self;
                writer.write_element_start("type")?;
                if let Some(__value) = __self_arch {
                    writer.write_attribute("arch", &{
                        let res = ::alloc::fmt::format(::core::fmt::Arguments::new_v1(
                            &[""],
                            &match (&__value,) {
                                (arg0,) => [::core::fmt::ArgumentV1::new(
                                    arg0,
                                    ::core::fmt::Display::fmt,
                                )],
                            },
                        ));
                        res
                    })?;
                }
                if let Some(__value) = __self_machine {
                    writer.write_attribute("machine", &{
                        let res = ::alloc::fmt::format(::core::fmt::Arguments::new_v1(
                            &[""],
                            &match (&__value,) {
                                (arg0,) => [::core::fmt::ArgumentV1::new(
                                    arg0,
                                    ::core::fmt::Display::fmt,
                                )],
                            },
                        ));
                        res
                    })?;
                }
                writer.write_element_end_open()?;
                let __value = &__self_text;
                writer.write_text(&{
                    let res = ::alloc::fmt::format(::core::fmt::Arguments::new_v1(
                        &[""],
                        &match (&__value,) {
                            (arg0,) => [::core::fmt::ArgumentV1::new(
                                arg0,
                                ::core::fmt::Display::fmt,
                            )],
                        },
                    ));
                    res
                })?;
                writer.write_element_end_close("type")?;
                Ok(())
            }
        }
        impl ::core::marker::StructuralPartialEq for r#type {}
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::cmp::PartialEq for r#type {
            #[inline]
            fn eq(&self, other: &r#type) -> bool {
                match *other {
                    r#type {
                        arch: ref __self_1_0,
                        machine: ref __self_1_1,
                        text: ref __self_1_2,
                    } => match *self {
                        r#type {
                            arch: ref __self_0_0,
                            machine: ref __self_0_1,
                            text: ref __self_0_2,
                        } => {
                            (*__self_0_0) == (*__self_1_0)
                                && (*__self_0_1) == (*__self_1_1)
                                && (*__self_0_2) == (*__self_1_2)
                        }
                    },
                }
            }
            #[inline]
            fn ne(&self, other: &r#type) -> bool {
                match *other {
                    r#type {
                        arch: ref __self_1_0,
                        machine: ref __self_1_1,
                        text: ref __self_1_2,
                    } => match *self {
                        r#type {
                            arch: ref __self_0_0,
                            machine: ref __self_0_1,
                            text: ref __self_0_2,
                        } => {
                            (*__self_0_0) != (*__self_1_0)
                                || (*__self_0_1) != (*__self_1_1)
                                || (*__self_0_2) != (*__self_1_2)
                        }
                    },
                }
            }
        }
        impl ::core::marker::StructuralEq for r#type {}
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::cmp::Eq for r#type {
            #[inline]
            #[doc(hidden)]
            fn assert_receiver_is_total_eq(&self) -> () {
                {
                    let _: ::core::cmp::AssertParamIsEq<Option<String>>;
                    let _: ::core::cmp::AssertParamIsEq<Option<String>>;
                    let _: ::core::cmp::AssertParamIsEq<String>;
                }
            }
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::fmt::Debug for r#type {
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                match *self {
                    r#type {
                        arch: ref __self_0_0,
                        machine: ref __self_0_1,
                        text: ref __self_0_2,
                    } => {
                        let mut debug_trait_builder = f.debug_struct("type");
                        let _ = debug_trait_builder.field("arch", &&(*__self_0_0));
                        let _ = debug_trait_builder.field("machine", &&(*__self_0_1));
                        let _ = debug_trait_builder.field("text", &&(*__self_0_2));
                        debug_trait_builder.finish()
                    }
                }
            }
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::clone::Clone for r#type {
            #[inline]
            fn clone(&self) -> r#type {
                match *self {
                    r#type {
                        arch: ref __self_0_0,
                        machine: ref __self_0_1,
                        text: ref __self_0_2,
                    } => r#type {
                        arch: ::core::clone::Clone::clone(&(*__self_0_0)),
                        machine: ::core::clone::Clone::clone(&(*__self_0_1)),
                        text: ::core::clone::Clone::clone(&(*__self_0_2)),
                    },
                }
            }
        }
        #[doc(hidden)]
        #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
        const _: () = {
            #[allow(rust_2018_idioms, clippy::useless_attribute)]
            extern crate serde as _serde;
            #[automatically_derived]
            impl _serde::Serialize for r#type {
                fn serialize<__S>(
                    &self,
                    __serializer: __S,
                ) -> _serde::export::Result<__S::Ok, __S::Error>
                where
                    __S: _serde::Serializer,
                {
                    let mut __serde_state = match _serde::Serializer::serialize_struct(
                        __serializer,
                        "type",
                        false as usize + 1 + 1 + 1,
                    ) {
                        _serde::export::Ok(__val) => __val,
                        _serde::export::Err(__err) => {
                            return _serde::export::Err(__err);
                        }
                    };
                    match _serde::ser::SerializeStruct::serialize_field(
                        &mut __serde_state,
                        "arch",
                        &self.arch,
                    ) {
                        _serde::export::Ok(__val) => __val,
                        _serde::export::Err(__err) => {
                            return _serde::export::Err(__err);
                        }
                    };
                    match _serde::ser::SerializeStruct::serialize_field(
                        &mut __serde_state,
                        "machine",
                        &self.machine,
                    ) {
                        _serde::export::Ok(__val) => __val,
                        _serde::export::Err(__err) => {
                            return _serde::export::Err(__err);
                        }
                    };
                    match _serde::ser::SerializeStruct::serialize_field(
                        &mut __serde_state,
                        "text",
                        &self.text,
                    ) {
                        _serde::export::Ok(__val) => __val,
                        _serde::export::Err(__err) => {
                            return _serde::export::Err(__err);
                        }
                    };
                    _serde::ser::SerializeStruct::end(__serde_state)
                }
            }
        };
        #[doc(hidden)]
        #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
        const _: () = {
            #[allow(rust_2018_idioms, clippy::useless_attribute)]
            extern crate serde as _serde;
            #[automatically_derived]
            impl<'de> _serde::Deserialize<'de> for r#type {
                fn deserialize<__D>(__deserializer: __D) -> _serde::export::Result<Self, __D::Error>
                where
                    __D: _serde::Deserializer<'de>,
                {
                    #[allow(non_camel_case_types)]
                    enum __Field {
                        __field0,
                        __field1,
                        __field2,
                        __ignore,
                    }
                    struct __FieldVisitor;
                    impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                        type Value = __Field;
                        fn expecting(
                            &self,
                            __formatter: &mut _serde::export::Formatter,
                        ) -> _serde::export::fmt::Result {
                            _serde::export::Formatter::write_str(__formatter, "field identifier")
                        }
                        fn visit_u64<__E>(
                            self,
                            __value: u64,
                        ) -> _serde::export::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                0u64 => _serde::export::Ok(__Field::__field0),
                                1u64 => _serde::export::Ok(__Field::__field1),
                                2u64 => _serde::export::Ok(__Field::__field2),
                                _ => _serde::export::Err(_serde::de::Error::invalid_value(
                                    _serde::de::Unexpected::Unsigned(__value),
                                    &"field index 0 <= i < 3",
                                )),
                            }
                        }
                        fn visit_str<__E>(
                            self,
                            __value: &str,
                        ) -> _serde::export::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                "arch" => _serde::export::Ok(__Field::__field0),
                                "machine" => _serde::export::Ok(__Field::__field1),
                                "text" => _serde::export::Ok(__Field::__field2),
                                _ => _serde::export::Ok(__Field::__ignore),
                            }
                        }
                        fn visit_bytes<__E>(
                            self,
                            __value: &[u8],
                        ) -> _serde::export::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                b"arch" => _serde::export::Ok(__Field::__field0),
                                b"machine" => _serde::export::Ok(__Field::__field1),
                                b"text" => _serde::export::Ok(__Field::__field2),
                                _ => _serde::export::Ok(__Field::__ignore),
                            }
                        }
                    }
                    impl<'de> _serde::Deserialize<'de> for __Field {
                        #[inline]
                        fn deserialize<__D>(
                            __deserializer: __D,
                        ) -> _serde::export::Result<Self, __D::Error>
                        where
                            __D: _serde::Deserializer<'de>,
                        {
                            _serde::Deserializer::deserialize_identifier(
                                __deserializer,
                                __FieldVisitor,
                            )
                        }
                    }
                    struct __Visitor<'de> {
                        marker: _serde::export::PhantomData<r#type>,
                        lifetime: _serde::export::PhantomData<&'de ()>,
                    }
                    impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                        type Value = r#type;
                        fn expecting(
                            &self,
                            __formatter: &mut _serde::export::Formatter,
                        ) -> _serde::export::fmt::Result {
                            _serde::export::Formatter::write_str(__formatter, "struct r#type")
                        }
                        #[inline]
                        fn visit_seq<__A>(
                            self,
                            mut __seq: __A,
                        ) -> _serde::export::Result<Self::Value, __A::Error>
                        where
                            __A: _serde::de::SeqAccess<'de>,
                        {
                            let __field0 = match match _serde::de::SeqAccess::next_element::<
                                Option<String>,
                            >(&mut __seq)
                            {
                                _serde::export::Ok(__val) => __val,
                                _serde::export::Err(__err) => {
                                    return _serde::export::Err(__err);
                                }
                            } {
                                _serde::export::Some(__value) => __value,
                                _serde::export::None => {
                                    return _serde::export::Err(_serde::de::Error::invalid_length(
                                        0usize,
                                        &"struct r#type with 3 elements",
                                    ));
                                }
                            };
                            let __field1 = match match _serde::de::SeqAccess::next_element::<
                                Option<String>,
                            >(&mut __seq)
                            {
                                _serde::export::Ok(__val) => __val,
                                _serde::export::Err(__err) => {
                                    return _serde::export::Err(__err);
                                }
                            } {
                                _serde::export::Some(__value) => __value,
                                _serde::export::None => {
                                    return _serde::export::Err(_serde::de::Error::invalid_length(
                                        1usize,
                                        &"struct r#type with 3 elements",
                                    ));
                                }
                            };
                            let __field2 = match match _serde::de::SeqAccess::next_element::<String>(
                                &mut __seq,
                            ) {
                                _serde::export::Ok(__val) => __val,
                                _serde::export::Err(__err) => {
                                    return _serde::export::Err(__err);
                                }
                            } {
                                _serde::export::Some(__value) => __value,
                                _serde::export::None => {
                                    return _serde::export::Err(_serde::de::Error::invalid_length(
                                        2usize,
                                        &"struct r#type with 3 elements",
                                    ));
                                }
                            };
                            _serde::export::Ok(r#type {
                                arch: __field0,
                                machine: __field1,
                                text: __field2,
                            })
                        }
                        #[inline]
                        fn visit_map<__A>(
                            self,
                            mut __map: __A,
                        ) -> _serde::export::Result<Self::Value, __A::Error>
                        where
                            __A: _serde::de::MapAccess<'de>,
                        {
                            let mut __field0: _serde::export::Option<Option<String>> =
                                _serde::export::None;
                            let mut __field1: _serde::export::Option<Option<String>> =
                                _serde::export::None;
                            let mut __field2: _serde::export::Option<String> = _serde::export::None;
                            while let _serde::export::Some(__key) =
                                match _serde::de::MapAccess::next_key::<__Field>(&mut __map) {
                                    _serde::export::Ok(__val) => __val,
                                    _serde::export::Err(__err) => {
                                        return _serde::export::Err(__err);
                                    }
                                }
                            {
                                match __key {
                                    __Field::__field0 => {
                                        if _serde::export::Option::is_some(&__field0) {
                                            return _serde::export::Err(
                                                <__A::Error as _serde::de::Error>::duplicate_field(
                                                    "arch",
                                                ),
                                            );
                                        }
                                        __field0 = _serde::export::Some(
                                            match _serde::de::MapAccess::next_value::<Option<String>>(
                                                &mut __map,
                                            ) {
                                                _serde::export::Ok(__val) => __val,
                                                _serde::export::Err(__err) => {
                                                    return _serde::export::Err(__err);
                                                }
                                            },
                                        );
                                    }
                                    __Field::__field1 => {
                                        if _serde::export::Option::is_some(&__field1) {
                                            return _serde::export::Err(
                                                <__A::Error as _serde::de::Error>::duplicate_field(
                                                    "machine",
                                                ),
                                            );
                                        }
                                        __field1 = _serde::export::Some(
                                            match _serde::de::MapAccess::next_value::<Option<String>>(
                                                &mut __map,
                                            ) {
                                                _serde::export::Ok(__val) => __val,
                                                _serde::export::Err(__err) => {
                                                    return _serde::export::Err(__err);
                                                }
                                            },
                                        );
                                    }
                                    __Field::__field2 => {
                                        if _serde::export::Option::is_some(&__field2) {
                                            return _serde::export::Err(
                                                <__A::Error as _serde::de::Error>::duplicate_field(
                                                    "text",
                                                ),
                                            );
                                        }
                                        __field2 = _serde::export::Some(
                                            match _serde::de::MapAccess::next_value::<String>(
                                                &mut __map,
                                            ) {
                                                _serde::export::Ok(__val) => __val,
                                                _serde::export::Err(__err) => {
                                                    return _serde::export::Err(__err);
                                                }
                                            },
                                        );
                                    }
                                    _ => {
                                        let _ = match _serde::de::MapAccess::next_value::<
                                            _serde::de::IgnoredAny,
                                        >(
                                            &mut __map
                                        ) {
                                            _serde::export::Ok(__val) => __val,
                                            _serde::export::Err(__err) => {
                                                return _serde::export::Err(__err);
                                            }
                                        };
                                    }
                                }
                            }
                            let __field0 = match __field0 {
                                _serde::export::Some(__field0) => __field0,
                                _serde::export::None => {
                                    match _serde::private::de::missing_field("arch") {
                                        _serde::export::Ok(__val) => __val,
                                        _serde::export::Err(__err) => {
                                            return _serde::export::Err(__err);
                                        }
                                    }
                                }
                            };
                            let __field1 = match __field1 {
                                _serde::export::Some(__field1) => __field1,
                                _serde::export::None => {
                                    match _serde::private::de::missing_field("machine") {
                                        _serde::export::Ok(__val) => __val,
                                        _serde::export::Err(__err) => {
                                            return _serde::export::Err(__err);
                                        }
                                    }
                                }
                            };
                            let __field2 = match __field2 {
                                _serde::export::Some(__field2) => __field2,
                                _serde::export::None => {
                                    match _serde::private::de::missing_field("text") {
                                        _serde::export::Ok(__val) => __val,
                                        _serde::export::Err(__err) => {
                                            return _serde::export::Err(__err);
                                        }
                                    }
                                }
                            };
                            _serde::export::Ok(r#type {
                                arch: __field0,
                                machine: __field1,
                                text: __field2,
                            })
                        }
                    }
                    const FIELDS: &'static [&'static str] = &["arch", "machine", "text"];
                    _serde::Deserializer::deserialize_struct(
                        __deserializer,
                        "type",
                        FIELDS,
                        __Visitor {
                            marker: _serde::export::PhantomData::<r#type>,
                            lifetime: _serde::export::PhantomData,
                        },
                    )
                }
            }
        };
        #[xml(tag = "vmport")]
        pub struct vmport {
            #[xml(attr = "state")]
            pub state: Option<String>,
            #[xml(text)]
            text: String,
        }
        impl<'__input> strong_xml::XmlRead<'__input> for vmport {
            fn from_reader(
                mut reader: &mut strong_xml::XmlReader<'__input>,
            ) -> strong_xml::XmlResult<Self> {
                use strong_xml::xmlparser::{ElementEnd, Token, Tokenizer};
                use strong_xml::XmlError;
                let mut __self_state = None;
                let __self_text;
                reader.read_till_element_start("vmport")?;
                while let Some((__key, __value)) = reader.find_attribute()? {
                    match __key {
                        "state" => {
                            __self_state = Some(
                                <String as std::str::FromStr>::from_str(&__value)
                                    .map_err(|e| XmlError::FromStr(e.into()))?,
                            );
                        }
                        key => {}
                    }
                }
                let __value = reader.read_text("vmport")?;
                __self_text = Some(
                    <String as std::str::FromStr>::from_str(&__value)
                        .map_err(|e| XmlError::FromStr(e.into()))?,
                );
                let __res = vmport {
                    state: __self_state,
                    text: __self_text.ok_or(XmlError::MissingField {
                        name: "vmport".to_owned(),
                        field: "text".to_owned(),
                    })?,
                };
                return Ok(__res);
            }
        }
        impl strong_xml::XmlWrite for vmport {
            fn to_writer<W: std::io::Write>(
                &self,
                mut writer: &mut strong_xml::XmlWriter<W>,
            ) -> strong_xml::XmlResult<()> {
                let vmport {
                    state: __self_state,
                    text: __self_text,
                } = self;
                writer.write_element_start("vmport")?;
                if let Some(__value) = __self_state {
                    writer.write_attribute("state", &{
                        let res = ::alloc::fmt::format(::core::fmt::Arguments::new_v1(
                            &[""],
                            &match (&__value,) {
                                (arg0,) => [::core::fmt::ArgumentV1::new(
                                    arg0,
                                    ::core::fmt::Display::fmt,
                                )],
                            },
                        ));
                        res
                    })?;
                }
                writer.write_element_end_open()?;
                let __value = &__self_text;
                writer.write_text(&{
                    let res = ::alloc::fmt::format(::core::fmt::Arguments::new_v1(
                        &[""],
                        &match (&__value,) {
                            (arg0,) => [::core::fmt::ArgumentV1::new(
                                arg0,
                                ::core::fmt::Display::fmt,
                            )],
                        },
                    ));
                    res
                })?;
                writer.write_element_end_close("vmport")?;
                Ok(())
            }
        }
        impl ::core::marker::StructuralPartialEq for vmport {}
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::cmp::PartialEq for vmport {
            #[inline]
            fn eq(&self, other: &vmport) -> bool {
                match *other {
                    vmport {
                        state: ref __self_1_0,
                        text: ref __self_1_1,
                    } => match *self {
                        vmport {
                            state: ref __self_0_0,
                            text: ref __self_0_1,
                        } => (*__self_0_0) == (*__self_1_0) && (*__self_0_1) == (*__self_1_1),
                    },
                }
            }
            #[inline]
            fn ne(&self, other: &vmport) -> bool {
                match *other {
                    vmport {
                        state: ref __self_1_0,
                        text: ref __self_1_1,
                    } => match *self {
                        vmport {
                            state: ref __self_0_0,
                            text: ref __self_0_1,
                        } => (*__self_0_0) != (*__self_1_0) || (*__self_0_1) != (*__self_1_1),
                    },
                }
            }
        }
        impl ::core::marker::StructuralEq for vmport {}
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::cmp::Eq for vmport {
            #[inline]
            #[doc(hidden)]
            fn assert_receiver_is_total_eq(&self) -> () {
                {
                    let _: ::core::cmp::AssertParamIsEq<Option<String>>;
                    let _: ::core::cmp::AssertParamIsEq<String>;
                }
            }
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::fmt::Debug for vmport {
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                match *self {
                    vmport {
                        state: ref __self_0_0,
                        text: ref __self_0_1,
                    } => {
                        let mut debug_trait_builder = f.debug_struct("vmport");
                        let _ = debug_trait_builder.field("state", &&(*__self_0_0));
                        let _ = debug_trait_builder.field("text", &&(*__self_0_1));
                        debug_trait_builder.finish()
                    }
                }
            }
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::clone::Clone for vmport {
            #[inline]
            fn clone(&self) -> vmport {
                match *self {
                    vmport {
                        state: ref __self_0_0,
                        text: ref __self_0_1,
                    } => vmport {
                        state: ::core::clone::Clone::clone(&(*__self_0_0)),
                        text: ::core::clone::Clone::clone(&(*__self_0_1)),
                    },
                }
            }
        }
        #[doc(hidden)]
        #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
        const _: () = {
            #[allow(rust_2018_idioms, clippy::useless_attribute)]
            extern crate serde as _serde;
            #[automatically_derived]
            impl _serde::Serialize for vmport {
                fn serialize<__S>(
                    &self,
                    __serializer: __S,
                ) -> _serde::export::Result<__S::Ok, __S::Error>
                where
                    __S: _serde::Serializer,
                {
                    let mut __serde_state = match _serde::Serializer::serialize_struct(
                        __serializer,
                        "vmport",
                        false as usize + 1 + 1,
                    ) {
                        _serde::export::Ok(__val) => __val,
                        _serde::export::Err(__err) => {
                            return _serde::export::Err(__err);
                        }
                    };
                    match _serde::ser::SerializeStruct::serialize_field(
                        &mut __serde_state,
                        "state",
                        &self.state,
                    ) {
                        _serde::export::Ok(__val) => __val,
                        _serde::export::Err(__err) => {
                            return _serde::export::Err(__err);
                        }
                    };
                    match _serde::ser::SerializeStruct::serialize_field(
                        &mut __serde_state,
                        "text",
                        &self.text,
                    ) {
                        _serde::export::Ok(__val) => __val,
                        _serde::export::Err(__err) => {
                            return _serde::export::Err(__err);
                        }
                    };
                    _serde::ser::SerializeStruct::end(__serde_state)
                }
            }
        };
        #[doc(hidden)]
        #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
        const _: () = {
            #[allow(rust_2018_idioms, clippy::useless_attribute)]
            extern crate serde as _serde;
            #[automatically_derived]
            impl<'de> _serde::Deserialize<'de> for vmport {
                fn deserialize<__D>(__deserializer: __D) -> _serde::export::Result<Self, __D::Error>
                where
                    __D: _serde::Deserializer<'de>,
                {
                    #[allow(non_camel_case_types)]
                    enum __Field {
                        __field0,
                        __field1,
                        __ignore,
                    }
                    struct __FieldVisitor;
                    impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                        type Value = __Field;
                        fn expecting(
                            &self,
                            __formatter: &mut _serde::export::Formatter,
                        ) -> _serde::export::fmt::Result {
                            _serde::export::Formatter::write_str(__formatter, "field identifier")
                        }
                        fn visit_u64<__E>(
                            self,
                            __value: u64,
                        ) -> _serde::export::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                0u64 => _serde::export::Ok(__Field::__field0),
                                1u64 => _serde::export::Ok(__Field::__field1),
                                _ => _serde::export::Err(_serde::de::Error::invalid_value(
                                    _serde::de::Unexpected::Unsigned(__value),
                                    &"field index 0 <= i < 2",
                                )),
                            }
                        }
                        fn visit_str<__E>(
                            self,
                            __value: &str,
                        ) -> _serde::export::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                "state" => _serde::export::Ok(__Field::__field0),
                                "text" => _serde::export::Ok(__Field::__field1),
                                _ => _serde::export::Ok(__Field::__ignore),
                            }
                        }
                        fn visit_bytes<__E>(
                            self,
                            __value: &[u8],
                        ) -> _serde::export::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                b"state" => _serde::export::Ok(__Field::__field0),
                                b"text" => _serde::export::Ok(__Field::__field1),
                                _ => _serde::export::Ok(__Field::__ignore),
                            }
                        }
                    }
                    impl<'de> _serde::Deserialize<'de> for __Field {
                        #[inline]
                        fn deserialize<__D>(
                            __deserializer: __D,
                        ) -> _serde::export::Result<Self, __D::Error>
                        where
                            __D: _serde::Deserializer<'de>,
                        {
                            _serde::Deserializer::deserialize_identifier(
                                __deserializer,
                                __FieldVisitor,
                            )
                        }
                    }
                    struct __Visitor<'de> {
                        marker: _serde::export::PhantomData<vmport>,
                        lifetime: _serde::export::PhantomData<&'de ()>,
                    }
                    impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                        type Value = vmport;
                        fn expecting(
                            &self,
                            __formatter: &mut _serde::export::Formatter,
                        ) -> _serde::export::fmt::Result {
                            _serde::export::Formatter::write_str(__formatter, "struct vmport")
                        }
                        #[inline]
                        fn visit_seq<__A>(
                            self,
                            mut __seq: __A,
                        ) -> _serde::export::Result<Self::Value, __A::Error>
                        where
                            __A: _serde::de::SeqAccess<'de>,
                        {
                            let __field0 = match match _serde::de::SeqAccess::next_element::<
                                Option<String>,
                            >(&mut __seq)
                            {
                                _serde::export::Ok(__val) => __val,
                                _serde::export::Err(__err) => {
                                    return _serde::export::Err(__err);
                                }
                            } {
                                _serde::export::Some(__value) => __value,
                                _serde::export::None => {
                                    return _serde::export::Err(_serde::de::Error::invalid_length(
                                        0usize,
                                        &"struct vmport with 2 elements",
                                    ));
                                }
                            };
                            let __field1 = match match _serde::de::SeqAccess::next_element::<String>(
                                &mut __seq,
                            ) {
                                _serde::export::Ok(__val) => __val,
                                _serde::export::Err(__err) => {
                                    return _serde::export::Err(__err);
                                }
                            } {
                                _serde::export::Some(__value) => __value,
                                _serde::export::None => {
                                    return _serde::export::Err(_serde::de::Error::invalid_length(
                                        1usize,
                                        &"struct vmport with 2 elements",
                                    ));
                                }
                            };
                            _serde::export::Ok(vmport {
                                state: __field0,
                                text: __field1,
                            })
                        }
                        #[inline]
                        fn visit_map<__A>(
                            self,
                            mut __map: __A,
                        ) -> _serde::export::Result<Self::Value, __A::Error>
                        where
                            __A: _serde::de::MapAccess<'de>,
                        {
                            let mut __field0: _serde::export::Option<Option<String>> =
                                _serde::export::None;
                            let mut __field1: _serde::export::Option<String> = _serde::export::None;
                            while let _serde::export::Some(__key) =
                                match _serde::de::MapAccess::next_key::<__Field>(&mut __map) {
                                    _serde::export::Ok(__val) => __val,
                                    _serde::export::Err(__err) => {
                                        return _serde::export::Err(__err);
                                    }
                                }
                            {
                                match __key {
                                    __Field::__field0 => {
                                        if _serde::export::Option::is_some(&__field0) {
                                            return _serde::export::Err(
                                                <__A::Error as _serde::de::Error>::duplicate_field(
                                                    "state",
                                                ),
                                            );
                                        }
                                        __field0 = _serde::export::Some(
                                            match _serde::de::MapAccess::next_value::<Option<String>>(
                                                &mut __map,
                                            ) {
                                                _serde::export::Ok(__val) => __val,
                                                _serde::export::Err(__err) => {
                                                    return _serde::export::Err(__err);
                                                }
                                            },
                                        );
                                    }
                                    __Field::__field1 => {
                                        if _serde::export::Option::is_some(&__field1) {
                                            return _serde::export::Err(
                                                <__A::Error as _serde::de::Error>::duplicate_field(
                                                    "text",
                                                ),
                                            );
                                        }
                                        __field1 = _serde::export::Some(
                                            match _serde::de::MapAccess::next_value::<String>(
                                                &mut __map,
                                            ) {
                                                _serde::export::Ok(__val) => __val,
                                                _serde::export::Err(__err) => {
                                                    return _serde::export::Err(__err);
                                                }
                                            },
                                        );
                                    }
                                    _ => {
                                        let _ = match _serde::de::MapAccess::next_value::<
                                            _serde::de::IgnoredAny,
                                        >(
                                            &mut __map
                                        ) {
                                            _serde::export::Ok(__val) => __val,
                                            _serde::export::Err(__err) => {
                                                return _serde::export::Err(__err);
                                            }
                                        };
                                    }
                                }
                            }
                            let __field0 = match __field0 {
                                _serde::export::Some(__field0) => __field0,
                                _serde::export::None => {
                                    match _serde::private::de::missing_field("state") {
                                        _serde::export::Ok(__val) => __val,
                                        _serde::export::Err(__err) => {
                                            return _serde::export::Err(__err);
                                        }
                                    }
                                }
                            };
                            let __field1 = match __field1 {
                                _serde::export::Some(__field1) => __field1,
                                _serde::export::None => {
                                    match _serde::private::de::missing_field("text") {
                                        _serde::export::Ok(__val) => __val,
                                        _serde::export::Err(__err) => {
                                            return _serde::export::Err(__err);
                                        }
                                    }
                                }
                            };
                            _serde::export::Ok(vmport {
                                state: __field0,
                                text: __field1,
                            })
                        }
                    }
                    const FIELDS: &'static [&'static str] = &["state", "text"];
                    _serde::Deserializer::deserialize_struct(
                        __deserializer,
                        "vmport",
                        FIELDS,
                        __Visitor {
                            marker: _serde::export::PhantomData::<vmport>,
                            lifetime: _serde::export::PhantomData,
                        },
                    )
                }
            }
        };
        #[xml(tag = "driver")]
        pub struct driver {
            #[xml(attr = "name")]
            pub name: Option<String>,
            #[xml(attr = "type")]
            pub r#type: Option<String>,
            #[xml(text)]
            text: String,
        }
        impl<'__input> strong_xml::XmlRead<'__input> for driver {
            fn from_reader(
                mut reader: &mut strong_xml::XmlReader<'__input>,
            ) -> strong_xml::XmlResult<Self> {
                use strong_xml::xmlparser::{ElementEnd, Token, Tokenizer};
                use strong_xml::XmlError;
                let mut __self_name = None;
                let mut __self_type = None;
                let __self_text;
                reader.read_till_element_start("driver")?;
                while let Some((__key, __value)) = reader.find_attribute()? {
                    match __key {
                        "name" => {
                            __self_name = Some(
                                <String as std::str::FromStr>::from_str(&__value)
                                    .map_err(|e| XmlError::FromStr(e.into()))?,
                            );
                        }
                        "type" => {
                            __self_type = Some(
                                <String as std::str::FromStr>::from_str(&__value)
                                    .map_err(|e| XmlError::FromStr(e.into()))?,
                            );
                        }
                        key => {}
                    }
                }
                let __value = reader.read_text("driver")?;
                __self_text = Some(
                    <String as std::str::FromStr>::from_str(&__value)
                        .map_err(|e| XmlError::FromStr(e.into()))?,
                );
                let __res = driver {
                    name: __self_name,
                    r#type: __self_type,
                    text: __self_text.ok_or(XmlError::MissingField {
                        name: "driver".to_owned(),
                        field: "text".to_owned(),
                    })?,
                };
                return Ok(__res);
            }
        }
        impl strong_xml::XmlWrite for driver {
            fn to_writer<W: std::io::Write>(
                &self,
                mut writer: &mut strong_xml::XmlWriter<W>,
            ) -> strong_xml::XmlResult<()> {
                let driver {
                    name: __self_name,
                    r#type: __self_type,
                    text: __self_text,
                } = self;
                writer.write_element_start("driver")?;
                if let Some(__value) = __self_name {
                    writer.write_attribute("name", &{
                        let res = ::alloc::fmt::format(::core::fmt::Arguments::new_v1(
                            &[""],
                            &match (&__value,) {
                                (arg0,) => [::core::fmt::ArgumentV1::new(
                                    arg0,
                                    ::core::fmt::Display::fmt,
                                )],
                            },
                        ));
                        res
                    })?;
                }
                if let Some(__value) = __self_type {
                    writer.write_attribute("type", &{
                        let res = ::alloc::fmt::format(::core::fmt::Arguments::new_v1(
                            &[""],
                            &match (&__value,) {
                                (arg0,) => [::core::fmt::ArgumentV1::new(
                                    arg0,
                                    ::core::fmt::Display::fmt,
                                )],
                            },
                        ));
                        res
                    })?;
                }
                writer.write_element_end_open()?;
                let __value = &__self_text;
                writer.write_text(&{
                    let res = ::alloc::fmt::format(::core::fmt::Arguments::new_v1(
                        &[""],
                        &match (&__value,) {
                            (arg0,) => [::core::fmt::ArgumentV1::new(
                                arg0,
                                ::core::fmt::Display::fmt,
                            )],
                        },
                    ));
                    res
                })?;
                writer.write_element_end_close("driver")?;
                Ok(())
            }
        }
        impl ::core::marker::StructuralPartialEq for driver {}
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::cmp::PartialEq for driver {
            #[inline]
            fn eq(&self, other: &driver) -> bool {
                match *other {
                    driver {
                        name: ref __self_1_0,
                        r#type: ref __self_1_1,
                        text: ref __self_1_2,
                    } => match *self {
                        driver {
                            name: ref __self_0_0,
                            r#type: ref __self_0_1,
                            text: ref __self_0_2,
                        } => {
                            (*__self_0_0) == (*__self_1_0)
                                && (*__self_0_1) == (*__self_1_1)
                                && (*__self_0_2) == (*__self_1_2)
                        }
                    },
                }
            }
            #[inline]
            fn ne(&self, other: &driver) -> bool {
                match *other {
                    driver {
                        name: ref __self_1_0,
                        r#type: ref __self_1_1,
                        text: ref __self_1_2,
                    } => match *self {
                        driver {
                            name: ref __self_0_0,
                            r#type: ref __self_0_1,
                            text: ref __self_0_2,
                        } => {
                            (*__self_0_0) != (*__self_1_0)
                                || (*__self_0_1) != (*__self_1_1)
                                || (*__self_0_2) != (*__self_1_2)
                        }
                    },
                }
            }
        }
        impl ::core::marker::StructuralEq for driver {}
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::cmp::Eq for driver {
            #[inline]
            #[doc(hidden)]
            fn assert_receiver_is_total_eq(&self) -> () {
                {
                    let _: ::core::cmp::AssertParamIsEq<Option<String>>;
                    let _: ::core::cmp::AssertParamIsEq<Option<String>>;
                    let _: ::core::cmp::AssertParamIsEq<String>;
                }
            }
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::fmt::Debug for driver {
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                match *self {
                    driver {
                        name: ref __self_0_0,
                        r#type: ref __self_0_1,
                        text: ref __self_0_2,
                    } => {
                        let mut debug_trait_builder = f.debug_struct("driver");
                        let _ = debug_trait_builder.field("name", &&(*__self_0_0));
                        let _ = debug_trait_builder.field("type", &&(*__self_0_1));
                        let _ = debug_trait_builder.field("text", &&(*__self_0_2));
                        debug_trait_builder.finish()
                    }
                }
            }
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::clone::Clone for driver {
            #[inline]
            fn clone(&self) -> driver {
                match *self {
                    driver {
                        name: ref __self_0_0,
                        r#type: ref __self_0_1,
                        text: ref __self_0_2,
                    } => driver {
                        name: ::core::clone::Clone::clone(&(*__self_0_0)),
                        r#type: ::core::clone::Clone::clone(&(*__self_0_1)),
                        text: ::core::clone::Clone::clone(&(*__self_0_2)),
                    },
                }
            }
        }
        #[doc(hidden)]
        #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
        const _: () = {
            #[allow(rust_2018_idioms, clippy::useless_attribute)]
            extern crate serde as _serde;
            #[automatically_derived]
            impl _serde::Serialize for driver {
                fn serialize<__S>(
                    &self,
                    __serializer: __S,
                ) -> _serde::export::Result<__S::Ok, __S::Error>
                where
                    __S: _serde::Serializer,
                {
                    let mut __serde_state = match _serde::Serializer::serialize_struct(
                        __serializer,
                        "driver",
                        false as usize + 1 + 1 + 1,
                    ) {
                        _serde::export::Ok(__val) => __val,
                        _serde::export::Err(__err) => {
                            return _serde::export::Err(__err);
                        }
                    };
                    match _serde::ser::SerializeStruct::serialize_field(
                        &mut __serde_state,
                        "name",
                        &self.name,
                    ) {
                        _serde::export::Ok(__val) => __val,
                        _serde::export::Err(__err) => {
                            return _serde::export::Err(__err);
                        }
                    };
                    match _serde::ser::SerializeStruct::serialize_field(
                        &mut __serde_state,
                        "type",
                        &self.r#type,
                    ) {
                        _serde::export::Ok(__val) => __val,
                        _serde::export::Err(__err) => {
                            return _serde::export::Err(__err);
                        }
                    };
                    match _serde::ser::SerializeStruct::serialize_field(
                        &mut __serde_state,
                        "text",
                        &self.text,
                    ) {
                        _serde::export::Ok(__val) => __val,
                        _serde::export::Err(__err) => {
                            return _serde::export::Err(__err);
                        }
                    };
                    _serde::ser::SerializeStruct::end(__serde_state)
                }
            }
        };
        #[doc(hidden)]
        #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
        const _: () = {
            #[allow(rust_2018_idioms, clippy::useless_attribute)]
            extern crate serde as _serde;
            #[automatically_derived]
            impl<'de> _serde::Deserialize<'de> for driver {
                fn deserialize<__D>(__deserializer: __D) -> _serde::export::Result<Self, __D::Error>
                where
                    __D: _serde::Deserializer<'de>,
                {
                    #[allow(non_camel_case_types)]
                    enum __Field {
                        __field0,
                        __field1,
                        __field2,
                        __ignore,
                    }
                    struct __FieldVisitor;
                    impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                        type Value = __Field;
                        fn expecting(
                            &self,
                            __formatter: &mut _serde::export::Formatter,
                        ) -> _serde::export::fmt::Result {
                            _serde::export::Formatter::write_str(__formatter, "field identifier")
                        }
                        fn visit_u64<__E>(
                            self,
                            __value: u64,
                        ) -> _serde::export::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                0u64 => _serde::export::Ok(__Field::__field0),
                                1u64 => _serde::export::Ok(__Field::__field1),
                                2u64 => _serde::export::Ok(__Field::__field2),
                                _ => _serde::export::Err(_serde::de::Error::invalid_value(
                                    _serde::de::Unexpected::Unsigned(__value),
                                    &"field index 0 <= i < 3",
                                )),
                            }
                        }
                        fn visit_str<__E>(
                            self,
                            __value: &str,
                        ) -> _serde::export::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                "name" => _serde::export::Ok(__Field::__field0),
                                "type" => _serde::export::Ok(__Field::__field1),
                                "text" => _serde::export::Ok(__Field::__field2),
                                _ => _serde::export::Ok(__Field::__ignore),
                            }
                        }
                        fn visit_bytes<__E>(
                            self,
                            __value: &[u8],
                        ) -> _serde::export::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                b"name" => _serde::export::Ok(__Field::__field0),
                                b"type" => _serde::export::Ok(__Field::__field1),
                                b"text" => _serde::export::Ok(__Field::__field2),
                                _ => _serde::export::Ok(__Field::__ignore),
                            }
                        }
                    }
                    impl<'de> _serde::Deserialize<'de> for __Field {
                        #[inline]
                        fn deserialize<__D>(
                            __deserializer: __D,
                        ) -> _serde::export::Result<Self, __D::Error>
                        where
                            __D: _serde::Deserializer<'de>,
                        {
                            _serde::Deserializer::deserialize_identifier(
                                __deserializer,
                                __FieldVisitor,
                            )
                        }
                    }
                    struct __Visitor<'de> {
                        marker: _serde::export::PhantomData<driver>,
                        lifetime: _serde::export::PhantomData<&'de ()>,
                    }
                    impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                        type Value = driver;
                        fn expecting(
                            &self,
                            __formatter: &mut _serde::export::Formatter,
                        ) -> _serde::export::fmt::Result {
                            _serde::export::Formatter::write_str(__formatter, "struct driver")
                        }
                        #[inline]
                        fn visit_seq<__A>(
                            self,
                            mut __seq: __A,
                        ) -> _serde::export::Result<Self::Value, __A::Error>
                        where
                            __A: _serde::de::SeqAccess<'de>,
                        {
                            let __field0 = match match _serde::de::SeqAccess::next_element::<
                                Option<String>,
                            >(&mut __seq)
                            {
                                _serde::export::Ok(__val) => __val,
                                _serde::export::Err(__err) => {
                                    return _serde::export::Err(__err);
                                }
                            } {
                                _serde::export::Some(__value) => __value,
                                _serde::export::None => {
                                    return _serde::export::Err(_serde::de::Error::invalid_length(
                                        0usize,
                                        &"struct driver with 3 elements",
                                    ));
                                }
                            };
                            let __field1 = match match _serde::de::SeqAccess::next_element::<
                                Option<String>,
                            >(&mut __seq)
                            {
                                _serde::export::Ok(__val) => __val,
                                _serde::export::Err(__err) => {
                                    return _serde::export::Err(__err);
                                }
                            } {
                                _serde::export::Some(__value) => __value,
                                _serde::export::None => {
                                    return _serde::export::Err(_serde::de::Error::invalid_length(
                                        1usize,
                                        &"struct driver with 3 elements",
                                    ));
                                }
                            };
                            let __field2 = match match _serde::de::SeqAccess::next_element::<String>(
                                &mut __seq,
                            ) {
                                _serde::export::Ok(__val) => __val,
                                _serde::export::Err(__err) => {
                                    return _serde::export::Err(__err);
                                }
                            } {
                                _serde::export::Some(__value) => __value,
                                _serde::export::None => {
                                    return _serde::export::Err(_serde::de::Error::invalid_length(
                                        2usize,
                                        &"struct driver with 3 elements",
                                    ));
                                }
                            };
                            _serde::export::Ok(driver {
                                name: __field0,
                                r#type: __field1,
                                text: __field2,
                            })
                        }
                        #[inline]
                        fn visit_map<__A>(
                            self,
                            mut __map: __A,
                        ) -> _serde::export::Result<Self::Value, __A::Error>
                        where
                            __A: _serde::de::MapAccess<'de>,
                        {
                            let mut __field0: _serde::export::Option<Option<String>> =
                                _serde::export::None;
                            let mut __field1: _serde::export::Option<Option<String>> =
                                _serde::export::None;
                            let mut __field2: _serde::export::Option<String> = _serde::export::None;
                            while let _serde::export::Some(__key) =
                                match _serde::de::MapAccess::next_key::<__Field>(&mut __map) {
                                    _serde::export::Ok(__val) => __val,
                                    _serde::export::Err(__err) => {
                                        return _serde::export::Err(__err);
                                    }
                                }
                            {
                                match __key {
                                    __Field::__field0 => {
                                        if _serde::export::Option::is_some(&__field0) {
                                            return _serde::export::Err(
                                                <__A::Error as _serde::de::Error>::duplicate_field(
                                                    "name",
                                                ),
                                            );
                                        }
                                        __field0 = _serde::export::Some(
                                            match _serde::de::MapAccess::next_value::<Option<String>>(
                                                &mut __map,
                                            ) {
                                                _serde::export::Ok(__val) => __val,
                                                _serde::export::Err(__err) => {
                                                    return _serde::export::Err(__err);
                                                }
                                            },
                                        );
                                    }
                                    __Field::__field1 => {
                                        if _serde::export::Option::is_some(&__field1) {
                                            return _serde::export::Err(
                                                <__A::Error as _serde::de::Error>::duplicate_field(
                                                    "type",
                                                ),
                                            );
                                        }
                                        __field1 = _serde::export::Some(
                                            match _serde::de::MapAccess::next_value::<Option<String>>(
                                                &mut __map,
                                            ) {
                                                _serde::export::Ok(__val) => __val,
                                                _serde::export::Err(__err) => {
                                                    return _serde::export::Err(__err);
                                                }
                                            },
                                        );
                                    }
                                    __Field::__field2 => {
                                        if _serde::export::Option::is_some(&__field2) {
                                            return _serde::export::Err(
                                                <__A::Error as _serde::de::Error>::duplicate_field(
                                                    "text",
                                                ),
                                            );
                                        }
                                        __field2 = _serde::export::Some(
                                            match _serde::de::MapAccess::next_value::<String>(
                                                &mut __map,
                                            ) {
                                                _serde::export::Ok(__val) => __val,
                                                _serde::export::Err(__err) => {
                                                    return _serde::export::Err(__err);
                                                }
                                            },
                                        );
                                    }
                                    _ => {
                                        let _ = match _serde::de::MapAccess::next_value::<
                                            _serde::de::IgnoredAny,
                                        >(
                                            &mut __map
                                        ) {
                                            _serde::export::Ok(__val) => __val,
                                            _serde::export::Err(__err) => {
                                                return _serde::export::Err(__err);
                                            }
                                        };
                                    }
                                }
                            }
                            let __field0 = match __field0 {
                                _serde::export::Some(__field0) => __field0,
                                _serde::export::None => {
                                    match _serde::private::de::missing_field("name") {
                                        _serde::export::Ok(__val) => __val,
                                        _serde::export::Err(__err) => {
                                            return _serde::export::Err(__err);
                                        }
                                    }
                                }
                            };
                            let __field1 = match __field1 {
                                _serde::export::Some(__field1) => __field1,
                                _serde::export::None => {
                                    match _serde::private::de::missing_field("type") {
                                        _serde::export::Ok(__val) => __val,
                                        _serde::export::Err(__err) => {
                                            return _serde::export::Err(__err);
                                        }
                                    }
                                }
                            };
                            let __field2 = match __field2 {
                                _serde::export::Some(__field2) => __field2,
                                _serde::export::None => {
                                    match _serde::private::de::missing_field("text") {
                                        _serde::export::Ok(__val) => __val,
                                        _serde::export::Err(__err) => {
                                            return _serde::export::Err(__err);
                                        }
                                    }
                                }
                            };
                            _serde::export::Ok(driver {
                                name: __field0,
                                r#type: __field1,
                                text: __field2,
                            })
                        }
                    }
                    const FIELDS: &'static [&'static str] = &["name", "type", "text"];
                    _serde::Deserializer::deserialize_struct(
                        __deserializer,
                        "driver",
                        FIELDS,
                        __Visitor {
                            marker: _serde::export::PhantomData::<driver>,
                            lifetime: _serde::export::PhantomData,
                        },
                    )
                }
            }
        };
        #[xml(tag = "target")]
        pub struct Target {
            #[xml(attr = "dev")]
            pub dev: Option<String>,
            #[xml(attr = "bus")]
            pub bus: Option<String>,
            #[xml(text)]
            text: String,
        }
        impl<'__input> strong_xml::XmlRead<'__input> for Target {
            fn from_reader(
                mut reader: &mut strong_xml::XmlReader<'__input>,
            ) -> strong_xml::XmlResult<Self> {
                use strong_xml::xmlparser::{ElementEnd, Token, Tokenizer};
                use strong_xml::XmlError;
                let mut __self_dev = None;
                let mut __self_bus = None;
                let __self_text;
                reader.read_till_element_start("target")?;
                while let Some((__key, __value)) = reader.find_attribute()? {
                    match __key {
                        "dev" => {
                            __self_dev = Some(
                                <String as std::str::FromStr>::from_str(&__value)
                                    .map_err(|e| XmlError::FromStr(e.into()))?,
                            );
                        }
                        "bus" => {
                            __self_bus = Some(
                                <String as std::str::FromStr>::from_str(&__value)
                                    .map_err(|e| XmlError::FromStr(e.into()))?,
                            );
                        }
                        key => {}
                    }
                }
                let __value = reader.read_text("target")?;
                __self_text = Some(
                    <String as std::str::FromStr>::from_str(&__value)
                        .map_err(|e| XmlError::FromStr(e.into()))?,
                );
                let __res = Target {
                    dev: __self_dev,
                    bus: __self_bus,
                    text: __self_text.ok_or(XmlError::MissingField {
                        name: "Target".to_owned(),
                        field: "text".to_owned(),
                    })?,
                };
                return Ok(__res);
            }
        }
        impl strong_xml::XmlWrite for Target {
            fn to_writer<W: std::io::Write>(
                &self,
                mut writer: &mut strong_xml::XmlWriter<W>,
            ) -> strong_xml::XmlResult<()> {
                let Target {
                    dev: __self_dev,
                    bus: __self_bus,
                    text: __self_text,
                } = self;
                writer.write_element_start("target")?;
                if let Some(__value) = __self_dev {
                    writer.write_attribute("dev", &{
                        let res = ::alloc::fmt::format(::core::fmt::Arguments::new_v1(
                            &[""],
                            &match (&__value,) {
                                (arg0,) => [::core::fmt::ArgumentV1::new(
                                    arg0,
                                    ::core::fmt::Display::fmt,
                                )],
                            },
                        ));
                        res
                    })?;
                }
                if let Some(__value) = __self_bus {
                    writer.write_attribute("bus", &{
                        let res = ::alloc::fmt::format(::core::fmt::Arguments::new_v1(
                            &[""],
                            &match (&__value,) {
                                (arg0,) => [::core::fmt::ArgumentV1::new(
                                    arg0,
                                    ::core::fmt::Display::fmt,
                                )],
                            },
                        ));
                        res
                    })?;
                }
                writer.write_element_end_open()?;
                let __value = &__self_text;
                writer.write_text(&{
                    let res = ::alloc::fmt::format(::core::fmt::Arguments::new_v1(
                        &[""],
                        &match (&__value,) {
                            (arg0,) => [::core::fmt::ArgumentV1::new(
                                arg0,
                                ::core::fmt::Display::fmt,
                            )],
                        },
                    ));
                    res
                })?;
                writer.write_element_end_close("target")?;
                Ok(())
            }
        }
        impl ::core::marker::StructuralPartialEq for Target {}
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::cmp::PartialEq for Target {
            #[inline]
            fn eq(&self, other: &Target) -> bool {
                match *other {
                    Target {
                        dev: ref __self_1_0,
                        bus: ref __self_1_1,
                        text: ref __self_1_2,
                    } => match *self {
                        Target {
                            dev: ref __self_0_0,
                            bus: ref __self_0_1,
                            text: ref __self_0_2,
                        } => {
                            (*__self_0_0) == (*__self_1_0)
                                && (*__self_0_1) == (*__self_1_1)
                                && (*__self_0_2) == (*__self_1_2)
                        }
                    },
                }
            }
            #[inline]
            fn ne(&self, other: &Target) -> bool {
                match *other {
                    Target {
                        dev: ref __self_1_0,
                        bus: ref __self_1_1,
                        text: ref __self_1_2,
                    } => match *self {
                        Target {
                            dev: ref __self_0_0,
                            bus: ref __self_0_1,
                            text: ref __self_0_2,
                        } => {
                            (*__self_0_0) != (*__self_1_0)
                                || (*__self_0_1) != (*__self_1_1)
                                || (*__self_0_2) != (*__self_1_2)
                        }
                    },
                }
            }
        }
        impl ::core::marker::StructuralEq for Target {}
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::cmp::Eq for Target {
            #[inline]
            #[doc(hidden)]
            fn assert_receiver_is_total_eq(&self) -> () {
                {
                    let _: ::core::cmp::AssertParamIsEq<Option<String>>;
                    let _: ::core::cmp::AssertParamIsEq<Option<String>>;
                    let _: ::core::cmp::AssertParamIsEq<String>;
                }
            }
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::fmt::Debug for Target {
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                match *self {
                    Target {
                        dev: ref __self_0_0,
                        bus: ref __self_0_1,
                        text: ref __self_0_2,
                    } => {
                        let mut debug_trait_builder = f.debug_struct("Target");
                        let _ = debug_trait_builder.field("dev", &&(*__self_0_0));
                        let _ = debug_trait_builder.field("bus", &&(*__self_0_1));
                        let _ = debug_trait_builder.field("text", &&(*__self_0_2));
                        debug_trait_builder.finish()
                    }
                }
            }
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::clone::Clone for Target {
            #[inline]
            fn clone(&self) -> Target {
                match *self {
                    Target {
                        dev: ref __self_0_0,
                        bus: ref __self_0_1,
                        text: ref __self_0_2,
                    } => Target {
                        dev: ::core::clone::Clone::clone(&(*__self_0_0)),
                        bus: ::core::clone::Clone::clone(&(*__self_0_1)),
                        text: ::core::clone::Clone::clone(&(*__self_0_2)),
                    },
                }
            }
        }
        #[doc(hidden)]
        #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
        const _: () = {
            #[allow(rust_2018_idioms, clippy::useless_attribute)]
            extern crate serde as _serde;
            #[automatically_derived]
            impl _serde::Serialize for Target {
                fn serialize<__S>(
                    &self,
                    __serializer: __S,
                ) -> _serde::export::Result<__S::Ok, __S::Error>
                where
                    __S: _serde::Serializer,
                {
                    let mut __serde_state = match _serde::Serializer::serialize_struct(
                        __serializer,
                        "Target",
                        false as usize + 1 + 1 + 1,
                    ) {
                        _serde::export::Ok(__val) => __val,
                        _serde::export::Err(__err) => {
                            return _serde::export::Err(__err);
                        }
                    };
                    match _serde::ser::SerializeStruct::serialize_field(
                        &mut __serde_state,
                        "dev",
                        &self.dev,
                    ) {
                        _serde::export::Ok(__val) => __val,
                        _serde::export::Err(__err) => {
                            return _serde::export::Err(__err);
                        }
                    };
                    match _serde::ser::SerializeStruct::serialize_field(
                        &mut __serde_state,
                        "bus",
                        &self.bus,
                    ) {
                        _serde::export::Ok(__val) => __val,
                        _serde::export::Err(__err) => {
                            return _serde::export::Err(__err);
                        }
                    };
                    match _serde::ser::SerializeStruct::serialize_field(
                        &mut __serde_state,
                        "text",
                        &self.text,
                    ) {
                        _serde::export::Ok(__val) => __val,
                        _serde::export::Err(__err) => {
                            return _serde::export::Err(__err);
                        }
                    };
                    _serde::ser::SerializeStruct::end(__serde_state)
                }
            }
        };
        #[doc(hidden)]
        #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
        const _: () = {
            #[allow(rust_2018_idioms, clippy::useless_attribute)]
            extern crate serde as _serde;
            #[automatically_derived]
            impl<'de> _serde::Deserialize<'de> for Target {
                fn deserialize<__D>(__deserializer: __D) -> _serde::export::Result<Self, __D::Error>
                where
                    __D: _serde::Deserializer<'de>,
                {
                    #[allow(non_camel_case_types)]
                    enum __Field {
                        __field0,
                        __field1,
                        __field2,
                        __ignore,
                    }
                    struct __FieldVisitor;
                    impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                        type Value = __Field;
                        fn expecting(
                            &self,
                            __formatter: &mut _serde::export::Formatter,
                        ) -> _serde::export::fmt::Result {
                            _serde::export::Formatter::write_str(__formatter, "field identifier")
                        }
                        fn visit_u64<__E>(
                            self,
                            __value: u64,
                        ) -> _serde::export::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                0u64 => _serde::export::Ok(__Field::__field0),
                                1u64 => _serde::export::Ok(__Field::__field1),
                                2u64 => _serde::export::Ok(__Field::__field2),
                                _ => _serde::export::Err(_serde::de::Error::invalid_value(
                                    _serde::de::Unexpected::Unsigned(__value),
                                    &"field index 0 <= i < 3",
                                )),
                            }
                        }
                        fn visit_str<__E>(
                            self,
                            __value: &str,
                        ) -> _serde::export::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                "dev" => _serde::export::Ok(__Field::__field0),
                                "bus" => _serde::export::Ok(__Field::__field1),
                                "text" => _serde::export::Ok(__Field::__field2),
                                _ => _serde::export::Ok(__Field::__ignore),
                            }
                        }
                        fn visit_bytes<__E>(
                            self,
                            __value: &[u8],
                        ) -> _serde::export::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                b"dev" => _serde::export::Ok(__Field::__field0),
                                b"bus" => _serde::export::Ok(__Field::__field1),
                                b"text" => _serde::export::Ok(__Field::__field2),
                                _ => _serde::export::Ok(__Field::__ignore),
                            }
                        }
                    }
                    impl<'de> _serde::Deserialize<'de> for __Field {
                        #[inline]
                        fn deserialize<__D>(
                            __deserializer: __D,
                        ) -> _serde::export::Result<Self, __D::Error>
                        where
                            __D: _serde::Deserializer<'de>,
                        {
                            _serde::Deserializer::deserialize_identifier(
                                __deserializer,
                                __FieldVisitor,
                            )
                        }
                    }
                    struct __Visitor<'de> {
                        marker: _serde::export::PhantomData<Target>,
                        lifetime: _serde::export::PhantomData<&'de ()>,
                    }
                    impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                        type Value = Target;
                        fn expecting(
                            &self,
                            __formatter: &mut _serde::export::Formatter,
                        ) -> _serde::export::fmt::Result {
                            _serde::export::Formatter::write_str(__formatter, "struct Target")
                        }
                        #[inline]
                        fn visit_seq<__A>(
                            self,
                            mut __seq: __A,
                        ) -> _serde::export::Result<Self::Value, __A::Error>
                        where
                            __A: _serde::de::SeqAccess<'de>,
                        {
                            let __field0 = match match _serde::de::SeqAccess::next_element::<
                                Option<String>,
                            >(&mut __seq)
                            {
                                _serde::export::Ok(__val) => __val,
                                _serde::export::Err(__err) => {
                                    return _serde::export::Err(__err);
                                }
                            } {
                                _serde::export::Some(__value) => __value,
                                _serde::export::None => {
                                    return _serde::export::Err(_serde::de::Error::invalid_length(
                                        0usize,
                                        &"struct Target with 3 elements",
                                    ));
                                }
                            };
                            let __field1 = match match _serde::de::SeqAccess::next_element::<
                                Option<String>,
                            >(&mut __seq)
                            {
                                _serde::export::Ok(__val) => __val,
                                _serde::export::Err(__err) => {
                                    return _serde::export::Err(__err);
                                }
                            } {
                                _serde::export::Some(__value) => __value,
                                _serde::export::None => {
                                    return _serde::export::Err(_serde::de::Error::invalid_length(
                                        1usize,
                                        &"struct Target with 3 elements",
                                    ));
                                }
                            };
                            let __field2 = match match _serde::de::SeqAccess::next_element::<String>(
                                &mut __seq,
                            ) {
                                _serde::export::Ok(__val) => __val,
                                _serde::export::Err(__err) => {
                                    return _serde::export::Err(__err);
                                }
                            } {
                                _serde::export::Some(__value) => __value,
                                _serde::export::None => {
                                    return _serde::export::Err(_serde::de::Error::invalid_length(
                                        2usize,
                                        &"struct Target with 3 elements",
                                    ));
                                }
                            };
                            _serde::export::Ok(Target {
                                dev: __field0,
                                bus: __field1,
                                text: __field2,
                            })
                        }
                        #[inline]
                        fn visit_map<__A>(
                            self,
                            mut __map: __A,
                        ) -> _serde::export::Result<Self::Value, __A::Error>
                        where
                            __A: _serde::de::MapAccess<'de>,
                        {
                            let mut __field0: _serde::export::Option<Option<String>> =
                                _serde::export::None;
                            let mut __field1: _serde::export::Option<Option<String>> =
                                _serde::export::None;
                            let mut __field2: _serde::export::Option<String> = _serde::export::None;
                            while let _serde::export::Some(__key) =
                                match _serde::de::MapAccess::next_key::<__Field>(&mut __map) {
                                    _serde::export::Ok(__val) => __val,
                                    _serde::export::Err(__err) => {
                                        return _serde::export::Err(__err);
                                    }
                                }
                            {
                                match __key {
                                    __Field::__field0 => {
                                        if _serde::export::Option::is_some(&__field0) {
                                            return _serde::export::Err(
                                                <__A::Error as _serde::de::Error>::duplicate_field(
                                                    "dev",
                                                ),
                                            );
                                        }
                                        __field0 = _serde::export::Some(
                                            match _serde::de::MapAccess::next_value::<Option<String>>(
                                                &mut __map,
                                            ) {
                                                _serde::export::Ok(__val) => __val,
                                                _serde::export::Err(__err) => {
                                                    return _serde::export::Err(__err);
                                                }
                                            },
                                        );
                                    }
                                    __Field::__field1 => {
                                        if _serde::export::Option::is_some(&__field1) {
                                            return _serde::export::Err(
                                                <__A::Error as _serde::de::Error>::duplicate_field(
                                                    "bus",
                                                ),
                                            );
                                        }
                                        __field1 = _serde::export::Some(
                                            match _serde::de::MapAccess::next_value::<Option<String>>(
                                                &mut __map,
                                            ) {
                                                _serde::export::Ok(__val) => __val,
                                                _serde::export::Err(__err) => {
                                                    return _serde::export::Err(__err);
                                                }
                                            },
                                        );
                                    }
                                    __Field::__field2 => {
                                        if _serde::export::Option::is_some(&__field2) {
                                            return _serde::export::Err(
                                                <__A::Error as _serde::de::Error>::duplicate_field(
                                                    "text",
                                                ),
                                            );
                                        }
                                        __field2 = _serde::export::Some(
                                            match _serde::de::MapAccess::next_value::<String>(
                                                &mut __map,
                                            ) {
                                                _serde::export::Ok(__val) => __val,
                                                _serde::export::Err(__err) => {
                                                    return _serde::export::Err(__err);
                                                }
                                            },
                                        );
                                    }
                                    _ => {
                                        let _ = match _serde::de::MapAccess::next_value::<
                                            _serde::de::IgnoredAny,
                                        >(
                                            &mut __map
                                        ) {
                                            _serde::export::Ok(__val) => __val,
                                            _serde::export::Err(__err) => {
                                                return _serde::export::Err(__err);
                                            }
                                        };
                                    }
                                }
                            }
                            let __field0 = match __field0 {
                                _serde::export::Some(__field0) => __field0,
                                _serde::export::None => {
                                    match _serde::private::de::missing_field("dev") {
                                        _serde::export::Ok(__val) => __val,
                                        _serde::export::Err(__err) => {
                                            return _serde::export::Err(__err);
                                        }
                                    }
                                }
                            };
                            let __field1 = match __field1 {
                                _serde::export::Some(__field1) => __field1,
                                _serde::export::None => {
                                    match _serde::private::de::missing_field("bus") {
                                        _serde::export::Ok(__val) => __val,
                                        _serde::export::Err(__err) => {
                                            return _serde::export::Err(__err);
                                        }
                                    }
                                }
                            };
                            let __field2 = match __field2 {
                                _serde::export::Some(__field2) => __field2,
                                _serde::export::None => {
                                    match _serde::private::de::missing_field("text") {
                                        _serde::export::Ok(__val) => __val,
                                        _serde::export::Err(__err) => {
                                            return _serde::export::Err(__err);
                                        }
                                    }
                                }
                            };
                            _serde::export::Ok(Target {
                                dev: __field0,
                                bus: __field1,
                                text: __field2,
                            })
                        }
                    }
                    const FIELDS: &'static [&'static str] = &["dev", "bus", "text"];
                    _serde::Deserializer::deserialize_struct(
                        __deserializer,
                        "Target",
                        FIELDS,
                        __Visitor {
                            marker: _serde::export::PhantomData::<Target>,
                            lifetime: _serde::export::PhantomData,
                        },
                    )
                }
            }
        };
        #[xml(tag = "source")]
        pub struct Source {
            #[xml(attr = "file")]
            pub file: Option<String>,
            #[xml(text)]
            text: String,
        }
        impl<'__input> strong_xml::XmlRead<'__input> for Source {
            fn from_reader(
                mut reader: &mut strong_xml::XmlReader<'__input>,
            ) -> strong_xml::XmlResult<Self> {
                use strong_xml::xmlparser::{ElementEnd, Token, Tokenizer};
                use strong_xml::XmlError;
                let mut __self_file = None;
                let __self_text;
                reader.read_till_element_start("source")?;
                while let Some((__key, __value)) = reader.find_attribute()? {
                    match __key {
                        "file" => {
                            __self_file = Some(
                                <String as std::str::FromStr>::from_str(&__value)
                                    .map_err(|e| XmlError::FromStr(e.into()))?,
                            );
                        }
                        key => {}
                    }
                }
                let __value = reader.read_text("source")?;
                __self_text = Some(
                    <String as std::str::FromStr>::from_str(&__value)
                        .map_err(|e| XmlError::FromStr(e.into()))?,
                );
                let __res = Source {
                    file: __self_file,
                    text: __self_text.ok_or(XmlError::MissingField {
                        name: "Source".to_owned(),
                        field: "text".to_owned(),
                    })?,
                };
                return Ok(__res);
            }
        }
        impl strong_xml::XmlWrite for Source {
            fn to_writer<W: std::io::Write>(
                &self,
                mut writer: &mut strong_xml::XmlWriter<W>,
            ) -> strong_xml::XmlResult<()> {
                let Source {
                    file: __self_file,
                    text: __self_text,
                } = self;
                writer.write_element_start("source")?;
                if let Some(__value) = __self_file {
                    writer.write_attribute("file", &{
                        let res = ::alloc::fmt::format(::core::fmt::Arguments::new_v1(
                            &[""],
                            &match (&__value,) {
                                (arg0,) => [::core::fmt::ArgumentV1::new(
                                    arg0,
                                    ::core::fmt::Display::fmt,
                                )],
                            },
                        ));
                        res
                    })?;
                }
                writer.write_element_end_open()?;
                let __value = &__self_text;
                writer.write_text(&{
                    let res = ::alloc::fmt::format(::core::fmt::Arguments::new_v1(
                        &[""],
                        &match (&__value,) {
                            (arg0,) => [::core::fmt::ArgumentV1::new(
                                arg0,
                                ::core::fmt::Display::fmt,
                            )],
                        },
                    ));
                    res
                })?;
                writer.write_element_end_close("source")?;
                Ok(())
            }
        }
        impl ::core::marker::StructuralPartialEq for Source {}
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::cmp::PartialEq for Source {
            #[inline]
            fn eq(&self, other: &Source) -> bool {
                match *other {
                    Source {
                        file: ref __self_1_0,
                        text: ref __self_1_1,
                    } => match *self {
                        Source {
                            file: ref __self_0_0,
                            text: ref __self_0_1,
                        } => (*__self_0_0) == (*__self_1_0) && (*__self_0_1) == (*__self_1_1),
                    },
                }
            }
            #[inline]
            fn ne(&self, other: &Source) -> bool {
                match *other {
                    Source {
                        file: ref __self_1_0,
                        text: ref __self_1_1,
                    } => match *self {
                        Source {
                            file: ref __self_0_0,
                            text: ref __self_0_1,
                        } => (*__self_0_0) != (*__self_1_0) || (*__self_0_1) != (*__self_1_1),
                    },
                }
            }
        }
        impl ::core::marker::StructuralEq for Source {}
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::cmp::Eq for Source {
            #[inline]
            #[doc(hidden)]
            fn assert_receiver_is_total_eq(&self) -> () {
                {
                    let _: ::core::cmp::AssertParamIsEq<Option<String>>;
                    let _: ::core::cmp::AssertParamIsEq<String>;
                }
            }
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::fmt::Debug for Source {
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                match *self {
                    Source {
                        file: ref __self_0_0,
                        text: ref __self_0_1,
                    } => {
                        let mut debug_trait_builder = f.debug_struct("Source");
                        let _ = debug_trait_builder.field("file", &&(*__self_0_0));
                        let _ = debug_trait_builder.field("text", &&(*__self_0_1));
                        debug_trait_builder.finish()
                    }
                }
            }
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::clone::Clone for Source {
            #[inline]
            fn clone(&self) -> Source {
                match *self {
                    Source {
                        file: ref __self_0_0,
                        text: ref __self_0_1,
                    } => Source {
                        file: ::core::clone::Clone::clone(&(*__self_0_0)),
                        text: ::core::clone::Clone::clone(&(*__self_0_1)),
                    },
                }
            }
        }
        #[doc(hidden)]
        #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
        const _: () = {
            #[allow(rust_2018_idioms, clippy::useless_attribute)]
            extern crate serde as _serde;
            #[automatically_derived]
            impl _serde::Serialize for Source {
                fn serialize<__S>(
                    &self,
                    __serializer: __S,
                ) -> _serde::export::Result<__S::Ok, __S::Error>
                where
                    __S: _serde::Serializer,
                {
                    let mut __serde_state = match _serde::Serializer::serialize_struct(
                        __serializer,
                        "Source",
                        false as usize + 1 + 1,
                    ) {
                        _serde::export::Ok(__val) => __val,
                        _serde::export::Err(__err) => {
                            return _serde::export::Err(__err);
                        }
                    };
                    match _serde::ser::SerializeStruct::serialize_field(
                        &mut __serde_state,
                        "file",
                        &self.file,
                    ) {
                        _serde::export::Ok(__val) => __val,
                        _serde::export::Err(__err) => {
                            return _serde::export::Err(__err);
                        }
                    };
                    match _serde::ser::SerializeStruct::serialize_field(
                        &mut __serde_state,
                        "text",
                        &self.text,
                    ) {
                        _serde::export::Ok(__val) => __val,
                        _serde::export::Err(__err) => {
                            return _serde::export::Err(__err);
                        }
                    };
                    _serde::ser::SerializeStruct::end(__serde_state)
                }
            }
        };
        #[doc(hidden)]
        #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
        const _: () = {
            #[allow(rust_2018_idioms, clippy::useless_attribute)]
            extern crate serde as _serde;
            #[automatically_derived]
            impl<'de> _serde::Deserialize<'de> for Source {
                fn deserialize<__D>(__deserializer: __D) -> _serde::export::Result<Self, __D::Error>
                where
                    __D: _serde::Deserializer<'de>,
                {
                    #[allow(non_camel_case_types)]
                    enum __Field {
                        __field0,
                        __field1,
                        __ignore,
                    }
                    struct __FieldVisitor;
                    impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                        type Value = __Field;
                        fn expecting(
                            &self,
                            __formatter: &mut _serde::export::Formatter,
                        ) -> _serde::export::fmt::Result {
                            _serde::export::Formatter::write_str(__formatter, "field identifier")
                        }
                        fn visit_u64<__E>(
                            self,
                            __value: u64,
                        ) -> _serde::export::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                0u64 => _serde::export::Ok(__Field::__field0),
                                1u64 => _serde::export::Ok(__Field::__field1),
                                _ => _serde::export::Err(_serde::de::Error::invalid_value(
                                    _serde::de::Unexpected::Unsigned(__value),
                                    &"field index 0 <= i < 2",
                                )),
                            }
                        }
                        fn visit_str<__E>(
                            self,
                            __value: &str,
                        ) -> _serde::export::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                "file" => _serde::export::Ok(__Field::__field0),
                                "text" => _serde::export::Ok(__Field::__field1),
                                _ => _serde::export::Ok(__Field::__ignore),
                            }
                        }
                        fn visit_bytes<__E>(
                            self,
                            __value: &[u8],
                        ) -> _serde::export::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                b"file" => _serde::export::Ok(__Field::__field0),
                                b"text" => _serde::export::Ok(__Field::__field1),
                                _ => _serde::export::Ok(__Field::__ignore),
                            }
                        }
                    }
                    impl<'de> _serde::Deserialize<'de> for __Field {
                        #[inline]
                        fn deserialize<__D>(
                            __deserializer: __D,
                        ) -> _serde::export::Result<Self, __D::Error>
                        where
                            __D: _serde::Deserializer<'de>,
                        {
                            _serde::Deserializer::deserialize_identifier(
                                __deserializer,
                                __FieldVisitor,
                            )
                        }
                    }
                    struct __Visitor<'de> {
                        marker: _serde::export::PhantomData<Source>,
                        lifetime: _serde::export::PhantomData<&'de ()>,
                    }
                    impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                        type Value = Source;
                        fn expecting(
                            &self,
                            __formatter: &mut _serde::export::Formatter,
                        ) -> _serde::export::fmt::Result {
                            _serde::export::Formatter::write_str(__formatter, "struct Source")
                        }
                        #[inline]
                        fn visit_seq<__A>(
                            self,
                            mut __seq: __A,
                        ) -> _serde::export::Result<Self::Value, __A::Error>
                        where
                            __A: _serde::de::SeqAccess<'de>,
                        {
                            let __field0 = match match _serde::de::SeqAccess::next_element::<
                                Option<String>,
                            >(&mut __seq)
                            {
                                _serde::export::Ok(__val) => __val,
                                _serde::export::Err(__err) => {
                                    return _serde::export::Err(__err);
                                }
                            } {
                                _serde::export::Some(__value) => __value,
                                _serde::export::None => {
                                    return _serde::export::Err(_serde::de::Error::invalid_length(
                                        0usize,
                                        &"struct Source with 2 elements",
                                    ));
                                }
                            };
                            let __field1 = match match _serde::de::SeqAccess::next_element::<String>(
                                &mut __seq,
                            ) {
                                _serde::export::Ok(__val) => __val,
                                _serde::export::Err(__err) => {
                                    return _serde::export::Err(__err);
                                }
                            } {
                                _serde::export::Some(__value) => __value,
                                _serde::export::None => {
                                    return _serde::export::Err(_serde::de::Error::invalid_length(
                                        1usize,
                                        &"struct Source with 2 elements",
                                    ));
                                }
                            };
                            _serde::export::Ok(Source {
                                file: __field0,
                                text: __field1,
                            })
                        }
                        #[inline]
                        fn visit_map<__A>(
                            self,
                            mut __map: __A,
                        ) -> _serde::export::Result<Self::Value, __A::Error>
                        where
                            __A: _serde::de::MapAccess<'de>,
                        {
                            let mut __field0: _serde::export::Option<Option<String>> =
                                _serde::export::None;
                            let mut __field1: _serde::export::Option<String> = _serde::export::None;
                            while let _serde::export::Some(__key) =
                                match _serde::de::MapAccess::next_key::<__Field>(&mut __map) {
                                    _serde::export::Ok(__val) => __val,
                                    _serde::export::Err(__err) => {
                                        return _serde::export::Err(__err);
                                    }
                                }
                            {
                                match __key {
                                    __Field::__field0 => {
                                        if _serde::export::Option::is_some(&__field0) {
                                            return _serde::export::Err(
                                                <__A::Error as _serde::de::Error>::duplicate_field(
                                                    "file",
                                                ),
                                            );
                                        }
                                        __field0 = _serde::export::Some(
                                            match _serde::de::MapAccess::next_value::<Option<String>>(
                                                &mut __map,
                                            ) {
                                                _serde::export::Ok(__val) => __val,
                                                _serde::export::Err(__err) => {
                                                    return _serde::export::Err(__err);
                                                }
                                            },
                                        );
                                    }
                                    __Field::__field1 => {
                                        if _serde::export::Option::is_some(&__field1) {
                                            return _serde::export::Err(
                                                <__A::Error as _serde::de::Error>::duplicate_field(
                                                    "text",
                                                ),
                                            );
                                        }
                                        __field1 = _serde::export::Some(
                                            match _serde::de::MapAccess::next_value::<String>(
                                                &mut __map,
                                            ) {
                                                _serde::export::Ok(__val) => __val,
                                                _serde::export::Err(__err) => {
                                                    return _serde::export::Err(__err);
                                                }
                                            },
                                        );
                                    }
                                    _ => {
                                        let _ = match _serde::de::MapAccess::next_value::<
                                            _serde::de::IgnoredAny,
                                        >(
                                            &mut __map
                                        ) {
                                            _serde::export::Ok(__val) => __val,
                                            _serde::export::Err(__err) => {
                                                return _serde::export::Err(__err);
                                            }
                                        };
                                    }
                                }
                            }
                            let __field0 = match __field0 {
                                _serde::export::Some(__field0) => __field0,
                                _serde::export::None => {
                                    match _serde::private::de::missing_field("file") {
                                        _serde::export::Ok(__val) => __val,
                                        _serde::export::Err(__err) => {
                                            return _serde::export::Err(__err);
                                        }
                                    }
                                }
                            };
                            let __field1 = match __field1 {
                                _serde::export::Some(__field1) => __field1,
                                _serde::export::None => {
                                    match _serde::private::de::missing_field("text") {
                                        _serde::export::Ok(__val) => __val,
                                        _serde::export::Err(__err) => {
                                            return _serde::export::Err(__err);
                                        }
                                    }
                                }
                            };
                            _serde::export::Ok(Source {
                                file: __field0,
                                text: __field1,
                            })
                        }
                    }
                    const FIELDS: &'static [&'static str] = &["file", "text"];
                    _serde::Deserializer::deserialize_struct(
                        __deserializer,
                        "Source",
                        FIELDS,
                        __Visitor {
                            marker: _serde::export::PhantomData::<Source>,
                            lifetime: _serde::export::PhantomData,
                        },
                    )
                }
            }
        };
        #[xml(tag = "memory")]
        pub struct memory {
            #[xml(attr = "unit")]
            pub unit: Unit,
            #[xml(text)]
            text: String,
        }
        impl<'__input> strong_xml::XmlRead<'__input> for memory {
            fn from_reader(
                mut reader: &mut strong_xml::XmlReader<'__input>,
            ) -> strong_xml::XmlResult<Self> {
                use strong_xml::xmlparser::{ElementEnd, Token, Tokenizer};
                use strong_xml::XmlError;
                let mut __self_unit = None;
                let __self_text;
                reader.read_till_element_start("memory")?;
                while let Some((__key, __value)) = reader.find_attribute()? {
                    match __key {
                        "unit" => {
                            __self_unit = Some(
                                <Unit as std::str::FromStr>::from_str(&__value)
                                    .map_err(|e| XmlError::FromStr(e.into()))?,
                            );
                        }
                        key => {}
                    }
                }
                let __value = reader.read_text("memory")?;
                __self_text = Some(
                    <String as std::str::FromStr>::from_str(&__value)
                        .map_err(|e| XmlError::FromStr(e.into()))?,
                );
                let __res = memory {
                    unit: __self_unit.ok_or(XmlError::MissingField {
                        name: "memory".to_owned(),
                        field: "unit".to_owned(),
                    })?,
                    text: __self_text.ok_or(XmlError::MissingField {
                        name: "memory".to_owned(),
                        field: "text".to_owned(),
                    })?,
                };
                return Ok(__res);
            }
        }
        impl strong_xml::XmlWrite for memory {
            fn to_writer<W: std::io::Write>(
                &self,
                mut writer: &mut strong_xml::XmlWriter<W>,
            ) -> strong_xml::XmlResult<()> {
                let memory {
                    unit: __self_unit,
                    text: __self_text,
                } = self;
                writer.write_element_start("memory")?;
                let __value = __self_unit;
                writer.write_attribute("unit", &{
                    let res = ::alloc::fmt::format(::core::fmt::Arguments::new_v1(
                        &[""],
                        &match (&__value,) {
                            (arg0,) => [::core::fmt::ArgumentV1::new(
                                arg0,
                                ::core::fmt::Display::fmt,
                            )],
                        },
                    ));
                    res
                })?;
                writer.write_element_end_open()?;
                let __value = &__self_text;
                writer.write_text(&{
                    let res = ::alloc::fmt::format(::core::fmt::Arguments::new_v1(
                        &[""],
                        &match (&__value,) {
                            (arg0,) => [::core::fmt::ArgumentV1::new(
                                arg0,
                                ::core::fmt::Display::fmt,
                            )],
                        },
                    ));
                    res
                })?;
                writer.write_element_end_close("memory")?;
                Ok(())
            }
        }
        impl ::core::marker::StructuralPartialEq for memory {}
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::cmp::PartialEq for memory {
            #[inline]
            fn eq(&self, other: &memory) -> bool {
                match *other {
                    memory {
                        unit: ref __self_1_0,
                        text: ref __self_1_1,
                    } => match *self {
                        memory {
                            unit: ref __self_0_0,
                            text: ref __self_0_1,
                        } => (*__self_0_0) == (*__self_1_0) && (*__self_0_1) == (*__self_1_1),
                    },
                }
            }
            #[inline]
            fn ne(&self, other: &memory) -> bool {
                match *other {
                    memory {
                        unit: ref __self_1_0,
                        text: ref __self_1_1,
                    } => match *self {
                        memory {
                            unit: ref __self_0_0,
                            text: ref __self_0_1,
                        } => (*__self_0_0) != (*__self_1_0) || (*__self_0_1) != (*__self_1_1),
                    },
                }
            }
        }
        impl ::core::marker::StructuralEq for memory {}
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::cmp::Eq for memory {
            #[inline]
            #[doc(hidden)]
            fn assert_receiver_is_total_eq(&self) -> () {
                {
                    let _: ::core::cmp::AssertParamIsEq<Unit>;
                    let _: ::core::cmp::AssertParamIsEq<String>;
                }
            }
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::fmt::Debug for memory {
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                match *self {
                    memory {
                        unit: ref __self_0_0,
                        text: ref __self_0_1,
                    } => {
                        let mut debug_trait_builder = f.debug_struct("memory");
                        let _ = debug_trait_builder.field("unit", &&(*__self_0_0));
                        let _ = debug_trait_builder.field("text", &&(*__self_0_1));
                        debug_trait_builder.finish()
                    }
                }
            }
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::clone::Clone for memory {
            #[inline]
            fn clone(&self) -> memory {
                match *self {
                    memory {
                        unit: ref __self_0_0,
                        text: ref __self_0_1,
                    } => memory {
                        unit: ::core::clone::Clone::clone(&(*__self_0_0)),
                        text: ::core::clone::Clone::clone(&(*__self_0_1)),
                    },
                }
            }
        }
        #[doc(hidden)]
        #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
        const _: () = {
            #[allow(rust_2018_idioms, clippy::useless_attribute)]
            extern crate serde as _serde;
            #[automatically_derived]
            impl _serde::Serialize for memory {
                fn serialize<__S>(
                    &self,
                    __serializer: __S,
                ) -> _serde::export::Result<__S::Ok, __S::Error>
                where
                    __S: _serde::Serializer,
                {
                    let mut __serde_state = match _serde::Serializer::serialize_struct(
                        __serializer,
                        "memory",
                        false as usize + 1 + 1,
                    ) {
                        _serde::export::Ok(__val) => __val,
                        _serde::export::Err(__err) => {
                            return _serde::export::Err(__err);
                        }
                    };
                    match _serde::ser::SerializeStruct::serialize_field(
                        &mut __serde_state,
                        "unit",
                        &self.unit,
                    ) {
                        _serde::export::Ok(__val) => __val,
                        _serde::export::Err(__err) => {
                            return _serde::export::Err(__err);
                        }
                    };
                    match _serde::ser::SerializeStruct::serialize_field(
                        &mut __serde_state,
                        "text",
                        &self.text,
                    ) {
                        _serde::export::Ok(__val) => __val,
                        _serde::export::Err(__err) => {
                            return _serde::export::Err(__err);
                        }
                    };
                    _serde::ser::SerializeStruct::end(__serde_state)
                }
            }
        };
        #[doc(hidden)]
        #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
        const _: () = {
            #[allow(rust_2018_idioms, clippy::useless_attribute)]
            extern crate serde as _serde;
            #[automatically_derived]
            impl<'de> _serde::Deserialize<'de> for memory {
                fn deserialize<__D>(__deserializer: __D) -> _serde::export::Result<Self, __D::Error>
                where
                    __D: _serde::Deserializer<'de>,
                {
                    #[allow(non_camel_case_types)]
                    enum __Field {
                        __field0,
                        __field1,
                        __ignore,
                    }
                    struct __FieldVisitor;
                    impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                        type Value = __Field;
                        fn expecting(
                            &self,
                            __formatter: &mut _serde::export::Formatter,
                        ) -> _serde::export::fmt::Result {
                            _serde::export::Formatter::write_str(__formatter, "field identifier")
                        }
                        fn visit_u64<__E>(
                            self,
                            __value: u64,
                        ) -> _serde::export::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                0u64 => _serde::export::Ok(__Field::__field0),
                                1u64 => _serde::export::Ok(__Field::__field1),
                                _ => _serde::export::Err(_serde::de::Error::invalid_value(
                                    _serde::de::Unexpected::Unsigned(__value),
                                    &"field index 0 <= i < 2",
                                )),
                            }
                        }
                        fn visit_str<__E>(
                            self,
                            __value: &str,
                        ) -> _serde::export::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                "unit" => _serde::export::Ok(__Field::__field0),
                                "text" => _serde::export::Ok(__Field::__field1),
                                _ => _serde::export::Ok(__Field::__ignore),
                            }
                        }
                        fn visit_bytes<__E>(
                            self,
                            __value: &[u8],
                        ) -> _serde::export::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                b"unit" => _serde::export::Ok(__Field::__field0),
                                b"text" => _serde::export::Ok(__Field::__field1),
                                _ => _serde::export::Ok(__Field::__ignore),
                            }
                        }
                    }
                    impl<'de> _serde::Deserialize<'de> for __Field {
                        #[inline]
                        fn deserialize<__D>(
                            __deserializer: __D,
                        ) -> _serde::export::Result<Self, __D::Error>
                        where
                            __D: _serde::Deserializer<'de>,
                        {
                            _serde::Deserializer::deserialize_identifier(
                                __deserializer,
                                __FieldVisitor,
                            )
                        }
                    }
                    struct __Visitor<'de> {
                        marker: _serde::export::PhantomData<memory>,
                        lifetime: _serde::export::PhantomData<&'de ()>,
                    }
                    impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                        type Value = memory;
                        fn expecting(
                            &self,
                            __formatter: &mut _serde::export::Formatter,
                        ) -> _serde::export::fmt::Result {
                            _serde::export::Formatter::write_str(__formatter, "struct memory")
                        }
                        #[inline]
                        fn visit_seq<__A>(
                            self,
                            mut __seq: __A,
                        ) -> _serde::export::Result<Self::Value, __A::Error>
                        where
                            __A: _serde::de::SeqAccess<'de>,
                        {
                            let __field0 =
                                match match _serde::de::SeqAccess::next_element::<Unit>(&mut __seq)
                                {
                                    _serde::export::Ok(__val) => __val,
                                    _serde::export::Err(__err) => {
                                        return _serde::export::Err(__err);
                                    }
                                } {
                                    _serde::export::Some(__value) => __value,
                                    _serde::export::None => {
                                        return _serde::export::Err(
                                            _serde::de::Error::invalid_length(
                                                0usize,
                                                &"struct memory with 2 elements",
                                            ),
                                        );
                                    }
                                };
                            let __field1 = match match _serde::de::SeqAccess::next_element::<String>(
                                &mut __seq,
                            ) {
                                _serde::export::Ok(__val) => __val,
                                _serde::export::Err(__err) => {
                                    return _serde::export::Err(__err);
                                }
                            } {
                                _serde::export::Some(__value) => __value,
                                _serde::export::None => {
                                    return _serde::export::Err(_serde::de::Error::invalid_length(
                                        1usize,
                                        &"struct memory with 2 elements",
                                    ));
                                }
                            };
                            _serde::export::Ok(memory {
                                unit: __field0,
                                text: __field1,
                            })
                        }
                        #[inline]
                        fn visit_map<__A>(
                            self,
                            mut __map: __A,
                        ) -> _serde::export::Result<Self::Value, __A::Error>
                        where
                            __A: _serde::de::MapAccess<'de>,
                        {
                            let mut __field0: _serde::export::Option<Unit> = _serde::export::None;
                            let mut __field1: _serde::export::Option<String> = _serde::export::None;
                            while let _serde::export::Some(__key) =
                                match _serde::de::MapAccess::next_key::<__Field>(&mut __map) {
                                    _serde::export::Ok(__val) => __val,
                                    _serde::export::Err(__err) => {
                                        return _serde::export::Err(__err);
                                    }
                                }
                            {
                                match __key {
                                    __Field::__field0 => {
                                        if _serde::export::Option::is_some(&__field0) {
                                            return _serde::export::Err(
                                                <__A::Error as _serde::de::Error>::duplicate_field(
                                                    "unit",
                                                ),
                                            );
                                        }
                                        __field0 = _serde::export::Some(
                                            match _serde::de::MapAccess::next_value::<Unit>(
                                                &mut __map,
                                            ) {
                                                _serde::export::Ok(__val) => __val,
                                                _serde::export::Err(__err) => {
                                                    return _serde::export::Err(__err);
                                                }
                                            },
                                        );
                                    }
                                    __Field::__field1 => {
                                        if _serde::export::Option::is_some(&__field1) {
                                            return _serde::export::Err(
                                                <__A::Error as _serde::de::Error>::duplicate_field(
                                                    "text",
                                                ),
                                            );
                                        }
                                        __field1 = _serde::export::Some(
                                            match _serde::de::MapAccess::next_value::<String>(
                                                &mut __map,
                                            ) {
                                                _serde::export::Ok(__val) => __val,
                                                _serde::export::Err(__err) => {
                                                    return _serde::export::Err(__err);
                                                }
                                            },
                                        );
                                    }
                                    _ => {
                                        let _ = match _serde::de::MapAccess::next_value::<
                                            _serde::de::IgnoredAny,
                                        >(
                                            &mut __map
                                        ) {
                                            _serde::export::Ok(__val) => __val,
                                            _serde::export::Err(__err) => {
                                                return _serde::export::Err(__err);
                                            }
                                        };
                                    }
                                }
                            }
                            let __field0 = match __field0 {
                                _serde::export::Some(__field0) => __field0,
                                _serde::export::None => {
                                    match _serde::private::de::missing_field("unit") {
                                        _serde::export::Ok(__val) => __val,
                                        _serde::export::Err(__err) => {
                                            return _serde::export::Err(__err);
                                        }
                                    }
                                }
                            };
                            let __field1 = match __field1 {
                                _serde::export::Some(__field1) => __field1,
                                _serde::export::None => {
                                    match _serde::private::de::missing_field("text") {
                                        _serde::export::Ok(__val) => __val,
                                        _serde::export::Err(__err) => {
                                            return _serde::export::Err(__err);
                                        }
                                    }
                                }
                            };
                            _serde::export::Ok(memory {
                                unit: __field0,
                                text: __field1,
                            })
                        }
                    }
                    const FIELDS: &'static [&'static str] = &["unit", "text"];
                    _serde::Deserializer::deserialize_struct(
                        __deserializer,
                        "memory",
                        FIELDS,
                        __Visitor {
                            marker: _serde::export::PhantomData::<memory>,
                            lifetime: _serde::export::PhantomData,
                        },
                    )
                }
            }
        };
        #[xml(tag = "vcpu")]
        pub struct vcpu {
            #[xml(attr = "placement")]
            pub placement: Option<String>,
            #[xml(text)]
            text: String,
        }
        impl<'__input> strong_xml::XmlRead<'__input> for vcpu {
            fn from_reader(
                mut reader: &mut strong_xml::XmlReader<'__input>,
            ) -> strong_xml::XmlResult<Self> {
                use strong_xml::xmlparser::{ElementEnd, Token, Tokenizer};
                use strong_xml::XmlError;
                let mut __self_placement = None;
                let __self_text;
                reader.read_till_element_start("vcpu")?;
                while let Some((__key, __value)) = reader.find_attribute()? {
                    match __key {
                        "placement" => {
                            __self_placement = Some(
                                <String as std::str::FromStr>::from_str(&__value)
                                    .map_err(|e| XmlError::FromStr(e.into()))?,
                            );
                        }
                        key => {}
                    }
                }
                let __value = reader.read_text("vcpu")?;
                __self_text = Some(
                    <String as std::str::FromStr>::from_str(&__value)
                        .map_err(|e| XmlError::FromStr(e.into()))?,
                );
                let __res = vcpu {
                    placement: __self_placement,
                    text: __self_text.ok_or(XmlError::MissingField {
                        name: "vcpu".to_owned(),
                        field: "text".to_owned(),
                    })?,
                };
                return Ok(__res);
            }
        }
        impl strong_xml::XmlWrite for vcpu {
            fn to_writer<W: std::io::Write>(
                &self,
                mut writer: &mut strong_xml::XmlWriter<W>,
            ) -> strong_xml::XmlResult<()> {
                let vcpu {
                    placement: __self_placement,
                    text: __self_text,
                } = self;
                writer.write_element_start("vcpu")?;
                if let Some(__value) = __self_placement {
                    writer.write_attribute("placement", &{
                        let res = ::alloc::fmt::format(::core::fmt::Arguments::new_v1(
                            &[""],
                            &match (&__value,) {
                                (arg0,) => [::core::fmt::ArgumentV1::new(
                                    arg0,
                                    ::core::fmt::Display::fmt,
                                )],
                            },
                        ));
                        res
                    })?;
                }
                writer.write_element_end_open()?;
                let __value = &__self_text;
                writer.write_text(&{
                    let res = ::alloc::fmt::format(::core::fmt::Arguments::new_v1(
                        &[""],
                        &match (&__value,) {
                            (arg0,) => [::core::fmt::ArgumentV1::new(
                                arg0,
                                ::core::fmt::Display::fmt,
                            )],
                        },
                    ));
                    res
                })?;
                writer.write_element_end_close("vcpu")?;
                Ok(())
            }
        }
        impl ::core::marker::StructuralPartialEq for vcpu {}
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::cmp::PartialEq for vcpu {
            #[inline]
            fn eq(&self, other: &vcpu) -> bool {
                match *other {
                    vcpu {
                        placement: ref __self_1_0,
                        text: ref __self_1_1,
                    } => match *self {
                        vcpu {
                            placement: ref __self_0_0,
                            text: ref __self_0_1,
                        } => (*__self_0_0) == (*__self_1_0) && (*__self_0_1) == (*__self_1_1),
                    },
                }
            }
            #[inline]
            fn ne(&self, other: &vcpu) -> bool {
                match *other {
                    vcpu {
                        placement: ref __self_1_0,
                        text: ref __self_1_1,
                    } => match *self {
                        vcpu {
                            placement: ref __self_0_0,
                            text: ref __self_0_1,
                        } => (*__self_0_0) != (*__self_1_0) || (*__self_0_1) != (*__self_1_1),
                    },
                }
            }
        }
        impl ::core::marker::StructuralEq for vcpu {}
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::cmp::Eq for vcpu {
            #[inline]
            #[doc(hidden)]
            fn assert_receiver_is_total_eq(&self) -> () {
                {
                    let _: ::core::cmp::AssertParamIsEq<Option<String>>;
                    let _: ::core::cmp::AssertParamIsEq<String>;
                }
            }
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::fmt::Debug for vcpu {
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                match *self {
                    vcpu {
                        placement: ref __self_0_0,
                        text: ref __self_0_1,
                    } => {
                        let mut debug_trait_builder = f.debug_struct("vcpu");
                        let _ = debug_trait_builder.field("placement", &&(*__self_0_0));
                        let _ = debug_trait_builder.field("text", &&(*__self_0_1));
                        debug_trait_builder.finish()
                    }
                }
            }
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::clone::Clone for vcpu {
            #[inline]
            fn clone(&self) -> vcpu {
                match *self {
                    vcpu {
                        placement: ref __self_0_0,
                        text: ref __self_0_1,
                    } => vcpu {
                        placement: ::core::clone::Clone::clone(&(*__self_0_0)),
                        text: ::core::clone::Clone::clone(&(*__self_0_1)),
                    },
                }
            }
        }
        #[doc(hidden)]
        #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
        const _: () = {
            #[allow(rust_2018_idioms, clippy::useless_attribute)]
            extern crate serde as _serde;
            #[automatically_derived]
            impl _serde::Serialize for vcpu {
                fn serialize<__S>(
                    &self,
                    __serializer: __S,
                ) -> _serde::export::Result<__S::Ok, __S::Error>
                where
                    __S: _serde::Serializer,
                {
                    let mut __serde_state = match _serde::Serializer::serialize_struct(
                        __serializer,
                        "vcpu",
                        false as usize + 1 + 1,
                    ) {
                        _serde::export::Ok(__val) => __val,
                        _serde::export::Err(__err) => {
                            return _serde::export::Err(__err);
                        }
                    };
                    match _serde::ser::SerializeStruct::serialize_field(
                        &mut __serde_state,
                        "placement",
                        &self.placement,
                    ) {
                        _serde::export::Ok(__val) => __val,
                        _serde::export::Err(__err) => {
                            return _serde::export::Err(__err);
                        }
                    };
                    match _serde::ser::SerializeStruct::serialize_field(
                        &mut __serde_state,
                        "text",
                        &self.text,
                    ) {
                        _serde::export::Ok(__val) => __val,
                        _serde::export::Err(__err) => {
                            return _serde::export::Err(__err);
                        }
                    };
                    _serde::ser::SerializeStruct::end(__serde_state)
                }
            }
        };
        #[doc(hidden)]
        #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
        const _: () = {
            #[allow(rust_2018_idioms, clippy::useless_attribute)]
            extern crate serde as _serde;
            #[automatically_derived]
            impl<'de> _serde::Deserialize<'de> for vcpu {
                fn deserialize<__D>(__deserializer: __D) -> _serde::export::Result<Self, __D::Error>
                where
                    __D: _serde::Deserializer<'de>,
                {
                    #[allow(non_camel_case_types)]
                    enum __Field {
                        __field0,
                        __field1,
                        __ignore,
                    }
                    struct __FieldVisitor;
                    impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                        type Value = __Field;
                        fn expecting(
                            &self,
                            __formatter: &mut _serde::export::Formatter,
                        ) -> _serde::export::fmt::Result {
                            _serde::export::Formatter::write_str(__formatter, "field identifier")
                        }
                        fn visit_u64<__E>(
                            self,
                            __value: u64,
                        ) -> _serde::export::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                0u64 => _serde::export::Ok(__Field::__field0),
                                1u64 => _serde::export::Ok(__Field::__field1),
                                _ => _serde::export::Err(_serde::de::Error::invalid_value(
                                    _serde::de::Unexpected::Unsigned(__value),
                                    &"field index 0 <= i < 2",
                                )),
                            }
                        }
                        fn visit_str<__E>(
                            self,
                            __value: &str,
                        ) -> _serde::export::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                "placement" => _serde::export::Ok(__Field::__field0),
                                "text" => _serde::export::Ok(__Field::__field1),
                                _ => _serde::export::Ok(__Field::__ignore),
                            }
                        }
                        fn visit_bytes<__E>(
                            self,
                            __value: &[u8],
                        ) -> _serde::export::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                b"placement" => _serde::export::Ok(__Field::__field0),
                                b"text" => _serde::export::Ok(__Field::__field1),
                                _ => _serde::export::Ok(__Field::__ignore),
                            }
                        }
                    }
                    impl<'de> _serde::Deserialize<'de> for __Field {
                        #[inline]
                        fn deserialize<__D>(
                            __deserializer: __D,
                        ) -> _serde::export::Result<Self, __D::Error>
                        where
                            __D: _serde::Deserializer<'de>,
                        {
                            _serde::Deserializer::deserialize_identifier(
                                __deserializer,
                                __FieldVisitor,
                            )
                        }
                    }
                    struct __Visitor<'de> {
                        marker: _serde::export::PhantomData<vcpu>,
                        lifetime: _serde::export::PhantomData<&'de ()>,
                    }
                    impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                        type Value = vcpu;
                        fn expecting(
                            &self,
                            __formatter: &mut _serde::export::Formatter,
                        ) -> _serde::export::fmt::Result {
                            _serde::export::Formatter::write_str(__formatter, "struct vcpu")
                        }
                        #[inline]
                        fn visit_seq<__A>(
                            self,
                            mut __seq: __A,
                        ) -> _serde::export::Result<Self::Value, __A::Error>
                        where
                            __A: _serde::de::SeqAccess<'de>,
                        {
                            let __field0 = match match _serde::de::SeqAccess::next_element::<
                                Option<String>,
                            >(&mut __seq)
                            {
                                _serde::export::Ok(__val) => __val,
                                _serde::export::Err(__err) => {
                                    return _serde::export::Err(__err);
                                }
                            } {
                                _serde::export::Some(__value) => __value,
                                _serde::export::None => {
                                    return _serde::export::Err(_serde::de::Error::invalid_length(
                                        0usize,
                                        &"struct vcpu with 2 elements",
                                    ));
                                }
                            };
                            let __field1 = match match _serde::de::SeqAccess::next_element::<String>(
                                &mut __seq,
                            ) {
                                _serde::export::Ok(__val) => __val,
                                _serde::export::Err(__err) => {
                                    return _serde::export::Err(__err);
                                }
                            } {
                                _serde::export::Some(__value) => __value,
                                _serde::export::None => {
                                    return _serde::export::Err(_serde::de::Error::invalid_length(
                                        1usize,
                                        &"struct vcpu with 2 elements",
                                    ));
                                }
                            };
                            _serde::export::Ok(vcpu {
                                placement: __field0,
                                text: __field1,
                            })
                        }
                        #[inline]
                        fn visit_map<__A>(
                            self,
                            mut __map: __A,
                        ) -> _serde::export::Result<Self::Value, __A::Error>
                        where
                            __A: _serde::de::MapAccess<'de>,
                        {
                            let mut __field0: _serde::export::Option<Option<String>> =
                                _serde::export::None;
                            let mut __field1: _serde::export::Option<String> = _serde::export::None;
                            while let _serde::export::Some(__key) =
                                match _serde::de::MapAccess::next_key::<__Field>(&mut __map) {
                                    _serde::export::Ok(__val) => __val,
                                    _serde::export::Err(__err) => {
                                        return _serde::export::Err(__err);
                                    }
                                }
                            {
                                match __key {
                                    __Field::__field0 => {
                                        if _serde::export::Option::is_some(&__field0) {
                                            return _serde::export::Err(
                                                <__A::Error as _serde::de::Error>::duplicate_field(
                                                    "placement",
                                                ),
                                            );
                                        }
                                        __field0 = _serde::export::Some(
                                            match _serde::de::MapAccess::next_value::<Option<String>>(
                                                &mut __map,
                                            ) {
                                                _serde::export::Ok(__val) => __val,
                                                _serde::export::Err(__err) => {
                                                    return _serde::export::Err(__err);
                                                }
                                            },
                                        );
                                    }
                                    __Field::__field1 => {
                                        if _serde::export::Option::is_some(&__field1) {
                                            return _serde::export::Err(
                                                <__A::Error as _serde::de::Error>::duplicate_field(
                                                    "text",
                                                ),
                                            );
                                        }
                                        __field1 = _serde::export::Some(
                                            match _serde::de::MapAccess::next_value::<String>(
                                                &mut __map,
                                            ) {
                                                _serde::export::Ok(__val) => __val,
                                                _serde::export::Err(__err) => {
                                                    return _serde::export::Err(__err);
                                                }
                                            },
                                        );
                                    }
                                    _ => {
                                        let _ = match _serde::de::MapAccess::next_value::<
                                            _serde::de::IgnoredAny,
                                        >(
                                            &mut __map
                                        ) {
                                            _serde::export::Ok(__val) => __val,
                                            _serde::export::Err(__err) => {
                                                return _serde::export::Err(__err);
                                            }
                                        };
                                    }
                                }
                            }
                            let __field0 = match __field0 {
                                _serde::export::Some(__field0) => __field0,
                                _serde::export::None => {
                                    match _serde::private::de::missing_field("placement") {
                                        _serde::export::Ok(__val) => __val,
                                        _serde::export::Err(__err) => {
                                            return _serde::export::Err(__err);
                                        }
                                    }
                                }
                            };
                            let __field1 = match __field1 {
                                _serde::export::Some(__field1) => __field1,
                                _serde::export::None => {
                                    match _serde::private::de::missing_field("text") {
                                        _serde::export::Ok(__val) => __val,
                                        _serde::export::Err(__err) => {
                                            return _serde::export::Err(__err);
                                        }
                                    }
                                }
                            };
                            _serde::export::Ok(vcpu {
                                placement: __field0,
                                text: __field1,
                            })
                        }
                    }
                    const FIELDS: &'static [&'static str] = &["placement", "text"];
                    _serde::Deserializer::deserialize_struct(
                        __deserializer,
                        "vcpu",
                        FIELDS,
                        __Visitor {
                            marker: _serde::export::PhantomData::<vcpu>,
                            lifetime: _serde::export::PhantomData,
                        },
                    )
                }
            }
        };
        #[xml(tag = "timer")]
        pub struct Timer {
            #[xml(attr = "name")]
            pub name: Option<String>,
            #[xml(attr = "tickpolicy")]
            pub tickpolicy: Option<String>,
            #[xml(attr = "present")]
            pub present: Option<String>,
            #[xml(text)]
            text: String,
        }
        impl<'__input> strong_xml::XmlRead<'__input> for Timer {
            fn from_reader(
                mut reader: &mut strong_xml::XmlReader<'__input>,
            ) -> strong_xml::XmlResult<Self> {
                use strong_xml::xmlparser::{ElementEnd, Token, Tokenizer};
                use strong_xml::XmlError;
                let mut __self_name = None;
                let mut __self_tickpolicy = None;
                let mut __self_present = None;
                let __self_text;
                reader.read_till_element_start("timer")?;
                while let Some((__key, __value)) = reader.find_attribute()? {
                    match __key {
                        "name" => {
                            __self_name = Some(
                                <String as std::str::FromStr>::from_str(&__value)
                                    .map_err(|e| XmlError::FromStr(e.into()))?,
                            );
                        }
                        "tickpolicy" => {
                            __self_tickpolicy = Some(
                                <String as std::str::FromStr>::from_str(&__value)
                                    .map_err(|e| XmlError::FromStr(e.into()))?,
                            );
                        }
                        "present" => {
                            __self_present = Some(
                                <String as std::str::FromStr>::from_str(&__value)
                                    .map_err(|e| XmlError::FromStr(e.into()))?,
                            );
                        }
                        key => {}
                    }
                }
                let __value = reader.read_text("timer")?;
                __self_text = Some(
                    <String as std::str::FromStr>::from_str(&__value)
                        .map_err(|e| XmlError::FromStr(e.into()))?,
                );
                let __res = Timer {
                    name: __self_name,
                    tickpolicy: __self_tickpolicy,
                    present: __self_present,
                    text: __self_text.ok_or(XmlError::MissingField {
                        name: "Timer".to_owned(),
                        field: "text".to_owned(),
                    })?,
                };
                return Ok(__res);
            }
        }
        impl strong_xml::XmlWrite for Timer {
            fn to_writer<W: std::io::Write>(
                &self,
                mut writer: &mut strong_xml::XmlWriter<W>,
            ) -> strong_xml::XmlResult<()> {
                let Timer {
                    name: __self_name,
                    tickpolicy: __self_tickpolicy,
                    present: __self_present,
                    text: __self_text,
                } = self;
                writer.write_element_start("timer")?;
                if let Some(__value) = __self_name {
                    writer.write_attribute("name", &{
                        let res = ::alloc::fmt::format(::core::fmt::Arguments::new_v1(
                            &[""],
                            &match (&__value,) {
                                (arg0,) => [::core::fmt::ArgumentV1::new(
                                    arg0,
                                    ::core::fmt::Display::fmt,
                                )],
                            },
                        ));
                        res
                    })?;
                }
                if let Some(__value) = __self_tickpolicy {
                    writer.write_attribute("tickpolicy", &{
                        let res = ::alloc::fmt::format(::core::fmt::Arguments::new_v1(
                            &[""],
                            &match (&__value,) {
                                (arg0,) => [::core::fmt::ArgumentV1::new(
                                    arg0,
                                    ::core::fmt::Display::fmt,
                                )],
                            },
                        ));
                        res
                    })?;
                }
                if let Some(__value) = __self_present {
                    writer.write_attribute("present", &{
                        let res = ::alloc::fmt::format(::core::fmt::Arguments::new_v1(
                            &[""],
                            &match (&__value,) {
                                (arg0,) => [::core::fmt::ArgumentV1::new(
                                    arg0,
                                    ::core::fmt::Display::fmt,
                                )],
                            },
                        ));
                        res
                    })?;
                }
                writer.write_element_end_open()?;
                let __value = &__self_text;
                writer.write_text(&{
                    let res = ::alloc::fmt::format(::core::fmt::Arguments::new_v1(
                        &[""],
                        &match (&__value,) {
                            (arg0,) => [::core::fmt::ArgumentV1::new(
                                arg0,
                                ::core::fmt::Display::fmt,
                            )],
                        },
                    ));
                    res
                })?;
                writer.write_element_end_close("timer")?;
                Ok(())
            }
        }
        impl ::core::marker::StructuralPartialEq for Timer {}
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::cmp::PartialEq for Timer {
            #[inline]
            fn eq(&self, other: &Timer) -> bool {
                match *other {
                    Timer {
                        name: ref __self_1_0,
                        tickpolicy: ref __self_1_1,
                        present: ref __self_1_2,
                        text: ref __self_1_3,
                    } => match *self {
                        Timer {
                            name: ref __self_0_0,
                            tickpolicy: ref __self_0_1,
                            present: ref __self_0_2,
                            text: ref __self_0_3,
                        } => {
                            (*__self_0_0) == (*__self_1_0)
                                && (*__self_0_1) == (*__self_1_1)
                                && (*__self_0_2) == (*__self_1_2)
                                && (*__self_0_3) == (*__self_1_3)
                        }
                    },
                }
            }
            #[inline]
            fn ne(&self, other: &Timer) -> bool {
                match *other {
                    Timer {
                        name: ref __self_1_0,
                        tickpolicy: ref __self_1_1,
                        present: ref __self_1_2,
                        text: ref __self_1_3,
                    } => match *self {
                        Timer {
                            name: ref __self_0_0,
                            tickpolicy: ref __self_0_1,
                            present: ref __self_0_2,
                            text: ref __self_0_3,
                        } => {
                            (*__self_0_0) != (*__self_1_0)
                                || (*__self_0_1) != (*__self_1_1)
                                || (*__self_0_2) != (*__self_1_2)
                                || (*__self_0_3) != (*__self_1_3)
                        }
                    },
                }
            }
        }
        impl ::core::marker::StructuralEq for Timer {}
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::cmp::Eq for Timer {
            #[inline]
            #[doc(hidden)]
            fn assert_receiver_is_total_eq(&self) -> () {
                {
                    let _: ::core::cmp::AssertParamIsEq<Option<String>>;
                    let _: ::core::cmp::AssertParamIsEq<Option<String>>;
                    let _: ::core::cmp::AssertParamIsEq<Option<String>>;
                    let _: ::core::cmp::AssertParamIsEq<String>;
                }
            }
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::fmt::Debug for Timer {
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                match *self {
                    Timer {
                        name: ref __self_0_0,
                        tickpolicy: ref __self_0_1,
                        present: ref __self_0_2,
                        text: ref __self_0_3,
                    } => {
                        let mut debug_trait_builder = f.debug_struct("Timer");
                        let _ = debug_trait_builder.field("name", &&(*__self_0_0));
                        let _ = debug_trait_builder.field("tickpolicy", &&(*__self_0_1));
                        let _ = debug_trait_builder.field("present", &&(*__self_0_2));
                        let _ = debug_trait_builder.field("text", &&(*__self_0_3));
                        debug_trait_builder.finish()
                    }
                }
            }
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::clone::Clone for Timer {
            #[inline]
            fn clone(&self) -> Timer {
                match *self {
                    Timer {
                        name: ref __self_0_0,
                        tickpolicy: ref __self_0_1,
                        present: ref __self_0_2,
                        text: ref __self_0_3,
                    } => Timer {
                        name: ::core::clone::Clone::clone(&(*__self_0_0)),
                        tickpolicy: ::core::clone::Clone::clone(&(*__self_0_1)),
                        present: ::core::clone::Clone::clone(&(*__self_0_2)),
                        text: ::core::clone::Clone::clone(&(*__self_0_3)),
                    },
                }
            }
        }
        #[doc(hidden)]
        #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
        const _: () = {
            #[allow(rust_2018_idioms, clippy::useless_attribute)]
            extern crate serde as _serde;
            #[automatically_derived]
            impl _serde::Serialize for Timer {
                fn serialize<__S>(
                    &self,
                    __serializer: __S,
                ) -> _serde::export::Result<__S::Ok, __S::Error>
                where
                    __S: _serde::Serializer,
                {
                    let mut __serde_state = match _serde::Serializer::serialize_struct(
                        __serializer,
                        "Timer",
                        false as usize + 1 + 1 + 1 + 1,
                    ) {
                        _serde::export::Ok(__val) => __val,
                        _serde::export::Err(__err) => {
                            return _serde::export::Err(__err);
                        }
                    };
                    match _serde::ser::SerializeStruct::serialize_field(
                        &mut __serde_state,
                        "name",
                        &self.name,
                    ) {
                        _serde::export::Ok(__val) => __val,
                        _serde::export::Err(__err) => {
                            return _serde::export::Err(__err);
                        }
                    };
                    match _serde::ser::SerializeStruct::serialize_field(
                        &mut __serde_state,
                        "tickpolicy",
                        &self.tickpolicy,
                    ) {
                        _serde::export::Ok(__val) => __val,
                        _serde::export::Err(__err) => {
                            return _serde::export::Err(__err);
                        }
                    };
                    match _serde::ser::SerializeStruct::serialize_field(
                        &mut __serde_state,
                        "present",
                        &self.present,
                    ) {
                        _serde::export::Ok(__val) => __val,
                        _serde::export::Err(__err) => {
                            return _serde::export::Err(__err);
                        }
                    };
                    match _serde::ser::SerializeStruct::serialize_field(
                        &mut __serde_state,
                        "text",
                        &self.text,
                    ) {
                        _serde::export::Ok(__val) => __val,
                        _serde::export::Err(__err) => {
                            return _serde::export::Err(__err);
                        }
                    };
                    _serde::ser::SerializeStruct::end(__serde_state)
                }
            }
        };
        #[doc(hidden)]
        #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
        const _: () = {
            #[allow(rust_2018_idioms, clippy::useless_attribute)]
            extern crate serde as _serde;
            #[automatically_derived]
            impl<'de> _serde::Deserialize<'de> for Timer {
                fn deserialize<__D>(__deserializer: __D) -> _serde::export::Result<Self, __D::Error>
                where
                    __D: _serde::Deserializer<'de>,
                {
                    #[allow(non_camel_case_types)]
                    enum __Field {
                        __field0,
                        __field1,
                        __field2,
                        __field3,
                        __ignore,
                    }
                    struct __FieldVisitor;
                    impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                        type Value = __Field;
                        fn expecting(
                            &self,
                            __formatter: &mut _serde::export::Formatter,
                        ) -> _serde::export::fmt::Result {
                            _serde::export::Formatter::write_str(__formatter, "field identifier")
                        }
                        fn visit_u64<__E>(
                            self,
                            __value: u64,
                        ) -> _serde::export::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                0u64 => _serde::export::Ok(__Field::__field0),
                                1u64 => _serde::export::Ok(__Field::__field1),
                                2u64 => _serde::export::Ok(__Field::__field2),
                                3u64 => _serde::export::Ok(__Field::__field3),
                                _ => _serde::export::Err(_serde::de::Error::invalid_value(
                                    _serde::de::Unexpected::Unsigned(__value),
                                    &"field index 0 <= i < 4",
                                )),
                            }
                        }
                        fn visit_str<__E>(
                            self,
                            __value: &str,
                        ) -> _serde::export::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                "name" => _serde::export::Ok(__Field::__field0),
                                "tickpolicy" => _serde::export::Ok(__Field::__field1),
                                "present" => _serde::export::Ok(__Field::__field2),
                                "text" => _serde::export::Ok(__Field::__field3),
                                _ => _serde::export::Ok(__Field::__ignore),
                            }
                        }
                        fn visit_bytes<__E>(
                            self,
                            __value: &[u8],
                        ) -> _serde::export::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                b"name" => _serde::export::Ok(__Field::__field0),
                                b"tickpolicy" => _serde::export::Ok(__Field::__field1),
                                b"present" => _serde::export::Ok(__Field::__field2),
                                b"text" => _serde::export::Ok(__Field::__field3),
                                _ => _serde::export::Ok(__Field::__ignore),
                            }
                        }
                    }
                    impl<'de> _serde::Deserialize<'de> for __Field {
                        #[inline]
                        fn deserialize<__D>(
                            __deserializer: __D,
                        ) -> _serde::export::Result<Self, __D::Error>
                        where
                            __D: _serde::Deserializer<'de>,
                        {
                            _serde::Deserializer::deserialize_identifier(
                                __deserializer,
                                __FieldVisitor,
                            )
                        }
                    }
                    struct __Visitor<'de> {
                        marker: _serde::export::PhantomData<Timer>,
                        lifetime: _serde::export::PhantomData<&'de ()>,
                    }
                    impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                        type Value = Timer;
                        fn expecting(
                            &self,
                            __formatter: &mut _serde::export::Formatter,
                        ) -> _serde::export::fmt::Result {
                            _serde::export::Formatter::write_str(__formatter, "struct Timer")
                        }
                        #[inline]
                        fn visit_seq<__A>(
                            self,
                            mut __seq: __A,
                        ) -> _serde::export::Result<Self::Value, __A::Error>
                        where
                            __A: _serde::de::SeqAccess<'de>,
                        {
                            let __field0 = match match _serde::de::SeqAccess::next_element::<
                                Option<String>,
                            >(&mut __seq)
                            {
                                _serde::export::Ok(__val) => __val,
                                _serde::export::Err(__err) => {
                                    return _serde::export::Err(__err);
                                }
                            } {
                                _serde::export::Some(__value) => __value,
                                _serde::export::None => {
                                    return _serde::export::Err(_serde::de::Error::invalid_length(
                                        0usize,
                                        &"struct Timer with 4 elements",
                                    ));
                                }
                            };
                            let __field1 = match match _serde::de::SeqAccess::next_element::<
                                Option<String>,
                            >(&mut __seq)
                            {
                                _serde::export::Ok(__val) => __val,
                                _serde::export::Err(__err) => {
                                    return _serde::export::Err(__err);
                                }
                            } {
                                _serde::export::Some(__value) => __value,
                                _serde::export::None => {
                                    return _serde::export::Err(_serde::de::Error::invalid_length(
                                        1usize,
                                        &"struct Timer with 4 elements",
                                    ));
                                }
                            };
                            let __field2 = match match _serde::de::SeqAccess::next_element::<
                                Option<String>,
                            >(&mut __seq)
                            {
                                _serde::export::Ok(__val) => __val,
                                _serde::export::Err(__err) => {
                                    return _serde::export::Err(__err);
                                }
                            } {
                                _serde::export::Some(__value) => __value,
                                _serde::export::None => {
                                    return _serde::export::Err(_serde::de::Error::invalid_length(
                                        2usize,
                                        &"struct Timer with 4 elements",
                                    ));
                                }
                            };
                            let __field3 = match match _serde::de::SeqAccess::next_element::<String>(
                                &mut __seq,
                            ) {
                                _serde::export::Ok(__val) => __val,
                                _serde::export::Err(__err) => {
                                    return _serde::export::Err(__err);
                                }
                            } {
                                _serde::export::Some(__value) => __value,
                                _serde::export::None => {
                                    return _serde::export::Err(_serde::de::Error::invalid_length(
                                        3usize,
                                        &"struct Timer with 4 elements",
                                    ));
                                }
                            };
                            _serde::export::Ok(Timer {
                                name: __field0,
                                tickpolicy: __field1,
                                present: __field2,
                                text: __field3,
                            })
                        }
                        #[inline]
                        fn visit_map<__A>(
                            self,
                            mut __map: __A,
                        ) -> _serde::export::Result<Self::Value, __A::Error>
                        where
                            __A: _serde::de::MapAccess<'de>,
                        {
                            let mut __field0: _serde::export::Option<Option<String>> =
                                _serde::export::None;
                            let mut __field1: _serde::export::Option<Option<String>> =
                                _serde::export::None;
                            let mut __field2: _serde::export::Option<Option<String>> =
                                _serde::export::None;
                            let mut __field3: _serde::export::Option<String> = _serde::export::None;
                            while let _serde::export::Some(__key) =
                                match _serde::de::MapAccess::next_key::<__Field>(&mut __map) {
                                    _serde::export::Ok(__val) => __val,
                                    _serde::export::Err(__err) => {
                                        return _serde::export::Err(__err);
                                    }
                                }
                            {
                                match __key {
                                    __Field::__field0 => {
                                        if _serde::export::Option::is_some(&__field0) {
                                            return _serde::export::Err(
                                                <__A::Error as _serde::de::Error>::duplicate_field(
                                                    "name",
                                                ),
                                            );
                                        }
                                        __field0 = _serde::export::Some(
                                            match _serde::de::MapAccess::next_value::<Option<String>>(
                                                &mut __map,
                                            ) {
                                                _serde::export::Ok(__val) => __val,
                                                _serde::export::Err(__err) => {
                                                    return _serde::export::Err(__err);
                                                }
                                            },
                                        );
                                    }
                                    __Field::__field1 => {
                                        if _serde::export::Option::is_some(&__field1) {
                                            return _serde::export::Err(
                                                <__A::Error as _serde::de::Error>::duplicate_field(
                                                    "tickpolicy",
                                                ),
                                            );
                                        }
                                        __field1 = _serde::export::Some(
                                            match _serde::de::MapAccess::next_value::<Option<String>>(
                                                &mut __map,
                                            ) {
                                                _serde::export::Ok(__val) => __val,
                                                _serde::export::Err(__err) => {
                                                    return _serde::export::Err(__err);
                                                }
                                            },
                                        );
                                    }
                                    __Field::__field2 => {
                                        if _serde::export::Option::is_some(&__field2) {
                                            return _serde::export::Err(
                                                <__A::Error as _serde::de::Error>::duplicate_field(
                                                    "present",
                                                ),
                                            );
                                        }
                                        __field2 = _serde::export::Some(
                                            match _serde::de::MapAccess::next_value::<Option<String>>(
                                                &mut __map,
                                            ) {
                                                _serde::export::Ok(__val) => __val,
                                                _serde::export::Err(__err) => {
                                                    return _serde::export::Err(__err);
                                                }
                                            },
                                        );
                                    }
                                    __Field::__field3 => {
                                        if _serde::export::Option::is_some(&__field3) {
                                            return _serde::export::Err(
                                                <__A::Error as _serde::de::Error>::duplicate_field(
                                                    "text",
                                                ),
                                            );
                                        }
                                        __field3 = _serde::export::Some(
                                            match _serde::de::MapAccess::next_value::<String>(
                                                &mut __map,
                                            ) {
                                                _serde::export::Ok(__val) => __val,
                                                _serde::export::Err(__err) => {
                                                    return _serde::export::Err(__err);
                                                }
                                            },
                                        );
                                    }
                                    _ => {
                                        let _ = match _serde::de::MapAccess::next_value::<
                                            _serde::de::IgnoredAny,
                                        >(
                                            &mut __map
                                        ) {
                                            _serde::export::Ok(__val) => __val,
                                            _serde::export::Err(__err) => {
                                                return _serde::export::Err(__err);
                                            }
                                        };
                                    }
                                }
                            }
                            let __field0 = match __field0 {
                                _serde::export::Some(__field0) => __field0,
                                _serde::export::None => {
                                    match _serde::private::de::missing_field("name") {
                                        _serde::export::Ok(__val) => __val,
                                        _serde::export::Err(__err) => {
                                            return _serde::export::Err(__err);
                                        }
                                    }
                                }
                            };
                            let __field1 = match __field1 {
                                _serde::export::Some(__field1) => __field1,
                                _serde::export::None => {
                                    match _serde::private::de::missing_field("tickpolicy") {
                                        _serde::export::Ok(__val) => __val,
                                        _serde::export::Err(__err) => {
                                            return _serde::export::Err(__err);
                                        }
                                    }
                                }
                            };
                            let __field2 = match __field2 {
                                _serde::export::Some(__field2) => __field2,
                                _serde::export::None => {
                                    match _serde::private::de::missing_field("present") {
                                        _serde::export::Ok(__val) => __val,
                                        _serde::export::Err(__err) => {
                                            return _serde::export::Err(__err);
                                        }
                                    }
                                }
                            };
                            let __field3 = match __field3 {
                                _serde::export::Some(__field3) => __field3,
                                _serde::export::None => {
                                    match _serde::private::de::missing_field("text") {
                                        _serde::export::Ok(__val) => __val,
                                        _serde::export::Err(__err) => {
                                            return _serde::export::Err(__err);
                                        }
                                    }
                                }
                            };
                            _serde::export::Ok(Timer {
                                name: __field0,
                                tickpolicy: __field1,
                                present: __field2,
                                text: __field3,
                            })
                        }
                    }
                    const FIELDS: &'static [&'static str] =
                        &["name", "tickpolicy", "present", "text"];
                    _serde::Deserializer::deserialize_struct(
                        __deserializer,
                        "Timer",
                        FIELDS,
                        __Visitor {
                            marker: _serde::export::PhantomData::<Timer>,
                            lifetime: _serde::export::PhantomData,
                        },
                    )
                }
            }
        };
        #[xml(tag = "features")]
        pub struct Features {
            #[xml(child = "acpi")]
            pub acpi: Option<acpi>,
            #[xml(child = "apic")]
            pub apic: Option<apic>,
            #[xml(child = "vmport")]
            pub vmport: Option<vmport>,
            #[xml(text)]
            text: String,
        }
        impl<'__input> strong_xml::XmlRead<'__input> for Features {
            fn from_reader(
                mut reader: &mut strong_xml::XmlReader<'__input>,
            ) -> strong_xml::XmlResult<Self> {
                use strong_xml::xmlparser::{ElementEnd, Token, Tokenizer};
                use strong_xml::XmlError;
                let mut __self_acpi = None;
                let mut __self_apic = None;
                let mut __self_vmport = None;
                let __self_text;
                reader.read_till_element_start("features")?;
                while let Some((__key, __value)) = reader.find_attribute()? {
                    match __key {
                        key => {}
                    }
                }
                let __value = reader.read_text("features")?;
                __self_text = Some(
                    <String as std::str::FromStr>::from_str(&__value)
                        .map_err(|e| XmlError::FromStr(e.into()))?,
                );
                let __res = Features {
                    acpi: __self_acpi,
                    apic: __self_apic,
                    vmport: __self_vmport,
                    text: __self_text.ok_or(XmlError::MissingField {
                        name: "Features".to_owned(),
                        field: "text".to_owned(),
                    })?,
                };
                return Ok(__res);
            }
        }
        impl strong_xml::XmlWrite for Features {
            fn to_writer<W: std::io::Write>(
                &self,
                mut writer: &mut strong_xml::XmlWriter<W>,
            ) -> strong_xml::XmlResult<()> {
                let Features {
                    acpi: __self_acpi,
                    apic: __self_apic,
                    vmport: __self_vmport,
                    text: __self_text,
                } = self;
                writer.write_element_start("features")?;
                writer.write_element_end_open()?;
                let __value = &__self_text;
                writer.write_text(&{
                    let res = ::alloc::fmt::format(::core::fmt::Arguments::new_v1(
                        &[""],
                        &match (&__value,) {
                            (arg0,) => [::core::fmt::ArgumentV1::new(
                                arg0,
                                ::core::fmt::Display::fmt,
                            )],
                        },
                    ));
                    res
                })?;
                writer.write_element_end_close("features")?;
                Ok(())
            }
        }
        impl ::core::marker::StructuralPartialEq for Features {}
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::cmp::PartialEq for Features {
            #[inline]
            fn eq(&self, other: &Features) -> bool {
                match *other {
                    Features {
                        acpi: ref __self_1_0,
                        apic: ref __self_1_1,
                        vmport: ref __self_1_2,
                        text: ref __self_1_3,
                    } => match *self {
                        Features {
                            acpi: ref __self_0_0,
                            apic: ref __self_0_1,
                            vmport: ref __self_0_2,
                            text: ref __self_0_3,
                        } => {
                            (*__self_0_0) == (*__self_1_0)
                                && (*__self_0_1) == (*__self_1_1)
                                && (*__self_0_2) == (*__self_1_2)
                                && (*__self_0_3) == (*__self_1_3)
                        }
                    },
                }
            }
            #[inline]
            fn ne(&self, other: &Features) -> bool {
                match *other {
                    Features {
                        acpi: ref __self_1_0,
                        apic: ref __self_1_1,
                        vmport: ref __self_1_2,
                        text: ref __self_1_3,
                    } => match *self {
                        Features {
                            acpi: ref __self_0_0,
                            apic: ref __self_0_1,
                            vmport: ref __self_0_2,
                            text: ref __self_0_3,
                        } => {
                            (*__self_0_0) != (*__self_1_0)
                                || (*__self_0_1) != (*__self_1_1)
                                || (*__self_0_2) != (*__self_1_2)
                                || (*__self_0_3) != (*__self_1_3)
                        }
                    },
                }
            }
        }
        impl ::core::marker::StructuralEq for Features {}
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::cmp::Eq for Features {
            #[inline]
            #[doc(hidden)]
            fn assert_receiver_is_total_eq(&self) -> () {
                {
                    let _: ::core::cmp::AssertParamIsEq<Option<acpi>>;
                    let _: ::core::cmp::AssertParamIsEq<Option<apic>>;
                    let _: ::core::cmp::AssertParamIsEq<Option<vmport>>;
                    let _: ::core::cmp::AssertParamIsEq<String>;
                }
            }
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::fmt::Debug for Features {
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                match *self {
                    Features {
                        acpi: ref __self_0_0,
                        apic: ref __self_0_1,
                        vmport: ref __self_0_2,
                        text: ref __self_0_3,
                    } => {
                        let mut debug_trait_builder = f.debug_struct("Features");
                        let _ = debug_trait_builder.field("acpi", &&(*__self_0_0));
                        let _ = debug_trait_builder.field("apic", &&(*__self_0_1));
                        let _ = debug_trait_builder.field("vmport", &&(*__self_0_2));
                        let _ = debug_trait_builder.field("text", &&(*__self_0_3));
                        debug_trait_builder.finish()
                    }
                }
            }
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::clone::Clone for Features {
            #[inline]
            fn clone(&self) -> Features {
                match *self {
                    Features {
                        acpi: ref __self_0_0,
                        apic: ref __self_0_1,
                        vmport: ref __self_0_2,
                        text: ref __self_0_3,
                    } => Features {
                        acpi: ::core::clone::Clone::clone(&(*__self_0_0)),
                        apic: ::core::clone::Clone::clone(&(*__self_0_1)),
                        vmport: ::core::clone::Clone::clone(&(*__self_0_2)),
                        text: ::core::clone::Clone::clone(&(*__self_0_3)),
                    },
                }
            }
        }
        #[doc(hidden)]
        #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
        const _: () = {
            #[allow(rust_2018_idioms, clippy::useless_attribute)]
            extern crate serde as _serde;
            #[automatically_derived]
            impl _serde::Serialize for Features {
                fn serialize<__S>(
                    &self,
                    __serializer: __S,
                ) -> _serde::export::Result<__S::Ok, __S::Error>
                where
                    __S: _serde::Serializer,
                {
                    let mut __serde_state = match _serde::Serializer::serialize_struct(
                        __serializer,
                        "Features",
                        false as usize + 1 + 1 + 1 + 1,
                    ) {
                        _serde::export::Ok(__val) => __val,
                        _serde::export::Err(__err) => {
                            return _serde::export::Err(__err);
                        }
                    };
                    match _serde::ser::SerializeStruct::serialize_field(
                        &mut __serde_state,
                        "acpi",
                        &self.acpi,
                    ) {
                        _serde::export::Ok(__val) => __val,
                        _serde::export::Err(__err) => {
                            return _serde::export::Err(__err);
                        }
                    };
                    match _serde::ser::SerializeStruct::serialize_field(
                        &mut __serde_state,
                        "apic",
                        &self.apic,
                    ) {
                        _serde::export::Ok(__val) => __val,
                        _serde::export::Err(__err) => {
                            return _serde::export::Err(__err);
                        }
                    };
                    match _serde::ser::SerializeStruct::serialize_field(
                        &mut __serde_state,
                        "vmport",
                        &self.vmport,
                    ) {
                        _serde::export::Ok(__val) => __val,
                        _serde::export::Err(__err) => {
                            return _serde::export::Err(__err);
                        }
                    };
                    match _serde::ser::SerializeStruct::serialize_field(
                        &mut __serde_state,
                        "text",
                        &self.text,
                    ) {
                        _serde::export::Ok(__val) => __val,
                        _serde::export::Err(__err) => {
                            return _serde::export::Err(__err);
                        }
                    };
                    _serde::ser::SerializeStruct::end(__serde_state)
                }
            }
        };
        #[doc(hidden)]
        #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
        const _: () = {
            #[allow(rust_2018_idioms, clippy::useless_attribute)]
            extern crate serde as _serde;
            #[automatically_derived]
            impl<'de> _serde::Deserialize<'de> for Features {
                fn deserialize<__D>(__deserializer: __D) -> _serde::export::Result<Self, __D::Error>
                where
                    __D: _serde::Deserializer<'de>,
                {
                    #[allow(non_camel_case_types)]
                    enum __Field {
                        __field0,
                        __field1,
                        __field2,
                        __field3,
                        __ignore,
                    }
                    struct __FieldVisitor;
                    impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                        type Value = __Field;
                        fn expecting(
                            &self,
                            __formatter: &mut _serde::export::Formatter,
                        ) -> _serde::export::fmt::Result {
                            _serde::export::Formatter::write_str(__formatter, "field identifier")
                        }
                        fn visit_u64<__E>(
                            self,
                            __value: u64,
                        ) -> _serde::export::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                0u64 => _serde::export::Ok(__Field::__field0),
                                1u64 => _serde::export::Ok(__Field::__field1),
                                2u64 => _serde::export::Ok(__Field::__field2),
                                3u64 => _serde::export::Ok(__Field::__field3),
                                _ => _serde::export::Err(_serde::de::Error::invalid_value(
                                    _serde::de::Unexpected::Unsigned(__value),
                                    &"field index 0 <= i < 4",
                                )),
                            }
                        }
                        fn visit_str<__E>(
                            self,
                            __value: &str,
                        ) -> _serde::export::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                "acpi" => _serde::export::Ok(__Field::__field0),
                                "apic" => _serde::export::Ok(__Field::__field1),
                                "vmport" => _serde::export::Ok(__Field::__field2),
                                "text" => _serde::export::Ok(__Field::__field3),
                                _ => _serde::export::Ok(__Field::__ignore),
                            }
                        }
                        fn visit_bytes<__E>(
                            self,
                            __value: &[u8],
                        ) -> _serde::export::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                b"acpi" => _serde::export::Ok(__Field::__field0),
                                b"apic" => _serde::export::Ok(__Field::__field1),
                                b"vmport" => _serde::export::Ok(__Field::__field2),
                                b"text" => _serde::export::Ok(__Field::__field3),
                                _ => _serde::export::Ok(__Field::__ignore),
                            }
                        }
                    }
                    impl<'de> _serde::Deserialize<'de> for __Field {
                        #[inline]
                        fn deserialize<__D>(
                            __deserializer: __D,
                        ) -> _serde::export::Result<Self, __D::Error>
                        where
                            __D: _serde::Deserializer<'de>,
                        {
                            _serde::Deserializer::deserialize_identifier(
                                __deserializer,
                                __FieldVisitor,
                            )
                        }
                    }
                    struct __Visitor<'de> {
                        marker: _serde::export::PhantomData<Features>,
                        lifetime: _serde::export::PhantomData<&'de ()>,
                    }
                    impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                        type Value = Features;
                        fn expecting(
                            &self,
                            __formatter: &mut _serde::export::Formatter,
                        ) -> _serde::export::fmt::Result {
                            _serde::export::Formatter::write_str(__formatter, "struct Features")
                        }
                        #[inline]
                        fn visit_seq<__A>(
                            self,
                            mut __seq: __A,
                        ) -> _serde::export::Result<Self::Value, __A::Error>
                        where
                            __A: _serde::de::SeqAccess<'de>,
                        {
                            let __field0 = match match _serde::de::SeqAccess::next_element::<
                                Option<acpi>,
                            >(&mut __seq)
                            {
                                _serde::export::Ok(__val) => __val,
                                _serde::export::Err(__err) => {
                                    return _serde::export::Err(__err);
                                }
                            } {
                                _serde::export::Some(__value) => __value,
                                _serde::export::None => {
                                    return _serde::export::Err(_serde::de::Error::invalid_length(
                                        0usize,
                                        &"struct Features with 4 elements",
                                    ));
                                }
                            };
                            let __field1 = match match _serde::de::SeqAccess::next_element::<
                                Option<apic>,
                            >(&mut __seq)
                            {
                                _serde::export::Ok(__val) => __val,
                                _serde::export::Err(__err) => {
                                    return _serde::export::Err(__err);
                                }
                            } {
                                _serde::export::Some(__value) => __value,
                                _serde::export::None => {
                                    return _serde::export::Err(_serde::de::Error::invalid_length(
                                        1usize,
                                        &"struct Features with 4 elements",
                                    ));
                                }
                            };
                            let __field2 = match match _serde::de::SeqAccess::next_element::<
                                Option<vmport>,
                            >(&mut __seq)
                            {
                                _serde::export::Ok(__val) => __val,
                                _serde::export::Err(__err) => {
                                    return _serde::export::Err(__err);
                                }
                            } {
                                _serde::export::Some(__value) => __value,
                                _serde::export::None => {
                                    return _serde::export::Err(_serde::de::Error::invalid_length(
                                        2usize,
                                        &"struct Features with 4 elements",
                                    ));
                                }
                            };
                            let __field3 = match match _serde::de::SeqAccess::next_element::<String>(
                                &mut __seq,
                            ) {
                                _serde::export::Ok(__val) => __val,
                                _serde::export::Err(__err) => {
                                    return _serde::export::Err(__err);
                                }
                            } {
                                _serde::export::Some(__value) => __value,
                                _serde::export::None => {
                                    return _serde::export::Err(_serde::de::Error::invalid_length(
                                        3usize,
                                        &"struct Features with 4 elements",
                                    ));
                                }
                            };
                            _serde::export::Ok(Features {
                                acpi: __field0,
                                apic: __field1,
                                vmport: __field2,
                                text: __field3,
                            })
                        }
                        #[inline]
                        fn visit_map<__A>(
                            self,
                            mut __map: __A,
                        ) -> _serde::export::Result<Self::Value, __A::Error>
                        where
                            __A: _serde::de::MapAccess<'de>,
                        {
                            let mut __field0: _serde::export::Option<Option<acpi>> =
                                _serde::export::None;
                            let mut __field1: _serde::export::Option<Option<apic>> =
                                _serde::export::None;
                            let mut __field2: _serde::export::Option<Option<vmport>> =
                                _serde::export::None;
                            let mut __field3: _serde::export::Option<String> = _serde::export::None;
                            while let _serde::export::Some(__key) =
                                match _serde::de::MapAccess::next_key::<__Field>(&mut __map) {
                                    _serde::export::Ok(__val) => __val,
                                    _serde::export::Err(__err) => {
                                        return _serde::export::Err(__err);
                                    }
                                }
                            {
                                match __key {
                                    __Field::__field0 => {
                                        if _serde::export::Option::is_some(&__field0) {
                                            return _serde::export::Err(
                                                <__A::Error as _serde::de::Error>::duplicate_field(
                                                    "acpi",
                                                ),
                                            );
                                        }
                                        __field0 = _serde::export::Some(
                                            match _serde::de::MapAccess::next_value::<Option<acpi>>(
                                                &mut __map,
                                            ) {
                                                _serde::export::Ok(__val) => __val,
                                                _serde::export::Err(__err) => {
                                                    return _serde::export::Err(__err);
                                                }
                                            },
                                        );
                                    }
                                    __Field::__field1 => {
                                        if _serde::export::Option::is_some(&__field1) {
                                            return _serde::export::Err(
                                                <__A::Error as _serde::de::Error>::duplicate_field(
                                                    "apic",
                                                ),
                                            );
                                        }
                                        __field1 = _serde::export::Some(
                                            match _serde::de::MapAccess::next_value::<Option<apic>>(
                                                &mut __map,
                                            ) {
                                                _serde::export::Ok(__val) => __val,
                                                _serde::export::Err(__err) => {
                                                    return _serde::export::Err(__err);
                                                }
                                            },
                                        );
                                    }
                                    __Field::__field2 => {
                                        if _serde::export::Option::is_some(&__field2) {
                                            return _serde::export::Err(
                                                <__A::Error as _serde::de::Error>::duplicate_field(
                                                    "vmport",
                                                ),
                                            );
                                        }
                                        __field2 = _serde::export::Some(
                                            match _serde::de::MapAccess::next_value::<Option<vmport>>(
                                                &mut __map,
                                            ) {
                                                _serde::export::Ok(__val) => __val,
                                                _serde::export::Err(__err) => {
                                                    return _serde::export::Err(__err);
                                                }
                                            },
                                        );
                                    }
                                    __Field::__field3 => {
                                        if _serde::export::Option::is_some(&__field3) {
                                            return _serde::export::Err(
                                                <__A::Error as _serde::de::Error>::duplicate_field(
                                                    "text",
                                                ),
                                            );
                                        }
                                        __field3 = _serde::export::Some(
                                            match _serde::de::MapAccess::next_value::<String>(
                                                &mut __map,
                                            ) {
                                                _serde::export::Ok(__val) => __val,
                                                _serde::export::Err(__err) => {
                                                    return _serde::export::Err(__err);
                                                }
                                            },
                                        );
                                    }
                                    _ => {
                                        let _ = match _serde::de::MapAccess::next_value::<
                                            _serde::de::IgnoredAny,
                                        >(
                                            &mut __map
                                        ) {
                                            _serde::export::Ok(__val) => __val,
                                            _serde::export::Err(__err) => {
                                                return _serde::export::Err(__err);
                                            }
                                        };
                                    }
                                }
                            }
                            let __field0 = match __field0 {
                                _serde::export::Some(__field0) => __field0,
                                _serde::export::None => {
                                    match _serde::private::de::missing_field("acpi") {
                                        _serde::export::Ok(__val) => __val,
                                        _serde::export::Err(__err) => {
                                            return _serde::export::Err(__err);
                                        }
                                    }
                                }
                            };
                            let __field1 = match __field1 {
                                _serde::export::Some(__field1) => __field1,
                                _serde::export::None => {
                                    match _serde::private::de::missing_field("apic") {
                                        _serde::export::Ok(__val) => __val,
                                        _serde::export::Err(__err) => {
                                            return _serde::export::Err(__err);
                                        }
                                    }
                                }
                            };
                            let __field2 = match __field2 {
                                _serde::export::Some(__field2) => __field2,
                                _serde::export::None => {
                                    match _serde::private::de::missing_field("vmport") {
                                        _serde::export::Ok(__val) => __val,
                                        _serde::export::Err(__err) => {
                                            return _serde::export::Err(__err);
                                        }
                                    }
                                }
                            };
                            let __field3 = match __field3 {
                                _serde::export::Some(__field3) => __field3,
                                _serde::export::None => {
                                    match _serde::private::de::missing_field("text") {
                                        _serde::export::Ok(__val) => __val,
                                        _serde::export::Err(__err) => {
                                            return _serde::export::Err(__err);
                                        }
                                    }
                                }
                            };
                            _serde::export::Ok(Features {
                                acpi: __field0,
                                apic: __field1,
                                vmport: __field2,
                                text: __field3,
                            })
                        }
                    }
                    const FIELDS: &'static [&'static str] = &["acpi", "apic", "vmport", "text"];
                    _serde::Deserializer::deserialize_struct(
                        __deserializer,
                        "Features",
                        FIELDS,
                        __Visitor {
                            marker: _serde::export::PhantomData::<Features>,
                            lifetime: _serde::export::PhantomData,
                        },
                    )
                }
            }
        };
        #[xml(tag = "pm")]
        pub struct PM {
            #[xml(child = "suspend-to-mem")]
            pub suspend_to_mem: Option<SuspendToMem>,
            #[xml(child = "suspend-to-disk")]
            pub suspend_to_disk: Option<SuspendToDisk>,
            #[xml(text)]
            text: String,
        }
        impl<'__input> strong_xml::XmlRead<'__input> for PM {
            fn from_reader(
                mut reader: &mut strong_xml::XmlReader<'__input>,
            ) -> strong_xml::XmlResult<Self> {
                use strong_xml::xmlparser::{ElementEnd, Token, Tokenizer};
                use strong_xml::XmlError;
                let mut __self_suspend_to_mem = None;
                let mut __self_suspend_to_disk = None;
                let __self_text;
                reader.read_till_element_start("pm")?;
                while let Some((__key, __value)) = reader.find_attribute()? {
                    match __key {
                        key => {}
                    }
                }
                let __value = reader.read_text("pm")?;
                __self_text = Some(
                    <String as std::str::FromStr>::from_str(&__value)
                        .map_err(|e| XmlError::FromStr(e.into()))?,
                );
                let __res = PM {
                    suspend_to_mem: __self_suspend_to_mem,
                    suspend_to_disk: __self_suspend_to_disk,
                    text: __self_text.ok_or(XmlError::MissingField {
                        name: "PM".to_owned(),
                        field: "text".to_owned(),
                    })?,
                };
                return Ok(__res);
            }
        }
        impl strong_xml::XmlWrite for PM {
            fn to_writer<W: std::io::Write>(
                &self,
                mut writer: &mut strong_xml::XmlWriter<W>,
            ) -> strong_xml::XmlResult<()> {
                let PM {
                    suspend_to_mem: __self_suspend_to_mem,
                    suspend_to_disk: __self_suspend_to_disk,
                    text: __self_text,
                } = self;
                writer.write_element_start("pm")?;
                writer.write_element_end_open()?;
                let __value = &__self_text;
                writer.write_text(&{
                    let res = ::alloc::fmt::format(::core::fmt::Arguments::new_v1(
                        &[""],
                        &match (&__value,) {
                            (arg0,) => [::core::fmt::ArgumentV1::new(
                                arg0,
                                ::core::fmt::Display::fmt,
                            )],
                        },
                    ));
                    res
                })?;
                writer.write_element_end_close("pm")?;
                Ok(())
            }
        }
        impl ::core::marker::StructuralPartialEq for PM {}
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::cmp::PartialEq for PM {
            #[inline]
            fn eq(&self, other: &PM) -> bool {
                match *other {
                    PM {
                        suspend_to_mem: ref __self_1_0,
                        suspend_to_disk: ref __self_1_1,
                        text: ref __self_1_2,
                    } => match *self {
                        PM {
                            suspend_to_mem: ref __self_0_0,
                            suspend_to_disk: ref __self_0_1,
                            text: ref __self_0_2,
                        } => {
                            (*__self_0_0) == (*__self_1_0)
                                && (*__self_0_1) == (*__self_1_1)
                                && (*__self_0_2) == (*__self_1_2)
                        }
                    },
                }
            }
            #[inline]
            fn ne(&self, other: &PM) -> bool {
                match *other {
                    PM {
                        suspend_to_mem: ref __self_1_0,
                        suspend_to_disk: ref __self_1_1,
                        text: ref __self_1_2,
                    } => match *self {
                        PM {
                            suspend_to_mem: ref __self_0_0,
                            suspend_to_disk: ref __self_0_1,
                            text: ref __self_0_2,
                        } => {
                            (*__self_0_0) != (*__self_1_0)
                                || (*__self_0_1) != (*__self_1_1)
                                || (*__self_0_2) != (*__self_1_2)
                        }
                    },
                }
            }
        }
        impl ::core::marker::StructuralEq for PM {}
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::cmp::Eq for PM {
            #[inline]
            #[doc(hidden)]
            fn assert_receiver_is_total_eq(&self) -> () {
                {
                    let _: ::core::cmp::AssertParamIsEq<Option<SuspendToMem>>;
                    let _: ::core::cmp::AssertParamIsEq<Option<SuspendToDisk>>;
                    let _: ::core::cmp::AssertParamIsEq<String>;
                }
            }
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::fmt::Debug for PM {
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                match *self {
                    PM {
                        suspend_to_mem: ref __self_0_0,
                        suspend_to_disk: ref __self_0_1,
                        text: ref __self_0_2,
                    } => {
                        let mut debug_trait_builder = f.debug_struct("PM");
                        let _ = debug_trait_builder.field("suspend_to_mem", &&(*__self_0_0));
                        let _ = debug_trait_builder.field("suspend_to_disk", &&(*__self_0_1));
                        let _ = debug_trait_builder.field("text", &&(*__self_0_2));
                        debug_trait_builder.finish()
                    }
                }
            }
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::clone::Clone for PM {
            #[inline]
            fn clone(&self) -> PM {
                match *self {
                    PM {
                        suspend_to_mem: ref __self_0_0,
                        suspend_to_disk: ref __self_0_1,
                        text: ref __self_0_2,
                    } => PM {
                        suspend_to_mem: ::core::clone::Clone::clone(&(*__self_0_0)),
                        suspend_to_disk: ::core::clone::Clone::clone(&(*__self_0_1)),
                        text: ::core::clone::Clone::clone(&(*__self_0_2)),
                    },
                }
            }
        }
        #[doc(hidden)]
        #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
        const _: () = {
            #[allow(rust_2018_idioms, clippy::useless_attribute)]
            extern crate serde as _serde;
            #[automatically_derived]
            impl _serde::Serialize for PM {
                fn serialize<__S>(
                    &self,
                    __serializer: __S,
                ) -> _serde::export::Result<__S::Ok, __S::Error>
                where
                    __S: _serde::Serializer,
                {
                    let mut __serde_state = match _serde::Serializer::serialize_struct(
                        __serializer,
                        "PM",
                        false as usize + 1 + 1 + 1,
                    ) {
                        _serde::export::Ok(__val) => __val,
                        _serde::export::Err(__err) => {
                            return _serde::export::Err(__err);
                        }
                    };
                    match _serde::ser::SerializeStruct::serialize_field(
                        &mut __serde_state,
                        "suspend_to_mem",
                        &self.suspend_to_mem,
                    ) {
                        _serde::export::Ok(__val) => __val,
                        _serde::export::Err(__err) => {
                            return _serde::export::Err(__err);
                        }
                    };
                    match _serde::ser::SerializeStruct::serialize_field(
                        &mut __serde_state,
                        "suspend_to_disk",
                        &self.suspend_to_disk,
                    ) {
                        _serde::export::Ok(__val) => __val,
                        _serde::export::Err(__err) => {
                            return _serde::export::Err(__err);
                        }
                    };
                    match _serde::ser::SerializeStruct::serialize_field(
                        &mut __serde_state,
                        "text",
                        &self.text,
                    ) {
                        _serde::export::Ok(__val) => __val,
                        _serde::export::Err(__err) => {
                            return _serde::export::Err(__err);
                        }
                    };
                    _serde::ser::SerializeStruct::end(__serde_state)
                }
            }
        };
        #[doc(hidden)]
        #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
        const _: () = {
            #[allow(rust_2018_idioms, clippy::useless_attribute)]
            extern crate serde as _serde;
            #[automatically_derived]
            impl<'de> _serde::Deserialize<'de> for PM {
                fn deserialize<__D>(__deserializer: __D) -> _serde::export::Result<Self, __D::Error>
                where
                    __D: _serde::Deserializer<'de>,
                {
                    #[allow(non_camel_case_types)]
                    enum __Field {
                        __field0,
                        __field1,
                        __field2,
                        __ignore,
                    }
                    struct __FieldVisitor;
                    impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                        type Value = __Field;
                        fn expecting(
                            &self,
                            __formatter: &mut _serde::export::Formatter,
                        ) -> _serde::export::fmt::Result {
                            _serde::export::Formatter::write_str(__formatter, "field identifier")
                        }
                        fn visit_u64<__E>(
                            self,
                            __value: u64,
                        ) -> _serde::export::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                0u64 => _serde::export::Ok(__Field::__field0),
                                1u64 => _serde::export::Ok(__Field::__field1),
                                2u64 => _serde::export::Ok(__Field::__field2),
                                _ => _serde::export::Err(_serde::de::Error::invalid_value(
                                    _serde::de::Unexpected::Unsigned(__value),
                                    &"field index 0 <= i < 3",
                                )),
                            }
                        }
                        fn visit_str<__E>(
                            self,
                            __value: &str,
                        ) -> _serde::export::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                "suspend_to_mem" => _serde::export::Ok(__Field::__field0),
                                "suspend_to_disk" => _serde::export::Ok(__Field::__field1),
                                "text" => _serde::export::Ok(__Field::__field2),
                                _ => _serde::export::Ok(__Field::__ignore),
                            }
                        }
                        fn visit_bytes<__E>(
                            self,
                            __value: &[u8],
                        ) -> _serde::export::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                b"suspend_to_mem" => _serde::export::Ok(__Field::__field0),
                                b"suspend_to_disk" => _serde::export::Ok(__Field::__field1),
                                b"text" => _serde::export::Ok(__Field::__field2),
                                _ => _serde::export::Ok(__Field::__ignore),
                            }
                        }
                    }
                    impl<'de> _serde::Deserialize<'de> for __Field {
                        #[inline]
                        fn deserialize<__D>(
                            __deserializer: __D,
                        ) -> _serde::export::Result<Self, __D::Error>
                        where
                            __D: _serde::Deserializer<'de>,
                        {
                            _serde::Deserializer::deserialize_identifier(
                                __deserializer,
                                __FieldVisitor,
                            )
                        }
                    }
                    struct __Visitor<'de> {
                        marker: _serde::export::PhantomData<PM>,
                        lifetime: _serde::export::PhantomData<&'de ()>,
                    }
                    impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                        type Value = PM;
                        fn expecting(
                            &self,
                            __formatter: &mut _serde::export::Formatter,
                        ) -> _serde::export::fmt::Result {
                            _serde::export::Formatter::write_str(__formatter, "struct PM")
                        }
                        #[inline]
                        fn visit_seq<__A>(
                            self,
                            mut __seq: __A,
                        ) -> _serde::export::Result<Self::Value, __A::Error>
                        where
                            __A: _serde::de::SeqAccess<'de>,
                        {
                            let __field0 = match match _serde::de::SeqAccess::next_element::<
                                Option<SuspendToMem>,
                            >(&mut __seq)
                            {
                                _serde::export::Ok(__val) => __val,
                                _serde::export::Err(__err) => {
                                    return _serde::export::Err(__err);
                                }
                            } {
                                _serde::export::Some(__value) => __value,
                                _serde::export::None => {
                                    return _serde::export::Err(_serde::de::Error::invalid_length(
                                        0usize,
                                        &"struct PM with 3 elements",
                                    ));
                                }
                            };
                            let __field1 = match match _serde::de::SeqAccess::next_element::<
                                Option<SuspendToDisk>,
                            >(&mut __seq)
                            {
                                _serde::export::Ok(__val) => __val,
                                _serde::export::Err(__err) => {
                                    return _serde::export::Err(__err);
                                }
                            } {
                                _serde::export::Some(__value) => __value,
                                _serde::export::None => {
                                    return _serde::export::Err(_serde::de::Error::invalid_length(
                                        1usize,
                                        &"struct PM with 3 elements",
                                    ));
                                }
                            };
                            let __field2 = match match _serde::de::SeqAccess::next_element::<String>(
                                &mut __seq,
                            ) {
                                _serde::export::Ok(__val) => __val,
                                _serde::export::Err(__err) => {
                                    return _serde::export::Err(__err);
                                }
                            } {
                                _serde::export::Some(__value) => __value,
                                _serde::export::None => {
                                    return _serde::export::Err(_serde::de::Error::invalid_length(
                                        2usize,
                                        &"struct PM with 3 elements",
                                    ));
                                }
                            };
                            _serde::export::Ok(PM {
                                suspend_to_mem: __field0,
                                suspend_to_disk: __field1,
                                text: __field2,
                            })
                        }
                        #[inline]
                        fn visit_map<__A>(
                            self,
                            mut __map: __A,
                        ) -> _serde::export::Result<Self::Value, __A::Error>
                        where
                            __A: _serde::de::MapAccess<'de>,
                        {
                            let mut __field0: _serde::export::Option<Option<SuspendToMem>> =
                                _serde::export::None;
                            let mut __field1: _serde::export::Option<Option<SuspendToDisk>> =
                                _serde::export::None;
                            let mut __field2: _serde::export::Option<String> = _serde::export::None;
                            while let _serde::export::Some(__key) =
                                match _serde::de::MapAccess::next_key::<__Field>(&mut __map) {
                                    _serde::export::Ok(__val) => __val,
                                    _serde::export::Err(__err) => {
                                        return _serde::export::Err(__err);
                                    }
                                }
                            {
                                match __key {
                                    __Field::__field0 => {
                                        if _serde::export::Option::is_some(&__field0) {
                                            return _serde::export::Err(
                                                <__A::Error as _serde::de::Error>::duplicate_field(
                                                    "suspend_to_mem",
                                                ),
                                            );
                                        }
                                        __field0 = _serde::export::Some(
                                            match _serde::de::MapAccess::next_value::<
                                                Option<SuspendToMem>,
                                            >(
                                                &mut __map
                                            ) {
                                                _serde::export::Ok(__val) => __val,
                                                _serde::export::Err(__err) => {
                                                    return _serde::export::Err(__err);
                                                }
                                            },
                                        );
                                    }
                                    __Field::__field1 => {
                                        if _serde::export::Option::is_some(&__field1) {
                                            return _serde::export::Err(
                                                <__A::Error as _serde::de::Error>::duplicate_field(
                                                    "suspend_to_disk",
                                                ),
                                            );
                                        }
                                        __field1 = _serde::export::Some(
                                            match _serde::de::MapAccess::next_value::<
                                                Option<SuspendToDisk>,
                                            >(
                                                &mut __map
                                            ) {
                                                _serde::export::Ok(__val) => __val,
                                                _serde::export::Err(__err) => {
                                                    return _serde::export::Err(__err);
                                                }
                                            },
                                        );
                                    }
                                    __Field::__field2 => {
                                        if _serde::export::Option::is_some(&__field2) {
                                            return _serde::export::Err(
                                                <__A::Error as _serde::de::Error>::duplicate_field(
                                                    "text",
                                                ),
                                            );
                                        }
                                        __field2 = _serde::export::Some(
                                            match _serde::de::MapAccess::next_value::<String>(
                                                &mut __map,
                                            ) {
                                                _serde::export::Ok(__val) => __val,
                                                _serde::export::Err(__err) => {
                                                    return _serde::export::Err(__err);
                                                }
                                            },
                                        );
                                    }
                                    _ => {
                                        let _ = match _serde::de::MapAccess::next_value::<
                                            _serde::de::IgnoredAny,
                                        >(
                                            &mut __map
                                        ) {
                                            _serde::export::Ok(__val) => __val,
                                            _serde::export::Err(__err) => {
                                                return _serde::export::Err(__err);
                                            }
                                        };
                                    }
                                }
                            }
                            let __field0 = match __field0 {
                                _serde::export::Some(__field0) => __field0,
                                _serde::export::None => {
                                    match _serde::private::de::missing_field("suspend_to_mem") {
                                        _serde::export::Ok(__val) => __val,
                                        _serde::export::Err(__err) => {
                                            return _serde::export::Err(__err);
                                        }
                                    }
                                }
                            };
                            let __field1 = match __field1 {
                                _serde::export::Some(__field1) => __field1,
                                _serde::export::None => {
                                    match _serde::private::de::missing_field("suspend_to_disk") {
                                        _serde::export::Ok(__val) => __val,
                                        _serde::export::Err(__err) => {
                                            return _serde::export::Err(__err);
                                        }
                                    }
                                }
                            };
                            let __field2 = match __field2 {
                                _serde::export::Some(__field2) => __field2,
                                _serde::export::None => {
                                    match _serde::private::de::missing_field("text") {
                                        _serde::export::Ok(__val) => __val,
                                        _serde::export::Err(__err) => {
                                            return _serde::export::Err(__err);
                                        }
                                    }
                                }
                            };
                            _serde::export::Ok(PM {
                                suspend_to_mem: __field0,
                                suspend_to_disk: __field1,
                                text: __field2,
                            })
                        }
                    }
                    const FIELDS: &'static [&'static str] =
                        &["suspend_to_mem", "suspend_to_disk", "text"];
                    _serde::Deserializer::deserialize_struct(
                        __deserializer,
                        "PM",
                        FIELDS,
                        __Visitor {
                            marker: _serde::export::PhantomData::<PM>,
                            lifetime: _serde::export::PhantomData,
                        },
                    )
                }
            }
        };
        #[xml(tag = "clock")]
        pub struct Clock {
            #[xml(attr = "offset")]
            pub offset: Option<String>,
            #[xml(child = "timer")]
            pub timers: Vec<Timer>,
        }
        impl strong_xml::XmlWrite for Clock {
            fn to_writer<W: std::io::Write>(
                &self,
                mut writer: &mut strong_xml::XmlWriter<W>,
            ) -> strong_xml::XmlResult<()> {
                let Clock {
                    offset: __self_offset,
                    timers: __self_timers,
                } = self;
                writer.write_element_start("clock")?;
                if let Some(__value) = __self_offset {
                    writer.write_attribute("offset", &{
                        let res = ::alloc::fmt::format(::core::fmt::Arguments::new_v1(
                            &[""],
                            &match (&__value,) {
                                (arg0,) => [::core::fmt::ArgumentV1::new(
                                    arg0,
                                    ::core::fmt::Display::fmt,
                                )],
                            },
                        ));
                        res
                    })?;
                }
                if true && __self_timers.is_empty() {
                    writer.write_element_end_empty()?;
                } else {
                    writer.write_element_end_open()?;
                    for ele in __self_timers {
                        ele.to_writer(&mut writer)?;
                    }
                    writer.write_element_end_close("clock")?;
                }
                Ok(())
            }
        }
        impl<'__input> strong_xml::XmlRead<'__input> for Clock {
            fn from_reader(
                mut reader: &mut strong_xml::XmlReader<'__input>,
            ) -> strong_xml::XmlResult<Self> {
                use strong_xml::xmlparser::{ElementEnd, Token, Tokenizer};
                use strong_xml::XmlError;
                let mut __self_offset = None;
                let mut __self_timers = Vec::new();
                reader.read_till_element_start("clock")?;
                while let Some((__key, __value)) = reader.find_attribute()? {
                    match __key {
                        "offset" => {
                            __self_offset = Some(
                                <String as std::str::FromStr>::from_str(&__value)
                                    .map_err(|e| XmlError::FromStr(e.into()))?,
                            );
                        }
                        key => {}
                    }
                }
                if let Token::ElementEnd {
                    end: ElementEnd::Empty,
                    ..
                } = reader.next().unwrap()?
                {
                    let __res = Clock {
                        offset: __self_offset,
                        timers: __self_timers,
                    };
                    return Ok(__res);
                }
                while let Some(__tag) = reader.find_element_start(Some("clock"))? {
                    match __tag {
                        "timer" => {
                            __self_timers
                                .push(<Timer as strong_xml::XmlRead>::from_reader(reader)?);
                        }
                        tag => {
                            reader.next();
                            reader.read_to_end(tag)?;
                        }
                    }
                }
                let __res = Clock {
                    offset: __self_offset,
                    timers: __self_timers,
                };
                return Ok(__res);
            }
        }
        impl ::core::marker::StructuralPartialEq for Clock {}
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::cmp::PartialEq for Clock {
            #[inline]
            fn eq(&self, other: &Clock) -> bool {
                match *other {
                    Clock {
                        offset: ref __self_1_0,
                        timers: ref __self_1_1,
                    } => match *self {
                        Clock {
                            offset: ref __self_0_0,
                            timers: ref __self_0_1,
                        } => (*__self_0_0) == (*__self_1_0) && (*__self_0_1) == (*__self_1_1),
                    },
                }
            }
            #[inline]
            fn ne(&self, other: &Clock) -> bool {
                match *other {
                    Clock {
                        offset: ref __self_1_0,
                        timers: ref __self_1_1,
                    } => match *self {
                        Clock {
                            offset: ref __self_0_0,
                            timers: ref __self_0_1,
                        } => (*__self_0_0) != (*__self_1_0) || (*__self_0_1) != (*__self_1_1),
                    },
                }
            }
        }
        impl ::core::marker::StructuralEq for Clock {}
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::cmp::Eq for Clock {
            #[inline]
            #[doc(hidden)]
            fn assert_receiver_is_total_eq(&self) -> () {
                {
                    let _: ::core::cmp::AssertParamIsEq<Option<String>>;
                    let _: ::core::cmp::AssertParamIsEq<Vec<Timer>>;
                }
            }
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::fmt::Debug for Clock {
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                match *self {
                    Clock {
                        offset: ref __self_0_0,
                        timers: ref __self_0_1,
                    } => {
                        let mut debug_trait_builder = f.debug_struct("Clock");
                        let _ = debug_trait_builder.field("offset", &&(*__self_0_0));
                        let _ = debug_trait_builder.field("timers", &&(*__self_0_1));
                        debug_trait_builder.finish()
                    }
                }
            }
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::clone::Clone for Clock {
            #[inline]
            fn clone(&self) -> Clock {
                match *self {
                    Clock {
                        offset: ref __self_0_0,
                        timers: ref __self_0_1,
                    } => Clock {
                        offset: ::core::clone::Clone::clone(&(*__self_0_0)),
                        timers: ::core::clone::Clone::clone(&(*__self_0_1)),
                    },
                }
            }
        }
        #[doc(hidden)]
        #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
        const _: () = {
            #[allow(rust_2018_idioms, clippy::useless_attribute)]
            extern crate serde as _serde;
            #[automatically_derived]
            impl _serde::Serialize for Clock {
                fn serialize<__S>(
                    &self,
                    __serializer: __S,
                ) -> _serde::export::Result<__S::Ok, __S::Error>
                where
                    __S: _serde::Serializer,
                {
                    let mut __serde_state = match _serde::Serializer::serialize_struct(
                        __serializer,
                        "Clock",
                        false as usize + 1 + 1,
                    ) {
                        _serde::export::Ok(__val) => __val,
                        _serde::export::Err(__err) => {
                            return _serde::export::Err(__err);
                        }
                    };
                    match _serde::ser::SerializeStruct::serialize_field(
                        &mut __serde_state,
                        "offset",
                        &self.offset,
                    ) {
                        _serde::export::Ok(__val) => __val,
                        _serde::export::Err(__err) => {
                            return _serde::export::Err(__err);
                        }
                    };
                    match _serde::ser::SerializeStruct::serialize_field(
                        &mut __serde_state,
                        "timers",
                        &self.timers,
                    ) {
                        _serde::export::Ok(__val) => __val,
                        _serde::export::Err(__err) => {
                            return _serde::export::Err(__err);
                        }
                    };
                    _serde::ser::SerializeStruct::end(__serde_state)
                }
            }
        };
        #[doc(hidden)]
        #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
        const _: () = {
            #[allow(rust_2018_idioms, clippy::useless_attribute)]
            extern crate serde as _serde;
            #[automatically_derived]
            impl<'de> _serde::Deserialize<'de> for Clock {
                fn deserialize<__D>(__deserializer: __D) -> _serde::export::Result<Self, __D::Error>
                where
                    __D: _serde::Deserializer<'de>,
                {
                    #[allow(non_camel_case_types)]
                    enum __Field {
                        __field0,
                        __field1,
                        __ignore,
                    }
                    struct __FieldVisitor;
                    impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                        type Value = __Field;
                        fn expecting(
                            &self,
                            __formatter: &mut _serde::export::Formatter,
                        ) -> _serde::export::fmt::Result {
                            _serde::export::Formatter::write_str(__formatter, "field identifier")
                        }
                        fn visit_u64<__E>(
                            self,
                            __value: u64,
                        ) -> _serde::export::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                0u64 => _serde::export::Ok(__Field::__field0),
                                1u64 => _serde::export::Ok(__Field::__field1),
                                _ => _serde::export::Err(_serde::de::Error::invalid_value(
                                    _serde::de::Unexpected::Unsigned(__value),
                                    &"field index 0 <= i < 2",
                                )),
                            }
                        }
                        fn visit_str<__E>(
                            self,
                            __value: &str,
                        ) -> _serde::export::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                "offset" => _serde::export::Ok(__Field::__field0),
                                "timers" => _serde::export::Ok(__Field::__field1),
                                _ => _serde::export::Ok(__Field::__ignore),
                            }
                        }
                        fn visit_bytes<__E>(
                            self,
                            __value: &[u8],
                        ) -> _serde::export::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                b"offset" => _serde::export::Ok(__Field::__field0),
                                b"timers" => _serde::export::Ok(__Field::__field1),
                                _ => _serde::export::Ok(__Field::__ignore),
                            }
                        }
                    }
                    impl<'de> _serde::Deserialize<'de> for __Field {
                        #[inline]
                        fn deserialize<__D>(
                            __deserializer: __D,
                        ) -> _serde::export::Result<Self, __D::Error>
                        where
                            __D: _serde::Deserializer<'de>,
                        {
                            _serde::Deserializer::deserialize_identifier(
                                __deserializer,
                                __FieldVisitor,
                            )
                        }
                    }
                    struct __Visitor<'de> {
                        marker: _serde::export::PhantomData<Clock>,
                        lifetime: _serde::export::PhantomData<&'de ()>,
                    }
                    impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                        type Value = Clock;
                        fn expecting(
                            &self,
                            __formatter: &mut _serde::export::Formatter,
                        ) -> _serde::export::fmt::Result {
                            _serde::export::Formatter::write_str(__formatter, "struct Clock")
                        }
                        #[inline]
                        fn visit_seq<__A>(
                            self,
                            mut __seq: __A,
                        ) -> _serde::export::Result<Self::Value, __A::Error>
                        where
                            __A: _serde::de::SeqAccess<'de>,
                        {
                            let __field0 = match match _serde::de::SeqAccess::next_element::<
                                Option<String>,
                            >(&mut __seq)
                            {
                                _serde::export::Ok(__val) => __val,
                                _serde::export::Err(__err) => {
                                    return _serde::export::Err(__err);
                                }
                            } {
                                _serde::export::Some(__value) => __value,
                                _serde::export::None => {
                                    return _serde::export::Err(_serde::de::Error::invalid_length(
                                        0usize,
                                        &"struct Clock with 2 elements",
                                    ));
                                }
                            };
                            let __field1 = match match _serde::de::SeqAccess::next_element::<
                                Vec<Timer>,
                            >(&mut __seq)
                            {
                                _serde::export::Ok(__val) => __val,
                                _serde::export::Err(__err) => {
                                    return _serde::export::Err(__err);
                                }
                            } {
                                _serde::export::Some(__value) => __value,
                                _serde::export::None => {
                                    return _serde::export::Err(_serde::de::Error::invalid_length(
                                        1usize,
                                        &"struct Clock with 2 elements",
                                    ));
                                }
                            };
                            _serde::export::Ok(Clock {
                                offset: __field0,
                                timers: __field1,
                            })
                        }
                        #[inline]
                        fn visit_map<__A>(
                            self,
                            mut __map: __A,
                        ) -> _serde::export::Result<Self::Value, __A::Error>
                        where
                            __A: _serde::de::MapAccess<'de>,
                        {
                            let mut __field0: _serde::export::Option<Option<String>> =
                                _serde::export::None;
                            let mut __field1: _serde::export::Option<Vec<Timer>> =
                                _serde::export::None;
                            while let _serde::export::Some(__key) =
                                match _serde::de::MapAccess::next_key::<__Field>(&mut __map) {
                                    _serde::export::Ok(__val) => __val,
                                    _serde::export::Err(__err) => {
                                        return _serde::export::Err(__err);
                                    }
                                }
                            {
                                match __key {
                                    __Field::__field0 => {
                                        if _serde::export::Option::is_some(&__field0) {
                                            return _serde::export::Err(
                                                <__A::Error as _serde::de::Error>::duplicate_field(
                                                    "offset",
                                                ),
                                            );
                                        }
                                        __field0 = _serde::export::Some(
                                            match _serde::de::MapAccess::next_value::<Option<String>>(
                                                &mut __map,
                                            ) {
                                                _serde::export::Ok(__val) => __val,
                                                _serde::export::Err(__err) => {
                                                    return _serde::export::Err(__err);
                                                }
                                            },
                                        );
                                    }
                                    __Field::__field1 => {
                                        if _serde::export::Option::is_some(&__field1) {
                                            return _serde::export::Err(
                                                <__A::Error as _serde::de::Error>::duplicate_field(
                                                    "timers",
                                                ),
                                            );
                                        }
                                        __field1 = _serde::export::Some(
                                            match _serde::de::MapAccess::next_value::<Vec<Timer>>(
                                                &mut __map,
                                            ) {
                                                _serde::export::Ok(__val) => __val,
                                                _serde::export::Err(__err) => {
                                                    return _serde::export::Err(__err);
                                                }
                                            },
                                        );
                                    }
                                    _ => {
                                        let _ = match _serde::de::MapAccess::next_value::<
                                            _serde::de::IgnoredAny,
                                        >(
                                            &mut __map
                                        ) {
                                            _serde::export::Ok(__val) => __val,
                                            _serde::export::Err(__err) => {
                                                return _serde::export::Err(__err);
                                            }
                                        };
                                    }
                                }
                            }
                            let __field0 = match __field0 {
                                _serde::export::Some(__field0) => __field0,
                                _serde::export::None => {
                                    match _serde::private::de::missing_field("offset") {
                                        _serde::export::Ok(__val) => __val,
                                        _serde::export::Err(__err) => {
                                            return _serde::export::Err(__err);
                                        }
                                    }
                                }
                            };
                            let __field1 = match __field1 {
                                _serde::export::Some(__field1) => __field1,
                                _serde::export::None => {
                                    match _serde::private::de::missing_field("timers") {
                                        _serde::export::Ok(__val) => __val,
                                        _serde::export::Err(__err) => {
                                            return _serde::export::Err(__err);
                                        }
                                    }
                                }
                            };
                            _serde::export::Ok(Clock {
                                offset: __field0,
                                timers: __field1,
                            })
                        }
                    }
                    const FIELDS: &'static [&'static str] = &["offset", "timers"];
                    _serde::Deserializer::deserialize_struct(
                        __deserializer,
                        "Clock",
                        FIELDS,
                        __Visitor {
                            marker: _serde::export::PhantomData::<Clock>,
                            lifetime: _serde::export::PhantomData,
                        },
                    )
                }
            }
        };
        #[xml(tag = "model")]
        pub struct Model {
            #[xml(attr = "fallback")]
            pub fallback: Option<String>,
        }
        impl<'__input> strong_xml::XmlRead<'__input> for Model {
            fn from_reader(
                mut reader: &mut strong_xml::XmlReader<'__input>,
            ) -> strong_xml::XmlResult<Self> {
                use strong_xml::xmlparser::{ElementEnd, Token, Tokenizer};
                use strong_xml::XmlError;
                let mut __self_fallback = None;
                reader.read_till_element_start("model")?;
                while let Some((__key, __value)) = reader.find_attribute()? {
                    match __key {
                        "fallback" => {
                            __self_fallback = Some(
                                <String as std::str::FromStr>::from_str(&__value)
                                    .map_err(|e| XmlError::FromStr(e.into()))?,
                            );
                        }
                        key => {}
                    }
                }
                if let Token::ElementEnd {
                    end: ElementEnd::Empty,
                    ..
                } = reader.next().unwrap()?
                {
                    let __res = Model {
                        fallback: __self_fallback,
                    };
                    return Ok(__res);
                }
                while let Some(__tag) = reader.find_element_start(Some("model"))? {
                    match __tag {
                        tag => {
                            reader.next();
                            reader.read_to_end(tag)?;
                        }
                    }
                }
                let __res = Model {
                    fallback: __self_fallback,
                };
                return Ok(__res);
            }
        }
        impl strong_xml::XmlWrite for Model {
            fn to_writer<W: std::io::Write>(
                &self,
                mut writer: &mut strong_xml::XmlWriter<W>,
            ) -> strong_xml::XmlResult<()> {
                let Model {
                    fallback: __self_fallback,
                } = self;
                writer.write_element_start("model")?;
                if let Some(__value) = __self_fallback {
                    writer.write_attribute("fallback", &{
                        let res = ::alloc::fmt::format(::core::fmt::Arguments::new_v1(
                            &[""],
                            &match (&__value,) {
                                (arg0,) => [::core::fmt::ArgumentV1::new(
                                    arg0,
                                    ::core::fmt::Display::fmt,
                                )],
                            },
                        ));
                        res
                    })?;
                }
                writer.write_element_end_empty()?;
                Ok(())
            }
        }
        impl ::core::marker::StructuralPartialEq for Model {}
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::cmp::PartialEq for Model {
            #[inline]
            fn eq(&self, other: &Model) -> bool {
                match *other {
                    Model {
                        fallback: ref __self_1_0,
                    } => match *self {
                        Model {
                            fallback: ref __self_0_0,
                        } => (*__self_0_0) == (*__self_1_0),
                    },
                }
            }
            #[inline]
            fn ne(&self, other: &Model) -> bool {
                match *other {
                    Model {
                        fallback: ref __self_1_0,
                    } => match *self {
                        Model {
                            fallback: ref __self_0_0,
                        } => (*__self_0_0) != (*__self_1_0),
                    },
                }
            }
        }
        impl ::core::marker::StructuralEq for Model {}
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::cmp::Eq for Model {
            #[inline]
            #[doc(hidden)]
            fn assert_receiver_is_total_eq(&self) -> () {
                {
                    let _: ::core::cmp::AssertParamIsEq<Option<String>>;
                }
            }
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::fmt::Debug for Model {
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                match *self {
                    Model {
                        fallback: ref __self_0_0,
                    } => {
                        let mut debug_trait_builder = f.debug_struct("Model");
                        let _ = debug_trait_builder.field("fallback", &&(*__self_0_0));
                        debug_trait_builder.finish()
                    }
                }
            }
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::clone::Clone for Model {
            #[inline]
            fn clone(&self) -> Model {
                match *self {
                    Model {
                        fallback: ref __self_0_0,
                    } => Model {
                        fallback: ::core::clone::Clone::clone(&(*__self_0_0)),
                    },
                }
            }
        }
        #[doc(hidden)]
        #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
        const _: () = {
            #[allow(rust_2018_idioms, clippy::useless_attribute)]
            extern crate serde as _serde;
            #[automatically_derived]
            impl _serde::Serialize for Model {
                fn serialize<__S>(
                    &self,
                    __serializer: __S,
                ) -> _serde::export::Result<__S::Ok, __S::Error>
                where
                    __S: _serde::Serializer,
                {
                    let mut __serde_state = match _serde::Serializer::serialize_struct(
                        __serializer,
                        "Model",
                        false as usize + 1,
                    ) {
                        _serde::export::Ok(__val) => __val,
                        _serde::export::Err(__err) => {
                            return _serde::export::Err(__err);
                        }
                    };
                    match _serde::ser::SerializeStruct::serialize_field(
                        &mut __serde_state,
                        "fallback",
                        &self.fallback,
                    ) {
                        _serde::export::Ok(__val) => __val,
                        _serde::export::Err(__err) => {
                            return _serde::export::Err(__err);
                        }
                    };
                    _serde::ser::SerializeStruct::end(__serde_state)
                }
            }
        };
        #[doc(hidden)]
        #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
        const _: () = {
            #[allow(rust_2018_idioms, clippy::useless_attribute)]
            extern crate serde as _serde;
            #[automatically_derived]
            impl<'de> _serde::Deserialize<'de> for Model {
                fn deserialize<__D>(__deserializer: __D) -> _serde::export::Result<Self, __D::Error>
                where
                    __D: _serde::Deserializer<'de>,
                {
                    #[allow(non_camel_case_types)]
                    enum __Field {
                        __field0,
                        __ignore,
                    }
                    struct __FieldVisitor;
                    impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                        type Value = __Field;
                        fn expecting(
                            &self,
                            __formatter: &mut _serde::export::Formatter,
                        ) -> _serde::export::fmt::Result {
                            _serde::export::Formatter::write_str(__formatter, "field identifier")
                        }
                        fn visit_u64<__E>(
                            self,
                            __value: u64,
                        ) -> _serde::export::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                0u64 => _serde::export::Ok(__Field::__field0),
                                _ => _serde::export::Err(_serde::de::Error::invalid_value(
                                    _serde::de::Unexpected::Unsigned(__value),
                                    &"field index 0 <= i < 1",
                                )),
                            }
                        }
                        fn visit_str<__E>(
                            self,
                            __value: &str,
                        ) -> _serde::export::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                "fallback" => _serde::export::Ok(__Field::__field0),
                                _ => _serde::export::Ok(__Field::__ignore),
                            }
                        }
                        fn visit_bytes<__E>(
                            self,
                            __value: &[u8],
                        ) -> _serde::export::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                b"fallback" => _serde::export::Ok(__Field::__field0),
                                _ => _serde::export::Ok(__Field::__ignore),
                            }
                        }
                    }
                    impl<'de> _serde::Deserialize<'de> for __Field {
                        #[inline]
                        fn deserialize<__D>(
                            __deserializer: __D,
                        ) -> _serde::export::Result<Self, __D::Error>
                        where
                            __D: _serde::Deserializer<'de>,
                        {
                            _serde::Deserializer::deserialize_identifier(
                                __deserializer,
                                __FieldVisitor,
                            )
                        }
                    }
                    struct __Visitor<'de> {
                        marker: _serde::export::PhantomData<Model>,
                        lifetime: _serde::export::PhantomData<&'de ()>,
                    }
                    impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                        type Value = Model;
                        fn expecting(
                            &self,
                            __formatter: &mut _serde::export::Formatter,
                        ) -> _serde::export::fmt::Result {
                            _serde::export::Formatter::write_str(__formatter, "struct Model")
                        }
                        #[inline]
                        fn visit_seq<__A>(
                            self,
                            mut __seq: __A,
                        ) -> _serde::export::Result<Self::Value, __A::Error>
                        where
                            __A: _serde::de::SeqAccess<'de>,
                        {
                            let __field0 = match match _serde::de::SeqAccess::next_element::<
                                Option<String>,
                            >(&mut __seq)
                            {
                                _serde::export::Ok(__val) => __val,
                                _serde::export::Err(__err) => {
                                    return _serde::export::Err(__err);
                                }
                            } {
                                _serde::export::Some(__value) => __value,
                                _serde::export::None => {
                                    return _serde::export::Err(_serde::de::Error::invalid_length(
                                        0usize,
                                        &"struct Model with 1 element",
                                    ));
                                }
                            };
                            _serde::export::Ok(Model { fallback: __field0 })
                        }
                        #[inline]
                        fn visit_map<__A>(
                            self,
                            mut __map: __A,
                        ) -> _serde::export::Result<Self::Value, __A::Error>
                        where
                            __A: _serde::de::MapAccess<'de>,
                        {
                            let mut __field0: _serde::export::Option<Option<String>> =
                                _serde::export::None;
                            while let _serde::export::Some(__key) =
                                match _serde::de::MapAccess::next_key::<__Field>(&mut __map) {
                                    _serde::export::Ok(__val) => __val,
                                    _serde::export::Err(__err) => {
                                        return _serde::export::Err(__err);
                                    }
                                }
                            {
                                match __key {
                                    __Field::__field0 => {
                                        if _serde::export::Option::is_some(&__field0) {
                                            return _serde::export::Err(
                                                <__A::Error as _serde::de::Error>::duplicate_field(
                                                    "fallback",
                                                ),
                                            );
                                        }
                                        __field0 = _serde::export::Some(
                                            match _serde::de::MapAccess::next_value::<Option<String>>(
                                                &mut __map,
                                            ) {
                                                _serde::export::Ok(__val) => __val,
                                                _serde::export::Err(__err) => {
                                                    return _serde::export::Err(__err);
                                                }
                                            },
                                        );
                                    }
                                    _ => {
                                        let _ = match _serde::de::MapAccess::next_value::<
                                            _serde::de::IgnoredAny,
                                        >(
                                            &mut __map
                                        ) {
                                            _serde::export::Ok(__val) => __val,
                                            _serde::export::Err(__err) => {
                                                return _serde::export::Err(__err);
                                            }
                                        };
                                    }
                                }
                            }
                            let __field0 = match __field0 {
                                _serde::export::Some(__field0) => __field0,
                                _serde::export::None => {
                                    match _serde::private::de::missing_field("fallback") {
                                        _serde::export::Ok(__val) => __val,
                                        _serde::export::Err(__err) => {
                                            return _serde::export::Err(__err);
                                        }
                                    }
                                }
                            };
                            _serde::export::Ok(Model { fallback: __field0 })
                        }
                    }
                    const FIELDS: &'static [&'static str] = &["fallback"];
                    _serde::Deserializer::deserialize_struct(
                        __deserializer,
                        "Model",
                        FIELDS,
                        __Visitor {
                            marker: _serde::export::PhantomData::<Model>,
                            lifetime: _serde::export::PhantomData,
                        },
                    )
                }
            }
        };
        #[xml(tag = "suspend-to-mem")]
        pub struct SuspendToMem {
            #[xml(attr = "enabled")]
            pub enabled: Option<String>,
        }
        impl<'__input> strong_xml::XmlRead<'__input> for SuspendToMem {
            fn from_reader(
                mut reader: &mut strong_xml::XmlReader<'__input>,
            ) -> strong_xml::XmlResult<Self> {
                use strong_xml::xmlparser::{ElementEnd, Token, Tokenizer};
                use strong_xml::XmlError;
                let mut __self_enabled = None;
                reader.read_till_element_start("suspend-to-mem")?;
                while let Some((__key, __value)) = reader.find_attribute()? {
                    match __key {
                        "enabled" => {
                            __self_enabled = Some(
                                <String as std::str::FromStr>::from_str(&__value)
                                    .map_err(|e| XmlError::FromStr(e.into()))?,
                            );
                        }
                        key => {}
                    }
                }
                if let Token::ElementEnd {
                    end: ElementEnd::Empty,
                    ..
                } = reader.next().unwrap()?
                {
                    let __res = SuspendToMem {
                        enabled: __self_enabled,
                    };
                    return Ok(__res);
                }
                while let Some(__tag) = reader.find_element_start(Some("suspend-to-mem"))? {
                    match __tag {
                        tag => {
                            reader.next();
                            reader.read_to_end(tag)?;
                        }
                    }
                }
                let __res = SuspendToMem {
                    enabled: __self_enabled,
                };
                return Ok(__res);
            }
        }
        impl strong_xml::XmlWrite for SuspendToMem {
            fn to_writer<W: std::io::Write>(
                &self,
                mut writer: &mut strong_xml::XmlWriter<W>,
            ) -> strong_xml::XmlResult<()> {
                let SuspendToMem {
                    enabled: __self_enabled,
                } = self;
                writer.write_element_start("suspend-to-mem")?;
                if let Some(__value) = __self_enabled {
                    writer.write_attribute("enabled", &{
                        let res = ::alloc::fmt::format(::core::fmt::Arguments::new_v1(
                            &[""],
                            &match (&__value,) {
                                (arg0,) => [::core::fmt::ArgumentV1::new(
                                    arg0,
                                    ::core::fmt::Display::fmt,
                                )],
                            },
                        ));
                        res
                    })?;
                }
                writer.write_element_end_empty()?;
                Ok(())
            }
        }
        impl ::core::marker::StructuralPartialEq for SuspendToMem {}
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::cmp::PartialEq for SuspendToMem {
            #[inline]
            fn eq(&self, other: &SuspendToMem) -> bool {
                match *other {
                    SuspendToMem {
                        enabled: ref __self_1_0,
                    } => match *self {
                        SuspendToMem {
                            enabled: ref __self_0_0,
                        } => (*__self_0_0) == (*__self_1_0),
                    },
                }
            }
            #[inline]
            fn ne(&self, other: &SuspendToMem) -> bool {
                match *other {
                    SuspendToMem {
                        enabled: ref __self_1_0,
                    } => match *self {
                        SuspendToMem {
                            enabled: ref __self_0_0,
                        } => (*__self_0_0) != (*__self_1_0),
                    },
                }
            }
        }
        impl ::core::marker::StructuralEq for SuspendToMem {}
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::cmp::Eq for SuspendToMem {
            #[inline]
            #[doc(hidden)]
            fn assert_receiver_is_total_eq(&self) -> () {
                {
                    let _: ::core::cmp::AssertParamIsEq<Option<String>>;
                }
            }
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::fmt::Debug for SuspendToMem {
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                match *self {
                    SuspendToMem {
                        enabled: ref __self_0_0,
                    } => {
                        let mut debug_trait_builder = f.debug_struct("SuspendToMem");
                        let _ = debug_trait_builder.field("enabled", &&(*__self_0_0));
                        debug_trait_builder.finish()
                    }
                }
            }
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::clone::Clone for SuspendToMem {
            #[inline]
            fn clone(&self) -> SuspendToMem {
                match *self {
                    SuspendToMem {
                        enabled: ref __self_0_0,
                    } => SuspendToMem {
                        enabled: ::core::clone::Clone::clone(&(*__self_0_0)),
                    },
                }
            }
        }
        #[doc(hidden)]
        #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
        const _: () = {
            #[allow(rust_2018_idioms, clippy::useless_attribute)]
            extern crate serde as _serde;
            #[automatically_derived]
            impl _serde::Serialize for SuspendToMem {
                fn serialize<__S>(
                    &self,
                    __serializer: __S,
                ) -> _serde::export::Result<__S::Ok, __S::Error>
                where
                    __S: _serde::Serializer,
                {
                    let mut __serde_state = match _serde::Serializer::serialize_struct(
                        __serializer,
                        "SuspendToMem",
                        false as usize + 1,
                    ) {
                        _serde::export::Ok(__val) => __val,
                        _serde::export::Err(__err) => {
                            return _serde::export::Err(__err);
                        }
                    };
                    match _serde::ser::SerializeStruct::serialize_field(
                        &mut __serde_state,
                        "enabled",
                        &self.enabled,
                    ) {
                        _serde::export::Ok(__val) => __val,
                        _serde::export::Err(__err) => {
                            return _serde::export::Err(__err);
                        }
                    };
                    _serde::ser::SerializeStruct::end(__serde_state)
                }
            }
        };
        #[doc(hidden)]
        #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
        const _: () = {
            #[allow(rust_2018_idioms, clippy::useless_attribute)]
            extern crate serde as _serde;
            #[automatically_derived]
            impl<'de> _serde::Deserialize<'de> for SuspendToMem {
                fn deserialize<__D>(__deserializer: __D) -> _serde::export::Result<Self, __D::Error>
                where
                    __D: _serde::Deserializer<'de>,
                {
                    #[allow(non_camel_case_types)]
                    enum __Field {
                        __field0,
                        __ignore,
                    }
                    struct __FieldVisitor;
                    impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                        type Value = __Field;
                        fn expecting(
                            &self,
                            __formatter: &mut _serde::export::Formatter,
                        ) -> _serde::export::fmt::Result {
                            _serde::export::Formatter::write_str(__formatter, "field identifier")
                        }
                        fn visit_u64<__E>(
                            self,
                            __value: u64,
                        ) -> _serde::export::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                0u64 => _serde::export::Ok(__Field::__field0),
                                _ => _serde::export::Err(_serde::de::Error::invalid_value(
                                    _serde::de::Unexpected::Unsigned(__value),
                                    &"field index 0 <= i < 1",
                                )),
                            }
                        }
                        fn visit_str<__E>(
                            self,
                            __value: &str,
                        ) -> _serde::export::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                "enabled" => _serde::export::Ok(__Field::__field0),
                                _ => _serde::export::Ok(__Field::__ignore),
                            }
                        }
                        fn visit_bytes<__E>(
                            self,
                            __value: &[u8],
                        ) -> _serde::export::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                b"enabled" => _serde::export::Ok(__Field::__field0),
                                _ => _serde::export::Ok(__Field::__ignore),
                            }
                        }
                    }
                    impl<'de> _serde::Deserialize<'de> for __Field {
                        #[inline]
                        fn deserialize<__D>(
                            __deserializer: __D,
                        ) -> _serde::export::Result<Self, __D::Error>
                        where
                            __D: _serde::Deserializer<'de>,
                        {
                            _serde::Deserializer::deserialize_identifier(
                                __deserializer,
                                __FieldVisitor,
                            )
                        }
                    }
                    struct __Visitor<'de> {
                        marker: _serde::export::PhantomData<SuspendToMem>,
                        lifetime: _serde::export::PhantomData<&'de ()>,
                    }
                    impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                        type Value = SuspendToMem;
                        fn expecting(
                            &self,
                            __formatter: &mut _serde::export::Formatter,
                        ) -> _serde::export::fmt::Result {
                            _serde::export::Formatter::write_str(__formatter, "struct SuspendToMem")
                        }
                        #[inline]
                        fn visit_seq<__A>(
                            self,
                            mut __seq: __A,
                        ) -> _serde::export::Result<Self::Value, __A::Error>
                        where
                            __A: _serde::de::SeqAccess<'de>,
                        {
                            let __field0 = match match _serde::de::SeqAccess::next_element::<
                                Option<String>,
                            >(&mut __seq)
                            {
                                _serde::export::Ok(__val) => __val,
                                _serde::export::Err(__err) => {
                                    return _serde::export::Err(__err);
                                }
                            } {
                                _serde::export::Some(__value) => __value,
                                _serde::export::None => {
                                    return _serde::export::Err(_serde::de::Error::invalid_length(
                                        0usize,
                                        &"struct SuspendToMem with 1 element",
                                    ));
                                }
                            };
                            _serde::export::Ok(SuspendToMem { enabled: __field0 })
                        }
                        #[inline]
                        fn visit_map<__A>(
                            self,
                            mut __map: __A,
                        ) -> _serde::export::Result<Self::Value, __A::Error>
                        where
                            __A: _serde::de::MapAccess<'de>,
                        {
                            let mut __field0: _serde::export::Option<Option<String>> =
                                _serde::export::None;
                            while let _serde::export::Some(__key) =
                                match _serde::de::MapAccess::next_key::<__Field>(&mut __map) {
                                    _serde::export::Ok(__val) => __val,
                                    _serde::export::Err(__err) => {
                                        return _serde::export::Err(__err);
                                    }
                                }
                            {
                                match __key {
                                    __Field::__field0 => {
                                        if _serde::export::Option::is_some(&__field0) {
                                            return _serde::export::Err(
                                                <__A::Error as _serde::de::Error>::duplicate_field(
                                                    "enabled",
                                                ),
                                            );
                                        }
                                        __field0 = _serde::export::Some(
                                            match _serde::de::MapAccess::next_value::<Option<String>>(
                                                &mut __map,
                                            ) {
                                                _serde::export::Ok(__val) => __val,
                                                _serde::export::Err(__err) => {
                                                    return _serde::export::Err(__err);
                                                }
                                            },
                                        );
                                    }
                                    _ => {
                                        let _ = match _serde::de::MapAccess::next_value::<
                                            _serde::de::IgnoredAny,
                                        >(
                                            &mut __map
                                        ) {
                                            _serde::export::Ok(__val) => __val,
                                            _serde::export::Err(__err) => {
                                                return _serde::export::Err(__err);
                                            }
                                        };
                                    }
                                }
                            }
                            let __field0 = match __field0 {
                                _serde::export::Some(__field0) => __field0,
                                _serde::export::None => {
                                    match _serde::private::de::missing_field("enabled") {
                                        _serde::export::Ok(__val) => __val,
                                        _serde::export::Err(__err) => {
                                            return _serde::export::Err(__err);
                                        }
                                    }
                                }
                            };
                            _serde::export::Ok(SuspendToMem { enabled: __field0 })
                        }
                    }
                    const FIELDS: &'static [&'static str] = &["enabled"];
                    _serde::Deserializer::deserialize_struct(
                        __deserializer,
                        "SuspendToMem",
                        FIELDS,
                        __Visitor {
                            marker: _serde::export::PhantomData::<SuspendToMem>,
                            lifetime: _serde::export::PhantomData,
                        },
                    )
                }
            }
        };
        #[xml(tag = "suspend-to-disk")]
        pub struct SuspendToDisk {
            #[xml(attr = "enabled")]
            pub enabled: Option<String>,
        }
        impl<'__input> strong_xml::XmlRead<'__input> for SuspendToDisk {
            fn from_reader(
                mut reader: &mut strong_xml::XmlReader<'__input>,
            ) -> strong_xml::XmlResult<Self> {
                use strong_xml::xmlparser::{ElementEnd, Token, Tokenizer};
                use strong_xml::XmlError;
                let mut __self_enabled = None;
                reader.read_till_element_start("suspend-to-disk")?;
                while let Some((__key, __value)) = reader.find_attribute()? {
                    match __key {
                        "enabled" => {
                            __self_enabled = Some(
                                <String as std::str::FromStr>::from_str(&__value)
                                    .map_err(|e| XmlError::FromStr(e.into()))?,
                            );
                        }
                        key => {}
                    }
                }
                if let Token::ElementEnd {
                    end: ElementEnd::Empty,
                    ..
                } = reader.next().unwrap()?
                {
                    let __res = SuspendToDisk {
                        enabled: __self_enabled,
                    };
                    return Ok(__res);
                }
                while let Some(__tag) = reader.find_element_start(Some("suspend-to-disk"))? {
                    match __tag {
                        tag => {
                            reader.next();
                            reader.read_to_end(tag)?;
                        }
                    }
                }
                let __res = SuspendToDisk {
                    enabled: __self_enabled,
                };
                return Ok(__res);
            }
        }
        impl strong_xml::XmlWrite for SuspendToDisk {
            fn to_writer<W: std::io::Write>(
                &self,
                mut writer: &mut strong_xml::XmlWriter<W>,
            ) -> strong_xml::XmlResult<()> {
                let SuspendToDisk {
                    enabled: __self_enabled,
                } = self;
                writer.write_element_start("suspend-to-disk")?;
                if let Some(__value) = __self_enabled {
                    writer.write_attribute("enabled", &{
                        let res = ::alloc::fmt::format(::core::fmt::Arguments::new_v1(
                            &[""],
                            &match (&__value,) {
                                (arg0,) => [::core::fmt::ArgumentV1::new(
                                    arg0,
                                    ::core::fmt::Display::fmt,
                                )],
                            },
                        ));
                        res
                    })?;
                }
                writer.write_element_end_empty()?;
                Ok(())
            }
        }
        impl ::core::marker::StructuralPartialEq for SuspendToDisk {}
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::cmp::PartialEq for SuspendToDisk {
            #[inline]
            fn eq(&self, other: &SuspendToDisk) -> bool {
                match *other {
                    SuspendToDisk {
                        enabled: ref __self_1_0,
                    } => match *self {
                        SuspendToDisk {
                            enabled: ref __self_0_0,
                        } => (*__self_0_0) == (*__self_1_0),
                    },
                }
            }
            #[inline]
            fn ne(&self, other: &SuspendToDisk) -> bool {
                match *other {
                    SuspendToDisk {
                        enabled: ref __self_1_0,
                    } => match *self {
                        SuspendToDisk {
                            enabled: ref __self_0_0,
                        } => (*__self_0_0) != (*__self_1_0),
                    },
                }
            }
        }
        impl ::core::marker::StructuralEq for SuspendToDisk {}
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::cmp::Eq for SuspendToDisk {
            #[inline]
            #[doc(hidden)]
            fn assert_receiver_is_total_eq(&self) -> () {
                {
                    let _: ::core::cmp::AssertParamIsEq<Option<String>>;
                }
            }
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::fmt::Debug for SuspendToDisk {
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                match *self {
                    SuspendToDisk {
                        enabled: ref __self_0_0,
                    } => {
                        let mut debug_trait_builder = f.debug_struct("SuspendToDisk");
                        let _ = debug_trait_builder.field("enabled", &&(*__self_0_0));
                        debug_trait_builder.finish()
                    }
                }
            }
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::clone::Clone for SuspendToDisk {
            #[inline]
            fn clone(&self) -> SuspendToDisk {
                match *self {
                    SuspendToDisk {
                        enabled: ref __self_0_0,
                    } => SuspendToDisk {
                        enabled: ::core::clone::Clone::clone(&(*__self_0_0)),
                    },
                }
            }
        }
        #[doc(hidden)]
        #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
        const _: () = {
            #[allow(rust_2018_idioms, clippy::useless_attribute)]
            extern crate serde as _serde;
            #[automatically_derived]
            impl _serde::Serialize for SuspendToDisk {
                fn serialize<__S>(
                    &self,
                    __serializer: __S,
                ) -> _serde::export::Result<__S::Ok, __S::Error>
                where
                    __S: _serde::Serializer,
                {
                    let mut __serde_state = match _serde::Serializer::serialize_struct(
                        __serializer,
                        "SuspendToDisk",
                        false as usize + 1,
                    ) {
                        _serde::export::Ok(__val) => __val,
                        _serde::export::Err(__err) => {
                            return _serde::export::Err(__err);
                        }
                    };
                    match _serde::ser::SerializeStruct::serialize_field(
                        &mut __serde_state,
                        "enabled",
                        &self.enabled,
                    ) {
                        _serde::export::Ok(__val) => __val,
                        _serde::export::Err(__err) => {
                            return _serde::export::Err(__err);
                        }
                    };
                    _serde::ser::SerializeStruct::end(__serde_state)
                }
            }
        };
        #[doc(hidden)]
        #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
        const _: () = {
            #[allow(rust_2018_idioms, clippy::useless_attribute)]
            extern crate serde as _serde;
            #[automatically_derived]
            impl<'de> _serde::Deserialize<'de> for SuspendToDisk {
                fn deserialize<__D>(__deserializer: __D) -> _serde::export::Result<Self, __D::Error>
                where
                    __D: _serde::Deserializer<'de>,
                {
                    #[allow(non_camel_case_types)]
                    enum __Field {
                        __field0,
                        __ignore,
                    }
                    struct __FieldVisitor;
                    impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                        type Value = __Field;
                        fn expecting(
                            &self,
                            __formatter: &mut _serde::export::Formatter,
                        ) -> _serde::export::fmt::Result {
                            _serde::export::Formatter::write_str(__formatter, "field identifier")
                        }
                        fn visit_u64<__E>(
                            self,
                            __value: u64,
                        ) -> _serde::export::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                0u64 => _serde::export::Ok(__Field::__field0),
                                _ => _serde::export::Err(_serde::de::Error::invalid_value(
                                    _serde::de::Unexpected::Unsigned(__value),
                                    &"field index 0 <= i < 1",
                                )),
                            }
                        }
                        fn visit_str<__E>(
                            self,
                            __value: &str,
                        ) -> _serde::export::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                "enabled" => _serde::export::Ok(__Field::__field0),
                                _ => _serde::export::Ok(__Field::__ignore),
                            }
                        }
                        fn visit_bytes<__E>(
                            self,
                            __value: &[u8],
                        ) -> _serde::export::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                b"enabled" => _serde::export::Ok(__Field::__field0),
                                _ => _serde::export::Ok(__Field::__ignore),
                            }
                        }
                    }
                    impl<'de> _serde::Deserialize<'de> for __Field {
                        #[inline]
                        fn deserialize<__D>(
                            __deserializer: __D,
                        ) -> _serde::export::Result<Self, __D::Error>
                        where
                            __D: _serde::Deserializer<'de>,
                        {
                            _serde::Deserializer::deserialize_identifier(
                                __deserializer,
                                __FieldVisitor,
                            )
                        }
                    }
                    struct __Visitor<'de> {
                        marker: _serde::export::PhantomData<SuspendToDisk>,
                        lifetime: _serde::export::PhantomData<&'de ()>,
                    }
                    impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                        type Value = SuspendToDisk;
                        fn expecting(
                            &self,
                            __formatter: &mut _serde::export::Formatter,
                        ) -> _serde::export::fmt::Result {
                            _serde::export::Formatter::write_str(
                                __formatter,
                                "struct SuspendToDisk",
                            )
                        }
                        #[inline]
                        fn visit_seq<__A>(
                            self,
                            mut __seq: __A,
                        ) -> _serde::export::Result<Self::Value, __A::Error>
                        where
                            __A: _serde::de::SeqAccess<'de>,
                        {
                            let __field0 = match match _serde::de::SeqAccess::next_element::<
                                Option<String>,
                            >(&mut __seq)
                            {
                                _serde::export::Ok(__val) => __val,
                                _serde::export::Err(__err) => {
                                    return _serde::export::Err(__err);
                                }
                            } {
                                _serde::export::Some(__value) => __value,
                                _serde::export::None => {
                                    return _serde::export::Err(_serde::de::Error::invalid_length(
                                        0usize,
                                        &"struct SuspendToDisk with 1 element",
                                    ));
                                }
                            };
                            _serde::export::Ok(SuspendToDisk { enabled: __field0 })
                        }
                        #[inline]
                        fn visit_map<__A>(
                            self,
                            mut __map: __A,
                        ) -> _serde::export::Result<Self::Value, __A::Error>
                        where
                            __A: _serde::de::MapAccess<'de>,
                        {
                            let mut __field0: _serde::export::Option<Option<String>> =
                                _serde::export::None;
                            while let _serde::export::Some(__key) =
                                match _serde::de::MapAccess::next_key::<__Field>(&mut __map) {
                                    _serde::export::Ok(__val) => __val,
                                    _serde::export::Err(__err) => {
                                        return _serde::export::Err(__err);
                                    }
                                }
                            {
                                match __key {
                                    __Field::__field0 => {
                                        if _serde::export::Option::is_some(&__field0) {
                                            return _serde::export::Err(
                                                <__A::Error as _serde::de::Error>::duplicate_field(
                                                    "enabled",
                                                ),
                                            );
                                        }
                                        __field0 = _serde::export::Some(
                                            match _serde::de::MapAccess::next_value::<Option<String>>(
                                                &mut __map,
                                            ) {
                                                _serde::export::Ok(__val) => __val,
                                                _serde::export::Err(__err) => {
                                                    return _serde::export::Err(__err);
                                                }
                                            },
                                        );
                                    }
                                    _ => {
                                        let _ = match _serde::de::MapAccess::next_value::<
                                            _serde::de::IgnoredAny,
                                        >(
                                            &mut __map
                                        ) {
                                            _serde::export::Ok(__val) => __val,
                                            _serde::export::Err(__err) => {
                                                return _serde::export::Err(__err);
                                            }
                                        };
                                    }
                                }
                            }
                            let __field0 = match __field0 {
                                _serde::export::Some(__field0) => __field0,
                                _serde::export::None => {
                                    match _serde::private::de::missing_field("enabled") {
                                        _serde::export::Ok(__val) => __val,
                                        _serde::export::Err(__err) => {
                                            return _serde::export::Err(__err);
                                        }
                                    }
                                }
                            };
                            _serde::export::Ok(SuspendToDisk { enabled: __field0 })
                        }
                    }
                    const FIELDS: &'static [&'static str] = &["enabled"];
                    _serde::Deserializer::deserialize_struct(
                        __deserializer,
                        "SuspendToDisk",
                        FIELDS,
                        __Visitor {
                            marker: _serde::export::PhantomData::<SuspendToDisk>,
                            lifetime: _serde::export::PhantomData,
                        },
                    )
                }
            }
        };
        #[xml(tag = "cpu")]
        pub struct CPU {
            #[xml(attr = "mode")]
            pub mode: Option<String>,
            #[xml(attr = "check")]
            pub check: Option<String>,
            #[xml(child = "model")]
            pub model: Option<Model>,
        }
        impl strong_xml::XmlWrite for CPU {
            fn to_writer<W: std::io::Write>(
                &self,
                mut writer: &mut strong_xml::XmlWriter<W>,
            ) -> strong_xml::XmlResult<()> {
                let CPU {
                    mode: __self_mode,
                    check: __self_check,
                    model: __self_model,
                } = self;
                writer.write_element_start("cpu")?;
                if let Some(__value) = __self_mode {
                    writer.write_attribute("mode", &{
                        let res = ::alloc::fmt::format(::core::fmt::Arguments::new_v1(
                            &[""],
                            &match (&__value,) {
                                (arg0,) => [::core::fmt::ArgumentV1::new(
                                    arg0,
                                    ::core::fmt::Display::fmt,
                                )],
                            },
                        ));
                        res
                    })?;
                }
                if let Some(__value) = __self_check {
                    writer.write_attribute("check", &{
                        let res = ::alloc::fmt::format(::core::fmt::Arguments::new_v1(
                            &[""],
                            &match (&__value,) {
                                (arg0,) => [::core::fmt::ArgumentV1::new(
                                    arg0,
                                    ::core::fmt::Display::fmt,
                                )],
                            },
                        ));
                        res
                    })?;
                }
                if true && __self_model.is_none() {
                    writer.write_element_end_empty()?;
                } else {
                    writer.write_element_end_open()?;
                    if let Some(ref ele) = __self_model {
                        ele.to_writer(&mut writer)?;
                    }
                    writer.write_element_end_close("cpu")?;
                }
                Ok(())
            }
        }
        impl<'__input> strong_xml::XmlRead<'__input> for CPU {
            fn from_reader(
                mut reader: &mut strong_xml::XmlReader<'__input>,
            ) -> strong_xml::XmlResult<Self> {
                use strong_xml::xmlparser::{ElementEnd, Token, Tokenizer};
                use strong_xml::XmlError;
                let mut __self_mode = None;
                let mut __self_check = None;
                let mut __self_model = None;
                reader.read_till_element_start("cpu")?;
                while let Some((__key, __value)) = reader.find_attribute()? {
                    match __key {
                        "mode" => {
                            __self_mode = Some(
                                <String as std::str::FromStr>::from_str(&__value)
                                    .map_err(|e| XmlError::FromStr(e.into()))?,
                            );
                        }
                        "check" => {
                            __self_check = Some(
                                <String as std::str::FromStr>::from_str(&__value)
                                    .map_err(|e| XmlError::FromStr(e.into()))?,
                            );
                        }
                        key => {}
                    }
                }
                if let Token::ElementEnd {
                    end: ElementEnd::Empty,
                    ..
                } = reader.next().unwrap()?
                {
                    let __res = CPU {
                        mode: __self_mode,
                        check: __self_check,
                        model: __self_model,
                    };
                    return Ok(__res);
                }
                while let Some(__tag) = reader.find_element_start(Some("cpu"))? {
                    match __tag {
                        "model" => {
                            __self_model =
                                Some(<Model as strong_xml::XmlRead>::from_reader(reader)?);
                        }
                        tag => {
                            reader.next();
                            reader.read_to_end(tag)?;
                        }
                    }
                }
                let __res = CPU {
                    mode: __self_mode,
                    check: __self_check,
                    model: __self_model,
                };
                return Ok(__res);
            }
        }
        impl ::core::marker::StructuralPartialEq for CPU {}
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::cmp::PartialEq for CPU {
            #[inline]
            fn eq(&self, other: &CPU) -> bool {
                match *other {
                    CPU {
                        mode: ref __self_1_0,
                        check: ref __self_1_1,
                        model: ref __self_1_2,
                    } => match *self {
                        CPU {
                            mode: ref __self_0_0,
                            check: ref __self_0_1,
                            model: ref __self_0_2,
                        } => {
                            (*__self_0_0) == (*__self_1_0)
                                && (*__self_0_1) == (*__self_1_1)
                                && (*__self_0_2) == (*__self_1_2)
                        }
                    },
                }
            }
            #[inline]
            fn ne(&self, other: &CPU) -> bool {
                match *other {
                    CPU {
                        mode: ref __self_1_0,
                        check: ref __self_1_1,
                        model: ref __self_1_2,
                    } => match *self {
                        CPU {
                            mode: ref __self_0_0,
                            check: ref __self_0_1,
                            model: ref __self_0_2,
                        } => {
                            (*__self_0_0) != (*__self_1_0)
                                || (*__self_0_1) != (*__self_1_1)
                                || (*__self_0_2) != (*__self_1_2)
                        }
                    },
                }
            }
        }
        impl ::core::marker::StructuralEq for CPU {}
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::cmp::Eq for CPU {
            #[inline]
            #[doc(hidden)]
            fn assert_receiver_is_total_eq(&self) -> () {
                {
                    let _: ::core::cmp::AssertParamIsEq<Option<String>>;
                    let _: ::core::cmp::AssertParamIsEq<Option<String>>;
                    let _: ::core::cmp::AssertParamIsEq<Option<Model>>;
                }
            }
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::fmt::Debug for CPU {
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                match *self {
                    CPU {
                        mode: ref __self_0_0,
                        check: ref __self_0_1,
                        model: ref __self_0_2,
                    } => {
                        let mut debug_trait_builder = f.debug_struct("CPU");
                        let _ = debug_trait_builder.field("mode", &&(*__self_0_0));
                        let _ = debug_trait_builder.field("check", &&(*__self_0_1));
                        let _ = debug_trait_builder.field("model", &&(*__self_0_2));
                        debug_trait_builder.finish()
                    }
                }
            }
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::clone::Clone for CPU {
            #[inline]
            fn clone(&self) -> CPU {
                match *self {
                    CPU {
                        mode: ref __self_0_0,
                        check: ref __self_0_1,
                        model: ref __self_0_2,
                    } => CPU {
                        mode: ::core::clone::Clone::clone(&(*__self_0_0)),
                        check: ::core::clone::Clone::clone(&(*__self_0_1)),
                        model: ::core::clone::Clone::clone(&(*__self_0_2)),
                    },
                }
            }
        }
        #[doc(hidden)]
        #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
        const _: () = {
            #[allow(rust_2018_idioms, clippy::useless_attribute)]
            extern crate serde as _serde;
            #[automatically_derived]
            impl _serde::Serialize for CPU {
                fn serialize<__S>(
                    &self,
                    __serializer: __S,
                ) -> _serde::export::Result<__S::Ok, __S::Error>
                where
                    __S: _serde::Serializer,
                {
                    let mut __serde_state = match _serde::Serializer::serialize_struct(
                        __serializer,
                        "CPU",
                        false as usize + 1 + 1 + 1,
                    ) {
                        _serde::export::Ok(__val) => __val,
                        _serde::export::Err(__err) => {
                            return _serde::export::Err(__err);
                        }
                    };
                    match _serde::ser::SerializeStruct::serialize_field(
                        &mut __serde_state,
                        "mode",
                        &self.mode,
                    ) {
                        _serde::export::Ok(__val) => __val,
                        _serde::export::Err(__err) => {
                            return _serde::export::Err(__err);
                        }
                    };
                    match _serde::ser::SerializeStruct::serialize_field(
                        &mut __serde_state,
                        "check",
                        &self.check,
                    ) {
                        _serde::export::Ok(__val) => __val,
                        _serde::export::Err(__err) => {
                            return _serde::export::Err(__err);
                        }
                    };
                    match _serde::ser::SerializeStruct::serialize_field(
                        &mut __serde_state,
                        "model",
                        &self.model,
                    ) {
                        _serde::export::Ok(__val) => __val,
                        _serde::export::Err(__err) => {
                            return _serde::export::Err(__err);
                        }
                    };
                    _serde::ser::SerializeStruct::end(__serde_state)
                }
            }
        };
        #[doc(hidden)]
        #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
        const _: () = {
            #[allow(rust_2018_idioms, clippy::useless_attribute)]
            extern crate serde as _serde;
            #[automatically_derived]
            impl<'de> _serde::Deserialize<'de> for CPU {
                fn deserialize<__D>(__deserializer: __D) -> _serde::export::Result<Self, __D::Error>
                where
                    __D: _serde::Deserializer<'de>,
                {
                    #[allow(non_camel_case_types)]
                    enum __Field {
                        __field0,
                        __field1,
                        __field2,
                        __ignore,
                    }
                    struct __FieldVisitor;
                    impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                        type Value = __Field;
                        fn expecting(
                            &self,
                            __formatter: &mut _serde::export::Formatter,
                        ) -> _serde::export::fmt::Result {
                            _serde::export::Formatter::write_str(__formatter, "field identifier")
                        }
                        fn visit_u64<__E>(
                            self,
                            __value: u64,
                        ) -> _serde::export::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                0u64 => _serde::export::Ok(__Field::__field0),
                                1u64 => _serde::export::Ok(__Field::__field1),
                                2u64 => _serde::export::Ok(__Field::__field2),
                                _ => _serde::export::Err(_serde::de::Error::invalid_value(
                                    _serde::de::Unexpected::Unsigned(__value),
                                    &"field index 0 <= i < 3",
                                )),
                            }
                        }
                        fn visit_str<__E>(
                            self,
                            __value: &str,
                        ) -> _serde::export::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                "mode" => _serde::export::Ok(__Field::__field0),
                                "check" => _serde::export::Ok(__Field::__field1),
                                "model" => _serde::export::Ok(__Field::__field2),
                                _ => _serde::export::Ok(__Field::__ignore),
                            }
                        }
                        fn visit_bytes<__E>(
                            self,
                            __value: &[u8],
                        ) -> _serde::export::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                b"mode" => _serde::export::Ok(__Field::__field0),
                                b"check" => _serde::export::Ok(__Field::__field1),
                                b"model" => _serde::export::Ok(__Field::__field2),
                                _ => _serde::export::Ok(__Field::__ignore),
                            }
                        }
                    }
                    impl<'de> _serde::Deserialize<'de> for __Field {
                        #[inline]
                        fn deserialize<__D>(
                            __deserializer: __D,
                        ) -> _serde::export::Result<Self, __D::Error>
                        where
                            __D: _serde::Deserializer<'de>,
                        {
                            _serde::Deserializer::deserialize_identifier(
                                __deserializer,
                                __FieldVisitor,
                            )
                        }
                    }
                    struct __Visitor<'de> {
                        marker: _serde::export::PhantomData<CPU>,
                        lifetime: _serde::export::PhantomData<&'de ()>,
                    }
                    impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                        type Value = CPU;
                        fn expecting(
                            &self,
                            __formatter: &mut _serde::export::Formatter,
                        ) -> _serde::export::fmt::Result {
                            _serde::export::Formatter::write_str(__formatter, "struct CPU")
                        }
                        #[inline]
                        fn visit_seq<__A>(
                            self,
                            mut __seq: __A,
                        ) -> _serde::export::Result<Self::Value, __A::Error>
                        where
                            __A: _serde::de::SeqAccess<'de>,
                        {
                            let __field0 = match match _serde::de::SeqAccess::next_element::<
                                Option<String>,
                            >(&mut __seq)
                            {
                                _serde::export::Ok(__val) => __val,
                                _serde::export::Err(__err) => {
                                    return _serde::export::Err(__err);
                                }
                            } {
                                _serde::export::Some(__value) => __value,
                                _serde::export::None => {
                                    return _serde::export::Err(_serde::de::Error::invalid_length(
                                        0usize,
                                        &"struct CPU with 3 elements",
                                    ));
                                }
                            };
                            let __field1 = match match _serde::de::SeqAccess::next_element::<
                                Option<String>,
                            >(&mut __seq)
                            {
                                _serde::export::Ok(__val) => __val,
                                _serde::export::Err(__err) => {
                                    return _serde::export::Err(__err);
                                }
                            } {
                                _serde::export::Some(__value) => __value,
                                _serde::export::None => {
                                    return _serde::export::Err(_serde::de::Error::invalid_length(
                                        1usize,
                                        &"struct CPU with 3 elements",
                                    ));
                                }
                            };
                            let __field2 = match match _serde::de::SeqAccess::next_element::<
                                Option<Model>,
                            >(&mut __seq)
                            {
                                _serde::export::Ok(__val) => __val,
                                _serde::export::Err(__err) => {
                                    return _serde::export::Err(__err);
                                }
                            } {
                                _serde::export::Some(__value) => __value,
                                _serde::export::None => {
                                    return _serde::export::Err(_serde::de::Error::invalid_length(
                                        2usize,
                                        &"struct CPU with 3 elements",
                                    ));
                                }
                            };
                            _serde::export::Ok(CPU {
                                mode: __field0,
                                check: __field1,
                                model: __field2,
                            })
                        }
                        #[inline]
                        fn visit_map<__A>(
                            self,
                            mut __map: __A,
                        ) -> _serde::export::Result<Self::Value, __A::Error>
                        where
                            __A: _serde::de::MapAccess<'de>,
                        {
                            let mut __field0: _serde::export::Option<Option<String>> =
                                _serde::export::None;
                            let mut __field1: _serde::export::Option<Option<String>> =
                                _serde::export::None;
                            let mut __field2: _serde::export::Option<Option<Model>> =
                                _serde::export::None;
                            while let _serde::export::Some(__key) =
                                match _serde::de::MapAccess::next_key::<__Field>(&mut __map) {
                                    _serde::export::Ok(__val) => __val,
                                    _serde::export::Err(__err) => {
                                        return _serde::export::Err(__err);
                                    }
                                }
                            {
                                match __key {
                                    __Field::__field0 => {
                                        if _serde::export::Option::is_some(&__field0) {
                                            return _serde::export::Err(
                                                <__A::Error as _serde::de::Error>::duplicate_field(
                                                    "mode",
                                                ),
                                            );
                                        }
                                        __field0 = _serde::export::Some(
                                            match _serde::de::MapAccess::next_value::<Option<String>>(
                                                &mut __map,
                                            ) {
                                                _serde::export::Ok(__val) => __val,
                                                _serde::export::Err(__err) => {
                                                    return _serde::export::Err(__err);
                                                }
                                            },
                                        );
                                    }
                                    __Field::__field1 => {
                                        if _serde::export::Option::is_some(&__field1) {
                                            return _serde::export::Err(
                                                <__A::Error as _serde::de::Error>::duplicate_field(
                                                    "check",
                                                ),
                                            );
                                        }
                                        __field1 = _serde::export::Some(
                                            match _serde::de::MapAccess::next_value::<Option<String>>(
                                                &mut __map,
                                            ) {
                                                _serde::export::Ok(__val) => __val,
                                                _serde::export::Err(__err) => {
                                                    return _serde::export::Err(__err);
                                                }
                                            },
                                        );
                                    }
                                    __Field::__field2 => {
                                        if _serde::export::Option::is_some(&__field2) {
                                            return _serde::export::Err(
                                                <__A::Error as _serde::de::Error>::duplicate_field(
                                                    "model",
                                                ),
                                            );
                                        }
                                        __field2 = _serde::export::Some(
                                            match _serde::de::MapAccess::next_value::<Option<Model>>(
                                                &mut __map,
                                            ) {
                                                _serde::export::Ok(__val) => __val,
                                                _serde::export::Err(__err) => {
                                                    return _serde::export::Err(__err);
                                                }
                                            },
                                        );
                                    }
                                    _ => {
                                        let _ = match _serde::de::MapAccess::next_value::<
                                            _serde::de::IgnoredAny,
                                        >(
                                            &mut __map
                                        ) {
                                            _serde::export::Ok(__val) => __val,
                                            _serde::export::Err(__err) => {
                                                return _serde::export::Err(__err);
                                            }
                                        };
                                    }
                                }
                            }
                            let __field0 = match __field0 {
                                _serde::export::Some(__field0) => __field0,
                                _serde::export::None => {
                                    match _serde::private::de::missing_field("mode") {
                                        _serde::export::Ok(__val) => __val,
                                        _serde::export::Err(__err) => {
                                            return _serde::export::Err(__err);
                                        }
                                    }
                                }
                            };
                            let __field1 = match __field1 {
                                _serde::export::Some(__field1) => __field1,
                                _serde::export::None => {
                                    match _serde::private::de::missing_field("check") {
                                        _serde::export::Ok(__val) => __val,
                                        _serde::export::Err(__err) => {
                                            return _serde::export::Err(__err);
                                        }
                                    }
                                }
                            };
                            let __field2 = match __field2 {
                                _serde::export::Some(__field2) => __field2,
                                _serde::export::None => {
                                    match _serde::private::de::missing_field("model") {
                                        _serde::export::Ok(__val) => __val,
                                        _serde::export::Err(__err) => {
                                            return _serde::export::Err(__err);
                                        }
                                    }
                                }
                            };
                            _serde::export::Ok(CPU {
                                mode: __field0,
                                check: __field1,
                                model: __field2,
                            })
                        }
                    }
                    const FIELDS: &'static [&'static str] = &["mode", "check", "model"];
                    _serde::Deserializer::deserialize_struct(
                        __deserializer,
                        "CPU",
                        FIELDS,
                        __Visitor {
                            marker: _serde::export::PhantomData::<CPU>,
                            lifetime: _serde::export::PhantomData,
                        },
                    )
                }
            }
        };
        #[xml(tag = "address")]
        pub struct Address {
            #[xml(attr = "type")]
            pub r#type: Option<String>,
            #[xml(attr = "domain")]
            pub domain: Option<String>,
            #[xml(attr = "bus")]
            pub bus: Option<String>,
            #[xml(attr = "slot")]
            pub slot: Option<String>,
            #[xml(attr = "function")]
            pub function: Option<String>,
            #[xml(attr = "controller")]
            pub controller: Option<u16>,
            #[xml(attr = "target")]
            pub target: Option<u16>,
            #[xml(attr = "unit")]
            pub unit: Option<u32>,
            #[xml(attr = "port")]
            pub port: Option<u16>,
            #[xml(text)]
            text: String,
        }
        impl<'__input> strong_xml::XmlRead<'__input> for Address {
            fn from_reader(
                mut reader: &mut strong_xml::XmlReader<'__input>,
            ) -> strong_xml::XmlResult<Self> {
                use strong_xml::xmlparser::{ElementEnd, Token, Tokenizer};
                use strong_xml::XmlError;
                let mut __self_type = None;
                let mut __self_domain = None;
                let mut __self_bus = None;
                let mut __self_slot = None;
                let mut __self_function = None;
                let mut __self_controller = None;
                let mut __self_target = None;
                let mut __self_unit = None;
                let mut __self_port = None;
                let __self_text;
                reader.read_till_element_start("address")?;
                while let Some((__key, __value)) = reader.find_attribute()? {
                    match __key {
                        "type" => {
                            __self_type = Some(
                                <String as std::str::FromStr>::from_str(&__value)
                                    .map_err(|e| XmlError::FromStr(e.into()))?,
                            );
                        }
                        "domain" => {
                            __self_domain = Some(
                                <String as std::str::FromStr>::from_str(&__value)
                                    .map_err(|e| XmlError::FromStr(e.into()))?,
                            );
                        }
                        "bus" => {
                            __self_bus = Some(
                                <String as std::str::FromStr>::from_str(&__value)
                                    .map_err(|e| XmlError::FromStr(e.into()))?,
                            );
                        }
                        "slot" => {
                            __self_slot = Some(
                                <String as std::str::FromStr>::from_str(&__value)
                                    .map_err(|e| XmlError::FromStr(e.into()))?,
                            );
                        }
                        "function" => {
                            __self_function = Some(
                                <String as std::str::FromStr>::from_str(&__value)
                                    .map_err(|e| XmlError::FromStr(e.into()))?,
                            );
                        }
                        "controller" => {
                            __self_controller = Some(
                                <u16 as std::str::FromStr>::from_str(&__value)
                                    .map_err(|e| XmlError::FromStr(e.into()))?,
                            );
                        }
                        "target" => {
                            __self_target = Some(
                                <u16 as std::str::FromStr>::from_str(&__value)
                                    .map_err(|e| XmlError::FromStr(e.into()))?,
                            );
                        }
                        "unit" => {
                            __self_unit = Some(
                                <u32 as std::str::FromStr>::from_str(&__value)
                                    .map_err(|e| XmlError::FromStr(e.into()))?,
                            );
                        }
                        "port" => {
                            __self_port = Some(
                                <u16 as std::str::FromStr>::from_str(&__value)
                                    .map_err(|e| XmlError::FromStr(e.into()))?,
                            );
                        }
                        key => {}
                    }
                }
                let __value = reader.read_text("address")?;
                __self_text = Some(
                    <String as std::str::FromStr>::from_str(&__value)
                        .map_err(|e| XmlError::FromStr(e.into()))?,
                );
                let __res = Address {
                    r#type: __self_type,
                    domain: __self_domain,
                    bus: __self_bus,
                    slot: __self_slot,
                    function: __self_function,
                    controller: __self_controller,
                    target: __self_target,
                    unit: __self_unit,
                    port: __self_port,
                    text: __self_text.ok_or(XmlError::MissingField {
                        name: "Address".to_owned(),
                        field: "text".to_owned(),
                    })?,
                };
                return Ok(__res);
            }
        }
        impl strong_xml::XmlWrite for Address {
            fn to_writer<W: std::io::Write>(
                &self,
                mut writer: &mut strong_xml::XmlWriter<W>,
            ) -> strong_xml::XmlResult<()> {
                let Address {
                    r#type: __self_type,
                    domain: __self_domain,
                    bus: __self_bus,
                    slot: __self_slot,
                    function: __self_function,
                    controller: __self_controller,
                    target: __self_target,
                    unit: __self_unit,
                    port: __self_port,
                    text: __self_text,
                } = self;
                writer.write_element_start("address")?;
                if let Some(__value) = __self_type {
                    writer.write_attribute("type", &{
                        let res = ::alloc::fmt::format(::core::fmt::Arguments::new_v1(
                            &[""],
                            &match (&__value,) {
                                (arg0,) => [::core::fmt::ArgumentV1::new(
                                    arg0,
                                    ::core::fmt::Display::fmt,
                                )],
                            },
                        ));
                        res
                    })?;
                }
                if let Some(__value) = __self_domain {
                    writer.write_attribute("domain", &{
                        let res = ::alloc::fmt::format(::core::fmt::Arguments::new_v1(
                            &[""],
                            &match (&__value,) {
                                (arg0,) => [::core::fmt::ArgumentV1::new(
                                    arg0,
                                    ::core::fmt::Display::fmt,
                                )],
                            },
                        ));
                        res
                    })?;
                }
                if let Some(__value) = __self_bus {
                    writer.write_attribute("bus", &{
                        let res = ::alloc::fmt::format(::core::fmt::Arguments::new_v1(
                            &[""],
                            &match (&__value,) {
                                (arg0,) => [::core::fmt::ArgumentV1::new(
                                    arg0,
                                    ::core::fmt::Display::fmt,
                                )],
                            },
                        ));
                        res
                    })?;
                }
                if let Some(__value) = __self_slot {
                    writer.write_attribute("slot", &{
                        let res = ::alloc::fmt::format(::core::fmt::Arguments::new_v1(
                            &[""],
                            &match (&__value,) {
                                (arg0,) => [::core::fmt::ArgumentV1::new(
                                    arg0,
                                    ::core::fmt::Display::fmt,
                                )],
                            },
                        ));
                        res
                    })?;
                }
                if let Some(__value) = __self_function {
                    writer.write_attribute("function", &{
                        let res = ::alloc::fmt::format(::core::fmt::Arguments::new_v1(
                            &[""],
                            &match (&__value,) {
                                (arg0,) => [::core::fmt::ArgumentV1::new(
                                    arg0,
                                    ::core::fmt::Display::fmt,
                                )],
                            },
                        ));
                        res
                    })?;
                }
                if let Some(__value) = __self_controller {
                    writer.write_attribute("controller", &{
                        let res = ::alloc::fmt::format(::core::fmt::Arguments::new_v1(
                            &[""],
                            &match (&__value,) {
                                (arg0,) => [::core::fmt::ArgumentV1::new(
                                    arg0,
                                    ::core::fmt::Display::fmt,
                                )],
                            },
                        ));
                        res
                    })?;
                }
                if let Some(__value) = __self_target {
                    writer.write_attribute("target", &{
                        let res = ::alloc::fmt::format(::core::fmt::Arguments::new_v1(
                            &[""],
                            &match (&__value,) {
                                (arg0,) => [::core::fmt::ArgumentV1::new(
                                    arg0,
                                    ::core::fmt::Display::fmt,
                                )],
                            },
                        ));
                        res
                    })?;
                }
                if let Some(__value) = __self_unit {
                    writer.write_attribute("unit", &{
                        let res = ::alloc::fmt::format(::core::fmt::Arguments::new_v1(
                            &[""],
                            &match (&__value,) {
                                (arg0,) => [::core::fmt::ArgumentV1::new(
                                    arg0,
                                    ::core::fmt::Display::fmt,
                                )],
                            },
                        ));
                        res
                    })?;
                }
                if let Some(__value) = __self_port {
                    writer.write_attribute("port", &{
                        let res = ::alloc::fmt::format(::core::fmt::Arguments::new_v1(
                            &[""],
                            &match (&__value,) {
                                (arg0,) => [::core::fmt::ArgumentV1::new(
                                    arg0,
                                    ::core::fmt::Display::fmt,
                                )],
                            },
                        ));
                        res
                    })?;
                }
                writer.write_element_end_open()?;
                let __value = &__self_text;
                writer.write_text(&{
                    let res = ::alloc::fmt::format(::core::fmt::Arguments::new_v1(
                        &[""],
                        &match (&__value,) {
                            (arg0,) => [::core::fmt::ArgumentV1::new(
                                arg0,
                                ::core::fmt::Display::fmt,
                            )],
                        },
                    ));
                    res
                })?;
                writer.write_element_end_close("address")?;
                Ok(())
            }
        }
        impl ::core::marker::StructuralPartialEq for Address {}
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::cmp::PartialEq for Address {
            #[inline]
            fn eq(&self, other: &Address) -> bool {
                match *other {
                    Address {
                        r#type: ref __self_1_0,
                        domain: ref __self_1_1,
                        bus: ref __self_1_2,
                        slot: ref __self_1_3,
                        function: ref __self_1_4,
                        controller: ref __self_1_5,
                        target: ref __self_1_6,
                        unit: ref __self_1_7,
                        port: ref __self_1_8,
                        text: ref __self_1_9,
                    } => match *self {
                        Address {
                            r#type: ref __self_0_0,
                            domain: ref __self_0_1,
                            bus: ref __self_0_2,
                            slot: ref __self_0_3,
                            function: ref __self_0_4,
                            controller: ref __self_0_5,
                            target: ref __self_0_6,
                            unit: ref __self_0_7,
                            port: ref __self_0_8,
                            text: ref __self_0_9,
                        } => {
                            (*__self_0_0) == (*__self_1_0)
                                && (*__self_0_1) == (*__self_1_1)
                                && (*__self_0_2) == (*__self_1_2)
                                && (*__self_0_3) == (*__self_1_3)
                                && (*__self_0_4) == (*__self_1_4)
                                && (*__self_0_5) == (*__self_1_5)
                                && (*__self_0_6) == (*__self_1_6)
                                && (*__self_0_7) == (*__self_1_7)
                                && (*__self_0_8) == (*__self_1_8)
                                && (*__self_0_9) == (*__self_1_9)
                        }
                    },
                }
            }
            #[inline]
            fn ne(&self, other: &Address) -> bool {
                match *other {
                    Address {
                        r#type: ref __self_1_0,
                        domain: ref __self_1_1,
                        bus: ref __self_1_2,
                        slot: ref __self_1_3,
                        function: ref __self_1_4,
                        controller: ref __self_1_5,
                        target: ref __self_1_6,
                        unit: ref __self_1_7,
                        port: ref __self_1_8,
                        text: ref __self_1_9,
                    } => match *self {
                        Address {
                            r#type: ref __self_0_0,
                            domain: ref __self_0_1,
                            bus: ref __self_0_2,
                            slot: ref __self_0_3,
                            function: ref __self_0_4,
                            controller: ref __self_0_5,
                            target: ref __self_0_6,
                            unit: ref __self_0_7,
                            port: ref __self_0_8,
                            text: ref __self_0_9,
                        } => {
                            (*__self_0_0) != (*__self_1_0)
                                || (*__self_0_1) != (*__self_1_1)
                                || (*__self_0_2) != (*__self_1_2)
                                || (*__self_0_3) != (*__self_1_3)
                                || (*__self_0_4) != (*__self_1_4)
                                || (*__self_0_5) != (*__self_1_5)
                                || (*__self_0_6) != (*__self_1_6)
                                || (*__self_0_7) != (*__self_1_7)
                                || (*__self_0_8) != (*__self_1_8)
                                || (*__self_0_9) != (*__self_1_9)
                        }
                    },
                }
            }
        }
        impl ::core::marker::StructuralEq for Address {}
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::cmp::Eq for Address {
            #[inline]
            #[doc(hidden)]
            fn assert_receiver_is_total_eq(&self) -> () {
                {
                    let _: ::core::cmp::AssertParamIsEq<Option<String>>;
                    let _: ::core::cmp::AssertParamIsEq<Option<String>>;
                    let _: ::core::cmp::AssertParamIsEq<Option<String>>;
                    let _: ::core::cmp::AssertParamIsEq<Option<String>>;
                    let _: ::core::cmp::AssertParamIsEq<Option<String>>;
                    let _: ::core::cmp::AssertParamIsEq<Option<u16>>;
                    let _: ::core::cmp::AssertParamIsEq<Option<u16>>;
                    let _: ::core::cmp::AssertParamIsEq<Option<u32>>;
                    let _: ::core::cmp::AssertParamIsEq<Option<u16>>;
                    let _: ::core::cmp::AssertParamIsEq<String>;
                }
            }
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::fmt::Debug for Address {
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                match *self {
                    Address {
                        r#type: ref __self_0_0,
                        domain: ref __self_0_1,
                        bus: ref __self_0_2,
                        slot: ref __self_0_3,
                        function: ref __self_0_4,
                        controller: ref __self_0_5,
                        target: ref __self_0_6,
                        unit: ref __self_0_7,
                        port: ref __self_0_8,
                        text: ref __self_0_9,
                    } => {
                        let mut debug_trait_builder = f.debug_struct("Address");
                        let _ = debug_trait_builder.field("type", &&(*__self_0_0));
                        let _ = debug_trait_builder.field("domain", &&(*__self_0_1));
                        let _ = debug_trait_builder.field("bus", &&(*__self_0_2));
                        let _ = debug_trait_builder.field("slot", &&(*__self_0_3));
                        let _ = debug_trait_builder.field("function", &&(*__self_0_4));
                        let _ = debug_trait_builder.field("controller", &&(*__self_0_5));
                        let _ = debug_trait_builder.field("target", &&(*__self_0_6));
                        let _ = debug_trait_builder.field("unit", &&(*__self_0_7));
                        let _ = debug_trait_builder.field("port", &&(*__self_0_8));
                        let _ = debug_trait_builder.field("text", &&(*__self_0_9));
                        debug_trait_builder.finish()
                    }
                }
            }
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::clone::Clone for Address {
            #[inline]
            fn clone(&self) -> Address {
                match *self {
                    Address {
                        r#type: ref __self_0_0,
                        domain: ref __self_0_1,
                        bus: ref __self_0_2,
                        slot: ref __self_0_3,
                        function: ref __self_0_4,
                        controller: ref __self_0_5,
                        target: ref __self_0_6,
                        unit: ref __self_0_7,
                        port: ref __self_0_8,
                        text: ref __self_0_9,
                    } => Address {
                        r#type: ::core::clone::Clone::clone(&(*__self_0_0)),
                        domain: ::core::clone::Clone::clone(&(*__self_0_1)),
                        bus: ::core::clone::Clone::clone(&(*__self_0_2)),
                        slot: ::core::clone::Clone::clone(&(*__self_0_3)),
                        function: ::core::clone::Clone::clone(&(*__self_0_4)),
                        controller: ::core::clone::Clone::clone(&(*__self_0_5)),
                        target: ::core::clone::Clone::clone(&(*__self_0_6)),
                        unit: ::core::clone::Clone::clone(&(*__self_0_7)),
                        port: ::core::clone::Clone::clone(&(*__self_0_8)),
                        text: ::core::clone::Clone::clone(&(*__self_0_9)),
                    },
                }
            }
        }
        #[doc(hidden)]
        #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
        const _: () = {
            #[allow(rust_2018_idioms, clippy::useless_attribute)]
            extern crate serde as _serde;
            #[automatically_derived]
            impl _serde::Serialize for Address {
                fn serialize<__S>(
                    &self,
                    __serializer: __S,
                ) -> _serde::export::Result<__S::Ok, __S::Error>
                where
                    __S: _serde::Serializer,
                {
                    let mut __serde_state = match _serde::Serializer::serialize_struct(
                        __serializer,
                        "Address",
                        false as usize + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1 + 1,
                    ) {
                        _serde::export::Ok(__val) => __val,
                        _serde::export::Err(__err) => {
                            return _serde::export::Err(__err);
                        }
                    };
                    match _serde::ser::SerializeStruct::serialize_field(
                        &mut __serde_state,
                        "type",
                        &self.r#type,
                    ) {
                        _serde::export::Ok(__val) => __val,
                        _serde::export::Err(__err) => {
                            return _serde::export::Err(__err);
                        }
                    };
                    match _serde::ser::SerializeStruct::serialize_field(
                        &mut __serde_state,
                        "domain",
                        &self.domain,
                    ) {
                        _serde::export::Ok(__val) => __val,
                        _serde::export::Err(__err) => {
                            return _serde::export::Err(__err);
                        }
                    };
                    match _serde::ser::SerializeStruct::serialize_field(
                        &mut __serde_state,
                        "bus",
                        &self.bus,
                    ) {
                        _serde::export::Ok(__val) => __val,
                        _serde::export::Err(__err) => {
                            return _serde::export::Err(__err);
                        }
                    };
                    match _serde::ser::SerializeStruct::serialize_field(
                        &mut __serde_state,
                        "slot",
                        &self.slot,
                    ) {
                        _serde::export::Ok(__val) => __val,
                        _serde::export::Err(__err) => {
                            return _serde::export::Err(__err);
                        }
                    };
                    match _serde::ser::SerializeStruct::serialize_field(
                        &mut __serde_state,
                        "function",
                        &self.function,
                    ) {
                        _serde::export::Ok(__val) => __val,
                        _serde::export::Err(__err) => {
                            return _serde::export::Err(__err);
                        }
                    };
                    match _serde::ser::SerializeStruct::serialize_field(
                        &mut __serde_state,
                        "controller",
                        &self.controller,
                    ) {
                        _serde::export::Ok(__val) => __val,
                        _serde::export::Err(__err) => {
                            return _serde::export::Err(__err);
                        }
                    };
                    match _serde::ser::SerializeStruct::serialize_field(
                        &mut __serde_state,
                        "target",
                        &self.target,
                    ) {
                        _serde::export::Ok(__val) => __val,
                        _serde::export::Err(__err) => {
                            return _serde::export::Err(__err);
                        }
                    };
                    match _serde::ser::SerializeStruct::serialize_field(
                        &mut __serde_state,
                        "unit",
                        &self.unit,
                    ) {
                        _serde::export::Ok(__val) => __val,
                        _serde::export::Err(__err) => {
                            return _serde::export::Err(__err);
                        }
                    };
                    match _serde::ser::SerializeStruct::serialize_field(
                        &mut __serde_state,
                        "port",
                        &self.port,
                    ) {
                        _serde::export::Ok(__val) => __val,
                        _serde::export::Err(__err) => {
                            return _serde::export::Err(__err);
                        }
                    };
                    match _serde::ser::SerializeStruct::serialize_field(
                        &mut __serde_state,
                        "text",
                        &self.text,
                    ) {
                        _serde::export::Ok(__val) => __val,
                        _serde::export::Err(__err) => {
                            return _serde::export::Err(__err);
                        }
                    };
                    _serde::ser::SerializeStruct::end(__serde_state)
                }
            }
        };
        #[doc(hidden)]
        #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
        const _: () = {
            #[allow(rust_2018_idioms, clippy::useless_attribute)]
            extern crate serde as _serde;
            #[automatically_derived]
            impl<'de> _serde::Deserialize<'de> for Address {
                fn deserialize<__D>(__deserializer: __D) -> _serde::export::Result<Self, __D::Error>
                where
                    __D: _serde::Deserializer<'de>,
                {
                    #[allow(non_camel_case_types)]
                    enum __Field {
                        __field0,
                        __field1,
                        __field2,
                        __field3,
                        __field4,
                        __field5,
                        __field6,
                        __field7,
                        __field8,
                        __field9,
                        __ignore,
                    }
                    struct __FieldVisitor;
                    impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                        type Value = __Field;
                        fn expecting(
                            &self,
                            __formatter: &mut _serde::export::Formatter,
                        ) -> _serde::export::fmt::Result {
                            _serde::export::Formatter::write_str(__formatter, "field identifier")
                        }
                        fn visit_u64<__E>(
                            self,
                            __value: u64,
                        ) -> _serde::export::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                0u64 => _serde::export::Ok(__Field::__field0),
                                1u64 => _serde::export::Ok(__Field::__field1),
                                2u64 => _serde::export::Ok(__Field::__field2),
                                3u64 => _serde::export::Ok(__Field::__field3),
                                4u64 => _serde::export::Ok(__Field::__field4),
                                5u64 => _serde::export::Ok(__Field::__field5),
                                6u64 => _serde::export::Ok(__Field::__field6),
                                7u64 => _serde::export::Ok(__Field::__field7),
                                8u64 => _serde::export::Ok(__Field::__field8),
                                9u64 => _serde::export::Ok(__Field::__field9),
                                _ => _serde::export::Err(_serde::de::Error::invalid_value(
                                    _serde::de::Unexpected::Unsigned(__value),
                                    &"field index 0 <= i < 10",
                                )),
                            }
                        }
                        fn visit_str<__E>(
                            self,
                            __value: &str,
                        ) -> _serde::export::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                "type" => _serde::export::Ok(__Field::__field0),
                                "domain" => _serde::export::Ok(__Field::__field1),
                                "bus" => _serde::export::Ok(__Field::__field2),
                                "slot" => _serde::export::Ok(__Field::__field3),
                                "function" => _serde::export::Ok(__Field::__field4),
                                "controller" => _serde::export::Ok(__Field::__field5),
                                "target" => _serde::export::Ok(__Field::__field6),
                                "unit" => _serde::export::Ok(__Field::__field7),
                                "port" => _serde::export::Ok(__Field::__field8),
                                "text" => _serde::export::Ok(__Field::__field9),
                                _ => _serde::export::Ok(__Field::__ignore),
                            }
                        }
                        fn visit_bytes<__E>(
                            self,
                            __value: &[u8],
                        ) -> _serde::export::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                b"type" => _serde::export::Ok(__Field::__field0),
                                b"domain" => _serde::export::Ok(__Field::__field1),
                                b"bus" => _serde::export::Ok(__Field::__field2),
                                b"slot" => _serde::export::Ok(__Field::__field3),
                                b"function" => _serde::export::Ok(__Field::__field4),
                                b"controller" => _serde::export::Ok(__Field::__field5),
                                b"target" => _serde::export::Ok(__Field::__field6),
                                b"unit" => _serde::export::Ok(__Field::__field7),
                                b"port" => _serde::export::Ok(__Field::__field8),
                                b"text" => _serde::export::Ok(__Field::__field9),
                                _ => _serde::export::Ok(__Field::__ignore),
                            }
                        }
                    }
                    impl<'de> _serde::Deserialize<'de> for __Field {
                        #[inline]
                        fn deserialize<__D>(
                            __deserializer: __D,
                        ) -> _serde::export::Result<Self, __D::Error>
                        where
                            __D: _serde::Deserializer<'de>,
                        {
                            _serde::Deserializer::deserialize_identifier(
                                __deserializer,
                                __FieldVisitor,
                            )
                        }
                    }
                    struct __Visitor<'de> {
                        marker: _serde::export::PhantomData<Address>,
                        lifetime: _serde::export::PhantomData<&'de ()>,
                    }
                    impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                        type Value = Address;
                        fn expecting(
                            &self,
                            __formatter: &mut _serde::export::Formatter,
                        ) -> _serde::export::fmt::Result {
                            _serde::export::Formatter::write_str(__formatter, "struct Address")
                        }
                        #[inline]
                        fn visit_seq<__A>(
                            self,
                            mut __seq: __A,
                        ) -> _serde::export::Result<Self::Value, __A::Error>
                        where
                            __A: _serde::de::SeqAccess<'de>,
                        {
                            let __field0 = match match _serde::de::SeqAccess::next_element::<
                                Option<String>,
                            >(&mut __seq)
                            {
                                _serde::export::Ok(__val) => __val,
                                _serde::export::Err(__err) => {
                                    return _serde::export::Err(__err);
                                }
                            } {
                                _serde::export::Some(__value) => __value,
                                _serde::export::None => {
                                    return _serde::export::Err(_serde::de::Error::invalid_length(
                                        0usize,
                                        &"struct Address with 10 elements",
                                    ));
                                }
                            };
                            let __field1 = match match _serde::de::SeqAccess::next_element::<
                                Option<String>,
                            >(&mut __seq)
                            {
                                _serde::export::Ok(__val) => __val,
                                _serde::export::Err(__err) => {
                                    return _serde::export::Err(__err);
                                }
                            } {
                                _serde::export::Some(__value) => __value,
                                _serde::export::None => {
                                    return _serde::export::Err(_serde::de::Error::invalid_length(
                                        1usize,
                                        &"struct Address with 10 elements",
                                    ));
                                }
                            };
                            let __field2 = match match _serde::de::SeqAccess::next_element::<
                                Option<String>,
                            >(&mut __seq)
                            {
                                _serde::export::Ok(__val) => __val,
                                _serde::export::Err(__err) => {
                                    return _serde::export::Err(__err);
                                }
                            } {
                                _serde::export::Some(__value) => __value,
                                _serde::export::None => {
                                    return _serde::export::Err(_serde::de::Error::invalid_length(
                                        2usize,
                                        &"struct Address with 10 elements",
                                    ));
                                }
                            };
                            let __field3 = match match _serde::de::SeqAccess::next_element::<
                                Option<String>,
                            >(&mut __seq)
                            {
                                _serde::export::Ok(__val) => __val,
                                _serde::export::Err(__err) => {
                                    return _serde::export::Err(__err);
                                }
                            } {
                                _serde::export::Some(__value) => __value,
                                _serde::export::None => {
                                    return _serde::export::Err(_serde::de::Error::invalid_length(
                                        3usize,
                                        &"struct Address with 10 elements",
                                    ));
                                }
                            };
                            let __field4 = match match _serde::de::SeqAccess::next_element::<
                                Option<String>,
                            >(&mut __seq)
                            {
                                _serde::export::Ok(__val) => __val,
                                _serde::export::Err(__err) => {
                                    return _serde::export::Err(__err);
                                }
                            } {
                                _serde::export::Some(__value) => __value,
                                _serde::export::None => {
                                    return _serde::export::Err(_serde::de::Error::invalid_length(
                                        4usize,
                                        &"struct Address with 10 elements",
                                    ));
                                }
                            };
                            let __field5 = match match _serde::de::SeqAccess::next_element::<
                                Option<u16>,
                            >(&mut __seq)
                            {
                                _serde::export::Ok(__val) => __val,
                                _serde::export::Err(__err) => {
                                    return _serde::export::Err(__err);
                                }
                            } {
                                _serde::export::Some(__value) => __value,
                                _serde::export::None => {
                                    return _serde::export::Err(_serde::de::Error::invalid_length(
                                        5usize,
                                        &"struct Address with 10 elements",
                                    ));
                                }
                            };
                            let __field6 = match match _serde::de::SeqAccess::next_element::<
                                Option<u16>,
                            >(&mut __seq)
                            {
                                _serde::export::Ok(__val) => __val,
                                _serde::export::Err(__err) => {
                                    return _serde::export::Err(__err);
                                }
                            } {
                                _serde::export::Some(__value) => __value,
                                _serde::export::None => {
                                    return _serde::export::Err(_serde::de::Error::invalid_length(
                                        6usize,
                                        &"struct Address with 10 elements",
                                    ));
                                }
                            };
                            let __field7 = match match _serde::de::SeqAccess::next_element::<
                                Option<u32>,
                            >(&mut __seq)
                            {
                                _serde::export::Ok(__val) => __val,
                                _serde::export::Err(__err) => {
                                    return _serde::export::Err(__err);
                                }
                            } {
                                _serde::export::Some(__value) => __value,
                                _serde::export::None => {
                                    return _serde::export::Err(_serde::de::Error::invalid_length(
                                        7usize,
                                        &"struct Address with 10 elements",
                                    ));
                                }
                            };
                            let __field8 = match match _serde::de::SeqAccess::next_element::<
                                Option<u16>,
                            >(&mut __seq)
                            {
                                _serde::export::Ok(__val) => __val,
                                _serde::export::Err(__err) => {
                                    return _serde::export::Err(__err);
                                }
                            } {
                                _serde::export::Some(__value) => __value,
                                _serde::export::None => {
                                    return _serde::export::Err(_serde::de::Error::invalid_length(
                                        8usize,
                                        &"struct Address with 10 elements",
                                    ));
                                }
                            };
                            let __field9 = match match _serde::de::SeqAccess::next_element::<String>(
                                &mut __seq,
                            ) {
                                _serde::export::Ok(__val) => __val,
                                _serde::export::Err(__err) => {
                                    return _serde::export::Err(__err);
                                }
                            } {
                                _serde::export::Some(__value) => __value,
                                _serde::export::None => {
                                    return _serde::export::Err(_serde::de::Error::invalid_length(
                                        9usize,
                                        &"struct Address with 10 elements",
                                    ));
                                }
                            };
                            _serde::export::Ok(Address {
                                r#type: __field0,
                                domain: __field1,
                                bus: __field2,
                                slot: __field3,
                                function: __field4,
                                controller: __field5,
                                target: __field6,
                                unit: __field7,
                                port: __field8,
                                text: __field9,
                            })
                        }
                        #[inline]
                        fn visit_map<__A>(
                            self,
                            mut __map: __A,
                        ) -> _serde::export::Result<Self::Value, __A::Error>
                        where
                            __A: _serde::de::MapAccess<'de>,
                        {
                            let mut __field0: _serde::export::Option<Option<String>> =
                                _serde::export::None;
                            let mut __field1: _serde::export::Option<Option<String>> =
                                _serde::export::None;
                            let mut __field2: _serde::export::Option<Option<String>> =
                                _serde::export::None;
                            let mut __field3: _serde::export::Option<Option<String>> =
                                _serde::export::None;
                            let mut __field4: _serde::export::Option<Option<String>> =
                                _serde::export::None;
                            let mut __field5: _serde::export::Option<Option<u16>> =
                                _serde::export::None;
                            let mut __field6: _serde::export::Option<Option<u16>> =
                                _serde::export::None;
                            let mut __field7: _serde::export::Option<Option<u32>> =
                                _serde::export::None;
                            let mut __field8: _serde::export::Option<Option<u16>> =
                                _serde::export::None;
                            let mut __field9: _serde::export::Option<String> = _serde::export::None;
                            while let _serde::export::Some(__key) =
                                match _serde::de::MapAccess::next_key::<__Field>(&mut __map) {
                                    _serde::export::Ok(__val) => __val,
                                    _serde::export::Err(__err) => {
                                        return _serde::export::Err(__err);
                                    }
                                }
                            {
                                match __key {
                                    __Field::__field0 => {
                                        if _serde::export::Option::is_some(&__field0) {
                                            return _serde::export::Err(
                                                <__A::Error as _serde::de::Error>::duplicate_field(
                                                    "type",
                                                ),
                                            );
                                        }
                                        __field0 = _serde::export::Some(
                                            match _serde::de::MapAccess::next_value::<Option<String>>(
                                                &mut __map,
                                            ) {
                                                _serde::export::Ok(__val) => __val,
                                                _serde::export::Err(__err) => {
                                                    return _serde::export::Err(__err);
                                                }
                                            },
                                        );
                                    }
                                    __Field::__field1 => {
                                        if _serde::export::Option::is_some(&__field1) {
                                            return _serde::export::Err(
                                                <__A::Error as _serde::de::Error>::duplicate_field(
                                                    "domain",
                                                ),
                                            );
                                        }
                                        __field1 = _serde::export::Some(
                                            match _serde::de::MapAccess::next_value::<Option<String>>(
                                                &mut __map,
                                            ) {
                                                _serde::export::Ok(__val) => __val,
                                                _serde::export::Err(__err) => {
                                                    return _serde::export::Err(__err);
                                                }
                                            },
                                        );
                                    }
                                    __Field::__field2 => {
                                        if _serde::export::Option::is_some(&__field2) {
                                            return _serde::export::Err(
                                                <__A::Error as _serde::de::Error>::duplicate_field(
                                                    "bus",
                                                ),
                                            );
                                        }
                                        __field2 = _serde::export::Some(
                                            match _serde::de::MapAccess::next_value::<Option<String>>(
                                                &mut __map,
                                            ) {
                                                _serde::export::Ok(__val) => __val,
                                                _serde::export::Err(__err) => {
                                                    return _serde::export::Err(__err);
                                                }
                                            },
                                        );
                                    }
                                    __Field::__field3 => {
                                        if _serde::export::Option::is_some(&__field3) {
                                            return _serde::export::Err(
                                                <__A::Error as _serde::de::Error>::duplicate_field(
                                                    "slot",
                                                ),
                                            );
                                        }
                                        __field3 = _serde::export::Some(
                                            match _serde::de::MapAccess::next_value::<Option<String>>(
                                                &mut __map,
                                            ) {
                                                _serde::export::Ok(__val) => __val,
                                                _serde::export::Err(__err) => {
                                                    return _serde::export::Err(__err);
                                                }
                                            },
                                        );
                                    }
                                    __Field::__field4 => {
                                        if _serde::export::Option::is_some(&__field4) {
                                            return _serde::export::Err(
                                                <__A::Error as _serde::de::Error>::duplicate_field(
                                                    "function",
                                                ),
                                            );
                                        }
                                        __field4 = _serde::export::Some(
                                            match _serde::de::MapAccess::next_value::<Option<String>>(
                                                &mut __map,
                                            ) {
                                                _serde::export::Ok(__val) => __val,
                                                _serde::export::Err(__err) => {
                                                    return _serde::export::Err(__err);
                                                }
                                            },
                                        );
                                    }
                                    __Field::__field5 => {
                                        if _serde::export::Option::is_some(&__field5) {
                                            return _serde::export::Err(
                                                <__A::Error as _serde::de::Error>::duplicate_field(
                                                    "controller",
                                                ),
                                            );
                                        }
                                        __field5 = _serde::export::Some(
                                            match _serde::de::MapAccess::next_value::<Option<u16>>(
                                                &mut __map,
                                            ) {
                                                _serde::export::Ok(__val) => __val,
                                                _serde::export::Err(__err) => {
                                                    return _serde::export::Err(__err);
                                                }
                                            },
                                        );
                                    }
                                    __Field::__field6 => {
                                        if _serde::export::Option::is_some(&__field6) {
                                            return _serde::export::Err(
                                                <__A::Error as _serde::de::Error>::duplicate_field(
                                                    "target",
                                                ),
                                            );
                                        }
                                        __field6 = _serde::export::Some(
                                            match _serde::de::MapAccess::next_value::<Option<u16>>(
                                                &mut __map,
                                            ) {
                                                _serde::export::Ok(__val) => __val,
                                                _serde::export::Err(__err) => {
                                                    return _serde::export::Err(__err);
                                                }
                                            },
                                        );
                                    }
                                    __Field::__field7 => {
                                        if _serde::export::Option::is_some(&__field7) {
                                            return _serde::export::Err(
                                                <__A::Error as _serde::de::Error>::duplicate_field(
                                                    "unit",
                                                ),
                                            );
                                        }
                                        __field7 = _serde::export::Some(
                                            match _serde::de::MapAccess::next_value::<Option<u32>>(
                                                &mut __map,
                                            ) {
                                                _serde::export::Ok(__val) => __val,
                                                _serde::export::Err(__err) => {
                                                    return _serde::export::Err(__err);
                                                }
                                            },
                                        );
                                    }
                                    __Field::__field8 => {
                                        if _serde::export::Option::is_some(&__field8) {
                                            return _serde::export::Err(
                                                <__A::Error as _serde::de::Error>::duplicate_field(
                                                    "port",
                                                ),
                                            );
                                        }
                                        __field8 = _serde::export::Some(
                                            match _serde::de::MapAccess::next_value::<Option<u16>>(
                                                &mut __map,
                                            ) {
                                                _serde::export::Ok(__val) => __val,
                                                _serde::export::Err(__err) => {
                                                    return _serde::export::Err(__err);
                                                }
                                            },
                                        );
                                    }
                                    __Field::__field9 => {
                                        if _serde::export::Option::is_some(&__field9) {
                                            return _serde::export::Err(
                                                <__A::Error as _serde::de::Error>::duplicate_field(
                                                    "text",
                                                ),
                                            );
                                        }
                                        __field9 = _serde::export::Some(
                                            match _serde::de::MapAccess::next_value::<String>(
                                                &mut __map,
                                            ) {
                                                _serde::export::Ok(__val) => __val,
                                                _serde::export::Err(__err) => {
                                                    return _serde::export::Err(__err);
                                                }
                                            },
                                        );
                                    }
                                    _ => {
                                        let _ = match _serde::de::MapAccess::next_value::<
                                            _serde::de::IgnoredAny,
                                        >(
                                            &mut __map
                                        ) {
                                            _serde::export::Ok(__val) => __val,
                                            _serde::export::Err(__err) => {
                                                return _serde::export::Err(__err);
                                            }
                                        };
                                    }
                                }
                            }
                            let __field0 = match __field0 {
                                _serde::export::Some(__field0) => __field0,
                                _serde::export::None => {
                                    match _serde::private::de::missing_field("type") {
                                        _serde::export::Ok(__val) => __val,
                                        _serde::export::Err(__err) => {
                                            return _serde::export::Err(__err);
                                        }
                                    }
                                }
                            };
                            let __field1 = match __field1 {
                                _serde::export::Some(__field1) => __field1,
                                _serde::export::None => {
                                    match _serde::private::de::missing_field("domain") {
                                        _serde::export::Ok(__val) => __val,
                                        _serde::export::Err(__err) => {
                                            return _serde::export::Err(__err);
                                        }
                                    }
                                }
                            };
                            let __field2 = match __field2 {
                                _serde::export::Some(__field2) => __field2,
                                _serde::export::None => {
                                    match _serde::private::de::missing_field("bus") {
                                        _serde::export::Ok(__val) => __val,
                                        _serde::export::Err(__err) => {
                                            return _serde::export::Err(__err);
                                        }
                                    }
                                }
                            };
                            let __field3 = match __field3 {
                                _serde::export::Some(__field3) => __field3,
                                _serde::export::None => {
                                    match _serde::private::de::missing_field("slot") {
                                        _serde::export::Ok(__val) => __val,
                                        _serde::export::Err(__err) => {
                                            return _serde::export::Err(__err);
                                        }
                                    }
                                }
                            };
                            let __field4 = match __field4 {
                                _serde::export::Some(__field4) => __field4,
                                _serde::export::None => {
                                    match _serde::private::de::missing_field("function") {
                                        _serde::export::Ok(__val) => __val,
                                        _serde::export::Err(__err) => {
                                            return _serde::export::Err(__err);
                                        }
                                    }
                                }
                            };
                            let __field5 = match __field5 {
                                _serde::export::Some(__field5) => __field5,
                                _serde::export::None => {
                                    match _serde::private::de::missing_field("controller") {
                                        _serde::export::Ok(__val) => __val,
                                        _serde::export::Err(__err) => {
                                            return _serde::export::Err(__err);
                                        }
                                    }
                                }
                            };
                            let __field6 = match __field6 {
                                _serde::export::Some(__field6) => __field6,
                                _serde::export::None => {
                                    match _serde::private::de::missing_field("target") {
                                        _serde::export::Ok(__val) => __val,
                                        _serde::export::Err(__err) => {
                                            return _serde::export::Err(__err);
                                        }
                                    }
                                }
                            };
                            let __field7 = match __field7 {
                                _serde::export::Some(__field7) => __field7,
                                _serde::export::None => {
                                    match _serde::private::de::missing_field("unit") {
                                        _serde::export::Ok(__val) => __val,
                                        _serde::export::Err(__err) => {
                                            return _serde::export::Err(__err);
                                        }
                                    }
                                }
                            };
                            let __field8 = match __field8 {
                                _serde::export::Some(__field8) => __field8,
                                _serde::export::None => {
                                    match _serde::private::de::missing_field("port") {
                                        _serde::export::Ok(__val) => __val,
                                        _serde::export::Err(__err) => {
                                            return _serde::export::Err(__err);
                                        }
                                    }
                                }
                            };
                            let __field9 = match __field9 {
                                _serde::export::Some(__field9) => __field9,
                                _serde::export::None => {
                                    match _serde::private::de::missing_field("text") {
                                        _serde::export::Ok(__val) => __val,
                                        _serde::export::Err(__err) => {
                                            return _serde::export::Err(__err);
                                        }
                                    }
                                }
                            };
                            _serde::export::Ok(Address {
                                r#type: __field0,
                                domain: __field1,
                                bus: __field2,
                                slot: __field3,
                                function: __field4,
                                controller: __field5,
                                target: __field6,
                                unit: __field7,
                                port: __field8,
                                text: __field9,
                            })
                        }
                    }
                    const FIELDS: &'static [&'static str] = &[
                        "type",
                        "domain",
                        "bus",
                        "slot",
                        "function",
                        "controller",
                        "target",
                        "unit",
                        "port",
                        "text",
                    ];
                    _serde::Deserializer::deserialize_struct(
                        __deserializer,
                        "Address",
                        FIELDS,
                        __Visitor {
                            marker: _serde::export::PhantomData::<Address>,
                            lifetime: _serde::export::PhantomData,
                        },
                    )
                }
            }
        };
        #[xml(tag = "disk")]
        pub struct Disk {
            #[xml(attr = "type")]
            pub r#type: Option<String>,
            #[xml(attr = "device")]
            pub device: Option<String>,
            #[xml(child = "driver")]
            pub driver: Option<driver>,
            #[xml(child = "source")]
            pub source: Option<Source>,
            #[xml(child = "target")]
            pub target: Option<Target>,
            #[xml(child = "address")]
            pub address: Option<Address>,
        }
        impl strong_xml::XmlWrite for Disk {
            fn to_writer<W: std::io::Write>(
                &self,
                mut writer: &mut strong_xml::XmlWriter<W>,
            ) -> strong_xml::XmlResult<()> {
                let Disk {
                    r#type: __self_type,
                    device: __self_device,
                    driver: __self_driver,
                    source: __self_source,
                    target: __self_target,
                    address: __self_address,
                } = self;
                writer.write_element_start("disk")?;
                if let Some(__value) = __self_type {
                    writer.write_attribute("type", &{
                        let res = ::alloc::fmt::format(::core::fmt::Arguments::new_v1(
                            &[""],
                            &match (&__value,) {
                                (arg0,) => [::core::fmt::ArgumentV1::new(
                                    arg0,
                                    ::core::fmt::Display::fmt,
                                )],
                            },
                        ));
                        res
                    })?;
                }
                if let Some(__value) = __self_device {
                    writer.write_attribute("device", &{
                        let res = ::alloc::fmt::format(::core::fmt::Arguments::new_v1(
                            &[""],
                            &match (&__value,) {
                                (arg0,) => [::core::fmt::ArgumentV1::new(
                                    arg0,
                                    ::core::fmt::Display::fmt,
                                )],
                            },
                        ));
                        res
                    })?;
                }
                if true
                    && __self_driver.is_none()
                    && __self_source.is_none()
                    && __self_target.is_none()
                    && __self_address.is_none()
                {
                    writer.write_element_end_empty()?;
                } else {
                    writer.write_element_end_open()?;
                    if let Some(ref ele) = __self_driver {
                        ele.to_writer(&mut writer)?;
                    }
                    if let Some(ref ele) = __self_source {
                        ele.to_writer(&mut writer)?;
                    }
                    if let Some(ref ele) = __self_target {
                        ele.to_writer(&mut writer)?;
                    }
                    if let Some(ref ele) = __self_address {
                        ele.to_writer(&mut writer)?;
                    }
                    writer.write_element_end_close("disk")?;
                }
                Ok(())
            }
        }
        impl<'__input> strong_xml::XmlRead<'__input> for Disk {
            fn from_reader(
                mut reader: &mut strong_xml::XmlReader<'__input>,
            ) -> strong_xml::XmlResult<Self> {
                use strong_xml::xmlparser::{ElementEnd, Token, Tokenizer};
                use strong_xml::XmlError;
                let mut __self_type = None;
                let mut __self_device = None;
                let mut __self_driver = None;
                let mut __self_source = None;
                let mut __self_target = None;
                let mut __self_address = None;
                reader.read_till_element_start("disk")?;
                while let Some((__key, __value)) = reader.find_attribute()? {
                    match __key {
                        "type" => {
                            __self_type = Some(
                                <String as std::str::FromStr>::from_str(&__value)
                                    .map_err(|e| XmlError::FromStr(e.into()))?,
                            );
                        }
                        "device" => {
                            __self_device = Some(
                                <String as std::str::FromStr>::from_str(&__value)
                                    .map_err(|e| XmlError::FromStr(e.into()))?,
                            );
                        }
                        key => {}
                    }
                }
                if let Token::ElementEnd {
                    end: ElementEnd::Empty,
                    ..
                } = reader.next().unwrap()?
                {
                    let __res = Disk {
                        r#type: __self_type,
                        device: __self_device,
                        driver: __self_driver,
                        source: __self_source,
                        target: __self_target,
                        address: __self_address,
                    };
                    return Ok(__res);
                }
                while let Some(__tag) = reader.find_element_start(Some("disk"))? {
                    match __tag {
                        "driver" => {
                            __self_driver =
                                Some(<driver as strong_xml::XmlRead>::from_reader(reader)?);
                        }
                        "source" => {
                            __self_source =
                                Some(<Source as strong_xml::XmlRead>::from_reader(reader)?);
                        }
                        "target" => {
                            __self_target =
                                Some(<Target as strong_xml::XmlRead>::from_reader(reader)?);
                        }
                        "address" => {
                            __self_address =
                                Some(<Address as strong_xml::XmlRead>::from_reader(reader)?);
                        }
                        tag => {
                            reader.next();
                            reader.read_to_end(tag)?;
                        }
                    }
                }
                let __res = Disk {
                    r#type: __self_type,
                    device: __self_device,
                    driver: __self_driver,
                    source: __self_source,
                    target: __self_target,
                    address: __self_address,
                };
                return Ok(__res);
            }
        }
        impl ::core::marker::StructuralPartialEq for Disk {}
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::cmp::PartialEq for Disk {
            #[inline]
            fn eq(&self, other: &Disk) -> bool {
                match *other {
                    Disk {
                        r#type: ref __self_1_0,
                        device: ref __self_1_1,
                        driver: ref __self_1_2,
                        source: ref __self_1_3,
                        target: ref __self_1_4,
                        address: ref __self_1_5,
                    } => match *self {
                        Disk {
                            r#type: ref __self_0_0,
                            device: ref __self_0_1,
                            driver: ref __self_0_2,
                            source: ref __self_0_3,
                            target: ref __self_0_4,
                            address: ref __self_0_5,
                        } => {
                            (*__self_0_0) == (*__self_1_0)
                                && (*__self_0_1) == (*__self_1_1)
                                && (*__self_0_2) == (*__self_1_2)
                                && (*__self_0_3) == (*__self_1_3)
                                && (*__self_0_4) == (*__self_1_4)
                                && (*__self_0_5) == (*__self_1_5)
                        }
                    },
                }
            }
            #[inline]
            fn ne(&self, other: &Disk) -> bool {
                match *other {
                    Disk {
                        r#type: ref __self_1_0,
                        device: ref __self_1_1,
                        driver: ref __self_1_2,
                        source: ref __self_1_3,
                        target: ref __self_1_4,
                        address: ref __self_1_5,
                    } => match *self {
                        Disk {
                            r#type: ref __self_0_0,
                            device: ref __self_0_1,
                            driver: ref __self_0_2,
                            source: ref __self_0_3,
                            target: ref __self_0_4,
                            address: ref __self_0_5,
                        } => {
                            (*__self_0_0) != (*__self_1_0)
                                || (*__self_0_1) != (*__self_1_1)
                                || (*__self_0_2) != (*__self_1_2)
                                || (*__self_0_3) != (*__self_1_3)
                                || (*__self_0_4) != (*__self_1_4)
                                || (*__self_0_5) != (*__self_1_5)
                        }
                    },
                }
            }
        }
        impl ::core::marker::StructuralEq for Disk {}
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::cmp::Eq for Disk {
            #[inline]
            #[doc(hidden)]
            fn assert_receiver_is_total_eq(&self) -> () {
                {
                    let _: ::core::cmp::AssertParamIsEq<Option<String>>;
                    let _: ::core::cmp::AssertParamIsEq<Option<String>>;
                    let _: ::core::cmp::AssertParamIsEq<Option<driver>>;
                    let _: ::core::cmp::AssertParamIsEq<Option<Source>>;
                    let _: ::core::cmp::AssertParamIsEq<Option<Target>>;
                    let _: ::core::cmp::AssertParamIsEq<Option<Address>>;
                }
            }
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::fmt::Debug for Disk {
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                match *self {
                    Disk {
                        r#type: ref __self_0_0,
                        device: ref __self_0_1,
                        driver: ref __self_0_2,
                        source: ref __self_0_3,
                        target: ref __self_0_4,
                        address: ref __self_0_5,
                    } => {
                        let mut debug_trait_builder = f.debug_struct("Disk");
                        let _ = debug_trait_builder.field("type", &&(*__self_0_0));
                        let _ = debug_trait_builder.field("device", &&(*__self_0_1));
                        let _ = debug_trait_builder.field("driver", &&(*__self_0_2));
                        let _ = debug_trait_builder.field("source", &&(*__self_0_3));
                        let _ = debug_trait_builder.field("target", &&(*__self_0_4));
                        let _ = debug_trait_builder.field("address", &&(*__self_0_5));
                        debug_trait_builder.finish()
                    }
                }
            }
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::clone::Clone for Disk {
            #[inline]
            fn clone(&self) -> Disk {
                match *self {
                    Disk {
                        r#type: ref __self_0_0,
                        device: ref __self_0_1,
                        driver: ref __self_0_2,
                        source: ref __self_0_3,
                        target: ref __self_0_4,
                        address: ref __self_0_5,
                    } => Disk {
                        r#type: ::core::clone::Clone::clone(&(*__self_0_0)),
                        device: ::core::clone::Clone::clone(&(*__self_0_1)),
                        driver: ::core::clone::Clone::clone(&(*__self_0_2)),
                        source: ::core::clone::Clone::clone(&(*__self_0_3)),
                        target: ::core::clone::Clone::clone(&(*__self_0_4)),
                        address: ::core::clone::Clone::clone(&(*__self_0_5)),
                    },
                }
            }
        }
        #[doc(hidden)]
        #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
        const _: () = {
            #[allow(rust_2018_idioms, clippy::useless_attribute)]
            extern crate serde as _serde;
            #[automatically_derived]
            impl _serde::Serialize for Disk {
                fn serialize<__S>(
                    &self,
                    __serializer: __S,
                ) -> _serde::export::Result<__S::Ok, __S::Error>
                where
                    __S: _serde::Serializer,
                {
                    let mut __serde_state = match _serde::Serializer::serialize_struct(
                        __serializer,
                        "Disk",
                        false as usize + 1 + 1 + 1 + 1 + 1 + 1,
                    ) {
                        _serde::export::Ok(__val) => __val,
                        _serde::export::Err(__err) => {
                            return _serde::export::Err(__err);
                        }
                    };
                    match _serde::ser::SerializeStruct::serialize_field(
                        &mut __serde_state,
                        "type",
                        &self.r#type,
                    ) {
                        _serde::export::Ok(__val) => __val,
                        _serde::export::Err(__err) => {
                            return _serde::export::Err(__err);
                        }
                    };
                    match _serde::ser::SerializeStruct::serialize_field(
                        &mut __serde_state,
                        "device",
                        &self.device,
                    ) {
                        _serde::export::Ok(__val) => __val,
                        _serde::export::Err(__err) => {
                            return _serde::export::Err(__err);
                        }
                    };
                    match _serde::ser::SerializeStruct::serialize_field(
                        &mut __serde_state,
                        "driver",
                        &self.driver,
                    ) {
                        _serde::export::Ok(__val) => __val,
                        _serde::export::Err(__err) => {
                            return _serde::export::Err(__err);
                        }
                    };
                    match _serde::ser::SerializeStruct::serialize_field(
                        &mut __serde_state,
                        "source",
                        &self.source,
                    ) {
                        _serde::export::Ok(__val) => __val,
                        _serde::export::Err(__err) => {
                            return _serde::export::Err(__err);
                        }
                    };
                    match _serde::ser::SerializeStruct::serialize_field(
                        &mut __serde_state,
                        "target",
                        &self.target,
                    ) {
                        _serde::export::Ok(__val) => __val,
                        _serde::export::Err(__err) => {
                            return _serde::export::Err(__err);
                        }
                    };
                    match _serde::ser::SerializeStruct::serialize_field(
                        &mut __serde_state,
                        "address",
                        &self.address,
                    ) {
                        _serde::export::Ok(__val) => __val,
                        _serde::export::Err(__err) => {
                            return _serde::export::Err(__err);
                        }
                    };
                    _serde::ser::SerializeStruct::end(__serde_state)
                }
            }
        };
        #[doc(hidden)]
        #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
        const _: () = {
            #[allow(rust_2018_idioms, clippy::useless_attribute)]
            extern crate serde as _serde;
            #[automatically_derived]
            impl<'de> _serde::Deserialize<'de> for Disk {
                fn deserialize<__D>(__deserializer: __D) -> _serde::export::Result<Self, __D::Error>
                where
                    __D: _serde::Deserializer<'de>,
                {
                    #[allow(non_camel_case_types)]
                    enum __Field {
                        __field0,
                        __field1,
                        __field2,
                        __field3,
                        __field4,
                        __field5,
                        __ignore,
                    }
                    struct __FieldVisitor;
                    impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                        type Value = __Field;
                        fn expecting(
                            &self,
                            __formatter: &mut _serde::export::Formatter,
                        ) -> _serde::export::fmt::Result {
                            _serde::export::Formatter::write_str(__formatter, "field identifier")
                        }
                        fn visit_u64<__E>(
                            self,
                            __value: u64,
                        ) -> _serde::export::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                0u64 => _serde::export::Ok(__Field::__field0),
                                1u64 => _serde::export::Ok(__Field::__field1),
                                2u64 => _serde::export::Ok(__Field::__field2),
                                3u64 => _serde::export::Ok(__Field::__field3),
                                4u64 => _serde::export::Ok(__Field::__field4),
                                5u64 => _serde::export::Ok(__Field::__field5),
                                _ => _serde::export::Err(_serde::de::Error::invalid_value(
                                    _serde::de::Unexpected::Unsigned(__value),
                                    &"field index 0 <= i < 6",
                                )),
                            }
                        }
                        fn visit_str<__E>(
                            self,
                            __value: &str,
                        ) -> _serde::export::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                "type" => _serde::export::Ok(__Field::__field0),
                                "device" => _serde::export::Ok(__Field::__field1),
                                "driver" => _serde::export::Ok(__Field::__field2),
                                "source" => _serde::export::Ok(__Field::__field3),
                                "target" => _serde::export::Ok(__Field::__field4),
                                "address" => _serde::export::Ok(__Field::__field5),
                                _ => _serde::export::Ok(__Field::__ignore),
                            }
                        }
                        fn visit_bytes<__E>(
                            self,
                            __value: &[u8],
                        ) -> _serde::export::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                b"type" => _serde::export::Ok(__Field::__field0),
                                b"device" => _serde::export::Ok(__Field::__field1),
                                b"driver" => _serde::export::Ok(__Field::__field2),
                                b"source" => _serde::export::Ok(__Field::__field3),
                                b"target" => _serde::export::Ok(__Field::__field4),
                                b"address" => _serde::export::Ok(__Field::__field5),
                                _ => _serde::export::Ok(__Field::__ignore),
                            }
                        }
                    }
                    impl<'de> _serde::Deserialize<'de> for __Field {
                        #[inline]
                        fn deserialize<__D>(
                            __deserializer: __D,
                        ) -> _serde::export::Result<Self, __D::Error>
                        where
                            __D: _serde::Deserializer<'de>,
                        {
                            _serde::Deserializer::deserialize_identifier(
                                __deserializer,
                                __FieldVisitor,
                            )
                        }
                    }
                    struct __Visitor<'de> {
                        marker: _serde::export::PhantomData<Disk>,
                        lifetime: _serde::export::PhantomData<&'de ()>,
                    }
                    impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                        type Value = Disk;
                        fn expecting(
                            &self,
                            __formatter: &mut _serde::export::Formatter,
                        ) -> _serde::export::fmt::Result {
                            _serde::export::Formatter::write_str(__formatter, "struct Disk")
                        }
                        #[inline]
                        fn visit_seq<__A>(
                            self,
                            mut __seq: __A,
                        ) -> _serde::export::Result<Self::Value, __A::Error>
                        where
                            __A: _serde::de::SeqAccess<'de>,
                        {
                            let __field0 = match match _serde::de::SeqAccess::next_element::<
                                Option<String>,
                            >(&mut __seq)
                            {
                                _serde::export::Ok(__val) => __val,
                                _serde::export::Err(__err) => {
                                    return _serde::export::Err(__err);
                                }
                            } {
                                _serde::export::Some(__value) => __value,
                                _serde::export::None => {
                                    return _serde::export::Err(_serde::de::Error::invalid_length(
                                        0usize,
                                        &"struct Disk with 6 elements",
                                    ));
                                }
                            };
                            let __field1 = match match _serde::de::SeqAccess::next_element::<
                                Option<String>,
                            >(&mut __seq)
                            {
                                _serde::export::Ok(__val) => __val,
                                _serde::export::Err(__err) => {
                                    return _serde::export::Err(__err);
                                }
                            } {
                                _serde::export::Some(__value) => __value,
                                _serde::export::None => {
                                    return _serde::export::Err(_serde::de::Error::invalid_length(
                                        1usize,
                                        &"struct Disk with 6 elements",
                                    ));
                                }
                            };
                            let __field2 = match match _serde::de::SeqAccess::next_element::<
                                Option<driver>,
                            >(&mut __seq)
                            {
                                _serde::export::Ok(__val) => __val,
                                _serde::export::Err(__err) => {
                                    return _serde::export::Err(__err);
                                }
                            } {
                                _serde::export::Some(__value) => __value,
                                _serde::export::None => {
                                    return _serde::export::Err(_serde::de::Error::invalid_length(
                                        2usize,
                                        &"struct Disk with 6 elements",
                                    ));
                                }
                            };
                            let __field3 = match match _serde::de::SeqAccess::next_element::<
                                Option<Source>,
                            >(&mut __seq)
                            {
                                _serde::export::Ok(__val) => __val,
                                _serde::export::Err(__err) => {
                                    return _serde::export::Err(__err);
                                }
                            } {
                                _serde::export::Some(__value) => __value,
                                _serde::export::None => {
                                    return _serde::export::Err(_serde::de::Error::invalid_length(
                                        3usize,
                                        &"struct Disk with 6 elements",
                                    ));
                                }
                            };
                            let __field4 = match match _serde::de::SeqAccess::next_element::<
                                Option<Target>,
                            >(&mut __seq)
                            {
                                _serde::export::Ok(__val) => __val,
                                _serde::export::Err(__err) => {
                                    return _serde::export::Err(__err);
                                }
                            } {
                                _serde::export::Some(__value) => __value,
                                _serde::export::None => {
                                    return _serde::export::Err(_serde::de::Error::invalid_length(
                                        4usize,
                                        &"struct Disk with 6 elements",
                                    ));
                                }
                            };
                            let __field5 = match match _serde::de::SeqAccess::next_element::<
                                Option<Address>,
                            >(&mut __seq)
                            {
                                _serde::export::Ok(__val) => __val,
                                _serde::export::Err(__err) => {
                                    return _serde::export::Err(__err);
                                }
                            } {
                                _serde::export::Some(__value) => __value,
                                _serde::export::None => {
                                    return _serde::export::Err(_serde::de::Error::invalid_length(
                                        5usize,
                                        &"struct Disk with 6 elements",
                                    ));
                                }
                            };
                            _serde::export::Ok(Disk {
                                r#type: __field0,
                                device: __field1,
                                driver: __field2,
                                source: __field3,
                                target: __field4,
                                address: __field5,
                            })
                        }
                        #[inline]
                        fn visit_map<__A>(
                            self,
                            mut __map: __A,
                        ) -> _serde::export::Result<Self::Value, __A::Error>
                        where
                            __A: _serde::de::MapAccess<'de>,
                        {
                            let mut __field0: _serde::export::Option<Option<String>> =
                                _serde::export::None;
                            let mut __field1: _serde::export::Option<Option<String>> =
                                _serde::export::None;
                            let mut __field2: _serde::export::Option<Option<driver>> =
                                _serde::export::None;
                            let mut __field3: _serde::export::Option<Option<Source>> =
                                _serde::export::None;
                            let mut __field4: _serde::export::Option<Option<Target>> =
                                _serde::export::None;
                            let mut __field5: _serde::export::Option<Option<Address>> =
                                _serde::export::None;
                            while let _serde::export::Some(__key) =
                                match _serde::de::MapAccess::next_key::<__Field>(&mut __map) {
                                    _serde::export::Ok(__val) => __val,
                                    _serde::export::Err(__err) => {
                                        return _serde::export::Err(__err);
                                    }
                                }
                            {
                                match __key {
                                    __Field::__field0 => {
                                        if _serde::export::Option::is_some(&__field0) {
                                            return _serde::export::Err(
                                                <__A::Error as _serde::de::Error>::duplicate_field(
                                                    "type",
                                                ),
                                            );
                                        }
                                        __field0 = _serde::export::Some(
                                            match _serde::de::MapAccess::next_value::<Option<String>>(
                                                &mut __map,
                                            ) {
                                                _serde::export::Ok(__val) => __val,
                                                _serde::export::Err(__err) => {
                                                    return _serde::export::Err(__err);
                                                }
                                            },
                                        );
                                    }
                                    __Field::__field1 => {
                                        if _serde::export::Option::is_some(&__field1) {
                                            return _serde::export::Err(
                                                <__A::Error as _serde::de::Error>::duplicate_field(
                                                    "device",
                                                ),
                                            );
                                        }
                                        __field1 = _serde::export::Some(
                                            match _serde::de::MapAccess::next_value::<Option<String>>(
                                                &mut __map,
                                            ) {
                                                _serde::export::Ok(__val) => __val,
                                                _serde::export::Err(__err) => {
                                                    return _serde::export::Err(__err);
                                                }
                                            },
                                        );
                                    }
                                    __Field::__field2 => {
                                        if _serde::export::Option::is_some(&__field2) {
                                            return _serde::export::Err(
                                                <__A::Error as _serde::de::Error>::duplicate_field(
                                                    "driver",
                                                ),
                                            );
                                        }
                                        __field2 = _serde::export::Some(
                                            match _serde::de::MapAccess::next_value::<Option<driver>>(
                                                &mut __map,
                                            ) {
                                                _serde::export::Ok(__val) => __val,
                                                _serde::export::Err(__err) => {
                                                    return _serde::export::Err(__err);
                                                }
                                            },
                                        );
                                    }
                                    __Field::__field3 => {
                                        if _serde::export::Option::is_some(&__field3) {
                                            return _serde::export::Err(
                                                <__A::Error as _serde::de::Error>::duplicate_field(
                                                    "source",
                                                ),
                                            );
                                        }
                                        __field3 = _serde::export::Some(
                                            match _serde::de::MapAccess::next_value::<Option<Source>>(
                                                &mut __map,
                                            ) {
                                                _serde::export::Ok(__val) => __val,
                                                _serde::export::Err(__err) => {
                                                    return _serde::export::Err(__err);
                                                }
                                            },
                                        );
                                    }
                                    __Field::__field4 => {
                                        if _serde::export::Option::is_some(&__field4) {
                                            return _serde::export::Err(
                                                <__A::Error as _serde::de::Error>::duplicate_field(
                                                    "target",
                                                ),
                                            );
                                        }
                                        __field4 = _serde::export::Some(
                                            match _serde::de::MapAccess::next_value::<Option<Target>>(
                                                &mut __map,
                                            ) {
                                                _serde::export::Ok(__val) => __val,
                                                _serde::export::Err(__err) => {
                                                    return _serde::export::Err(__err);
                                                }
                                            },
                                        );
                                    }
                                    __Field::__field5 => {
                                        if _serde::export::Option::is_some(&__field5) {
                                            return _serde::export::Err(
                                                <__A::Error as _serde::de::Error>::duplicate_field(
                                                    "address",
                                                ),
                                            );
                                        }
                                        __field5 = _serde::export::Some(
                                            match _serde::de::MapAccess::next_value::<Option<Address>>(
                                                &mut __map,
                                            ) {
                                                _serde::export::Ok(__val) => __val,
                                                _serde::export::Err(__err) => {
                                                    return _serde::export::Err(__err);
                                                }
                                            },
                                        );
                                    }
                                    _ => {
                                        let _ = match _serde::de::MapAccess::next_value::<
                                            _serde::de::IgnoredAny,
                                        >(
                                            &mut __map
                                        ) {
                                            _serde::export::Ok(__val) => __val,
                                            _serde::export::Err(__err) => {
                                                return _serde::export::Err(__err);
                                            }
                                        };
                                    }
                                }
                            }
                            let __field0 = match __field0 {
                                _serde::export::Some(__field0) => __field0,
                                _serde::export::None => {
                                    match _serde::private::de::missing_field("type") {
                                        _serde::export::Ok(__val) => __val,
                                        _serde::export::Err(__err) => {
                                            return _serde::export::Err(__err);
                                        }
                                    }
                                }
                            };
                            let __field1 = match __field1 {
                                _serde::export::Some(__field1) => __field1,
                                _serde::export::None => {
                                    match _serde::private::de::missing_field("device") {
                                        _serde::export::Ok(__val) => __val,
                                        _serde::export::Err(__err) => {
                                            return _serde::export::Err(__err);
                                        }
                                    }
                                }
                            };
                            let __field2 = match __field2 {
                                _serde::export::Some(__field2) => __field2,
                                _serde::export::None => {
                                    match _serde::private::de::missing_field("driver") {
                                        _serde::export::Ok(__val) => __val,
                                        _serde::export::Err(__err) => {
                                            return _serde::export::Err(__err);
                                        }
                                    }
                                }
                            };
                            let __field3 = match __field3 {
                                _serde::export::Some(__field3) => __field3,
                                _serde::export::None => {
                                    match _serde::private::de::missing_field("source") {
                                        _serde::export::Ok(__val) => __val,
                                        _serde::export::Err(__err) => {
                                            return _serde::export::Err(__err);
                                        }
                                    }
                                }
                            };
                            let __field4 = match __field4 {
                                _serde::export::Some(__field4) => __field4,
                                _serde::export::None => {
                                    match _serde::private::de::missing_field("target") {
                                        _serde::export::Ok(__val) => __val,
                                        _serde::export::Err(__err) => {
                                            return _serde::export::Err(__err);
                                        }
                                    }
                                }
                            };
                            let __field5 = match __field5 {
                                _serde::export::Some(__field5) => __field5,
                                _serde::export::None => {
                                    match _serde::private::de::missing_field("address") {
                                        _serde::export::Ok(__val) => __val,
                                        _serde::export::Err(__err) => {
                                            return _serde::export::Err(__err);
                                        }
                                    }
                                }
                            };
                            _serde::export::Ok(Disk {
                                r#type: __field0,
                                device: __field1,
                                driver: __field2,
                                source: __field3,
                                target: __field4,
                                address: __field5,
                            })
                        }
                    }
                    const FIELDS: &'static [&'static str] =
                        &["type", "device", "driver", "source", "target", "address"];
                    _serde::Deserializer::deserialize_struct(
                        __deserializer,
                        "Disk",
                        FIELDS,
                        __Visitor {
                            marker: _serde::export::PhantomData::<Disk>,
                            lifetime: _serde::export::PhantomData,
                        },
                    )
                }
            }
        };
        #[xml(tag = "os")]
        pub struct OpSystem {
            #[xml(attr = "firmware")]
            pub firmware: Option<String>,
            #[xml(child = "type")]
            pub r#type: r#type,
            #[xml(child = "boot")]
            pub boot: Vec<boot>,
        }
        impl strong_xml::XmlWrite for OpSystem {
            fn to_writer<W: std::io::Write>(
                &self,
                mut writer: &mut strong_xml::XmlWriter<W>,
            ) -> strong_xml::XmlResult<()> {
                let OpSystem {
                    firmware: __self_firmware,
                    r#type: __self_type,
                    boot: __self_boot,
                } = self;
                writer.write_element_start("os")?;
                if let Some(__value) = __self_firmware {
                    writer.write_attribute("firmware", &{
                        let res = ::alloc::fmt::format(::core::fmt::Arguments::new_v1(
                            &[""],
                            &match (&__value,) {
                                (arg0,) => [::core::fmt::ArgumentV1::new(
                                    arg0,
                                    ::core::fmt::Display::fmt,
                                )],
                            },
                        ));
                        res
                    })?;
                }
                if false && __self_boot.is_empty() {
                    writer.write_element_end_empty()?;
                } else {
                    writer.write_element_end_open()?;
                    &__self_type.to_writer(&mut writer)?;
                    for ele in __self_boot {
                        ele.to_writer(&mut writer)?;
                    }
                    writer.write_element_end_close("os")?;
                }
                Ok(())
            }
        }
        impl<'__input> strong_xml::XmlRead<'__input> for OpSystem {
            fn from_reader(
                mut reader: &mut strong_xml::XmlReader<'__input>,
            ) -> strong_xml::XmlResult<Self> {
                use strong_xml::xmlparser::{ElementEnd, Token, Tokenizer};
                use strong_xml::XmlError;
                let mut __self_firmware = None;
                let mut __self_type = None;
                let mut __self_boot = Vec::new();
                reader.read_till_element_start("os")?;
                while let Some((__key, __value)) = reader.find_attribute()? {
                    match __key {
                        "firmware" => {
                            __self_firmware = Some(
                                <String as std::str::FromStr>::from_str(&__value)
                                    .map_err(|e| XmlError::FromStr(e.into()))?,
                            );
                        }
                        key => {}
                    }
                }
                if let Token::ElementEnd {
                    end: ElementEnd::Empty,
                    ..
                } = reader.next().unwrap()?
                {
                    let __res = OpSystem {
                        firmware: __self_firmware,
                        r#type: __self_type.ok_or(XmlError::MissingField {
                            name: "OpSystem".to_owned(),
                            field: "r#type".to_owned(),
                        })?,
                        boot: __self_boot,
                    };
                    return Ok(__res);
                }
                while let Some(__tag) = reader.find_element_start(Some("os"))? {
                    match __tag {
                        "type" => {
                            __self_type =
                                Some(<r#type as strong_xml::XmlRead>::from_reader(reader)?);
                        }
                        "boot" => {
                            __self_boot.push(<boot as strong_xml::XmlRead>::from_reader(reader)?);
                        }
                        tag => {
                            reader.next();
                            reader.read_to_end(tag)?;
                        }
                    }
                }
                let __res = OpSystem {
                    firmware: __self_firmware,
                    r#type: __self_type.ok_or(XmlError::MissingField {
                        name: "OpSystem".to_owned(),
                        field: "r#type".to_owned(),
                    })?,
                    boot: __self_boot,
                };
                return Ok(__res);
            }
        }
        impl ::core::marker::StructuralPartialEq for OpSystem {}
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::cmp::PartialEq for OpSystem {
            #[inline]
            fn eq(&self, other: &OpSystem) -> bool {
                match *other {
                    OpSystem {
                        firmware: ref __self_1_0,
                        r#type: ref __self_1_1,
                        boot: ref __self_1_2,
                    } => match *self {
                        OpSystem {
                            firmware: ref __self_0_0,
                            r#type: ref __self_0_1,
                            boot: ref __self_0_2,
                        } => {
                            (*__self_0_0) == (*__self_1_0)
                                && (*__self_0_1) == (*__self_1_1)
                                && (*__self_0_2) == (*__self_1_2)
                        }
                    },
                }
            }
            #[inline]
            fn ne(&self, other: &OpSystem) -> bool {
                match *other {
                    OpSystem {
                        firmware: ref __self_1_0,
                        r#type: ref __self_1_1,
                        boot: ref __self_1_2,
                    } => match *self {
                        OpSystem {
                            firmware: ref __self_0_0,
                            r#type: ref __self_0_1,
                            boot: ref __self_0_2,
                        } => {
                            (*__self_0_0) != (*__self_1_0)
                                || (*__self_0_1) != (*__self_1_1)
                                || (*__self_0_2) != (*__self_1_2)
                        }
                    },
                }
            }
        }
        impl ::core::marker::StructuralEq for OpSystem {}
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::cmp::Eq for OpSystem {
            #[inline]
            #[doc(hidden)]
            fn assert_receiver_is_total_eq(&self) -> () {
                {
                    let _: ::core::cmp::AssertParamIsEq<Option<String>>;
                    let _: ::core::cmp::AssertParamIsEq<r#type>;
                    let _: ::core::cmp::AssertParamIsEq<Vec<boot>>;
                }
            }
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::fmt::Debug for OpSystem {
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                match *self {
                    OpSystem {
                        firmware: ref __self_0_0,
                        r#type: ref __self_0_1,
                        boot: ref __self_0_2,
                    } => {
                        let mut debug_trait_builder = f.debug_struct("OpSystem");
                        let _ = debug_trait_builder.field("firmware", &&(*__self_0_0));
                        let _ = debug_trait_builder.field("type", &&(*__self_0_1));
                        let _ = debug_trait_builder.field("boot", &&(*__self_0_2));
                        debug_trait_builder.finish()
                    }
                }
            }
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::clone::Clone for OpSystem {
            #[inline]
            fn clone(&self) -> OpSystem {
                match *self {
                    OpSystem {
                        firmware: ref __self_0_0,
                        r#type: ref __self_0_1,
                        boot: ref __self_0_2,
                    } => OpSystem {
                        firmware: ::core::clone::Clone::clone(&(*__self_0_0)),
                        r#type: ::core::clone::Clone::clone(&(*__self_0_1)),
                        boot: ::core::clone::Clone::clone(&(*__self_0_2)),
                    },
                }
            }
        }
        #[doc(hidden)]
        #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
        const _: () = {
            #[allow(rust_2018_idioms, clippy::useless_attribute)]
            extern crate serde as _serde;
            #[automatically_derived]
            impl _serde::Serialize for OpSystem {
                fn serialize<__S>(
                    &self,
                    __serializer: __S,
                ) -> _serde::export::Result<__S::Ok, __S::Error>
                where
                    __S: _serde::Serializer,
                {
                    let mut __serde_state = match _serde::Serializer::serialize_struct(
                        __serializer,
                        "OpSystem",
                        false as usize + 1 + 1 + 1,
                    ) {
                        _serde::export::Ok(__val) => __val,
                        _serde::export::Err(__err) => {
                            return _serde::export::Err(__err);
                        }
                    };
                    match _serde::ser::SerializeStruct::serialize_field(
                        &mut __serde_state,
                        "firmware",
                        &self.firmware,
                    ) {
                        _serde::export::Ok(__val) => __val,
                        _serde::export::Err(__err) => {
                            return _serde::export::Err(__err);
                        }
                    };
                    match _serde::ser::SerializeStruct::serialize_field(
                        &mut __serde_state,
                        "type",
                        &self.r#type,
                    ) {
                        _serde::export::Ok(__val) => __val,
                        _serde::export::Err(__err) => {
                            return _serde::export::Err(__err);
                        }
                    };
                    match _serde::ser::SerializeStruct::serialize_field(
                        &mut __serde_state,
                        "boot",
                        &self.boot,
                    ) {
                        _serde::export::Ok(__val) => __val,
                        _serde::export::Err(__err) => {
                            return _serde::export::Err(__err);
                        }
                    };
                    _serde::ser::SerializeStruct::end(__serde_state)
                }
            }
        };
        #[doc(hidden)]
        #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
        const _: () = {
            #[allow(rust_2018_idioms, clippy::useless_attribute)]
            extern crate serde as _serde;
            #[automatically_derived]
            impl<'de> _serde::Deserialize<'de> for OpSystem {
                fn deserialize<__D>(__deserializer: __D) -> _serde::export::Result<Self, __D::Error>
                where
                    __D: _serde::Deserializer<'de>,
                {
                    #[allow(non_camel_case_types)]
                    enum __Field {
                        __field0,
                        __field1,
                        __field2,
                        __ignore,
                    }
                    struct __FieldVisitor;
                    impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                        type Value = __Field;
                        fn expecting(
                            &self,
                            __formatter: &mut _serde::export::Formatter,
                        ) -> _serde::export::fmt::Result {
                            _serde::export::Formatter::write_str(__formatter, "field identifier")
                        }
                        fn visit_u64<__E>(
                            self,
                            __value: u64,
                        ) -> _serde::export::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                0u64 => _serde::export::Ok(__Field::__field0),
                                1u64 => _serde::export::Ok(__Field::__field1),
                                2u64 => _serde::export::Ok(__Field::__field2),
                                _ => _serde::export::Err(_serde::de::Error::invalid_value(
                                    _serde::de::Unexpected::Unsigned(__value),
                                    &"field index 0 <= i < 3",
                                )),
                            }
                        }
                        fn visit_str<__E>(
                            self,
                            __value: &str,
                        ) -> _serde::export::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                "firmware" => _serde::export::Ok(__Field::__field0),
                                "type" => _serde::export::Ok(__Field::__field1),
                                "boot" => _serde::export::Ok(__Field::__field2),
                                _ => _serde::export::Ok(__Field::__ignore),
                            }
                        }
                        fn visit_bytes<__E>(
                            self,
                            __value: &[u8],
                        ) -> _serde::export::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                b"firmware" => _serde::export::Ok(__Field::__field0),
                                b"type" => _serde::export::Ok(__Field::__field1),
                                b"boot" => _serde::export::Ok(__Field::__field2),
                                _ => _serde::export::Ok(__Field::__ignore),
                            }
                        }
                    }
                    impl<'de> _serde::Deserialize<'de> for __Field {
                        #[inline]
                        fn deserialize<__D>(
                            __deserializer: __D,
                        ) -> _serde::export::Result<Self, __D::Error>
                        where
                            __D: _serde::Deserializer<'de>,
                        {
                            _serde::Deserializer::deserialize_identifier(
                                __deserializer,
                                __FieldVisitor,
                            )
                        }
                    }
                    struct __Visitor<'de> {
                        marker: _serde::export::PhantomData<OpSystem>,
                        lifetime: _serde::export::PhantomData<&'de ()>,
                    }
                    impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                        type Value = OpSystem;
                        fn expecting(
                            &self,
                            __formatter: &mut _serde::export::Formatter,
                        ) -> _serde::export::fmt::Result {
                            _serde::export::Formatter::write_str(__formatter, "struct OpSystem")
                        }
                        #[inline]
                        fn visit_seq<__A>(
                            self,
                            mut __seq: __A,
                        ) -> _serde::export::Result<Self::Value, __A::Error>
                        where
                            __A: _serde::de::SeqAccess<'de>,
                        {
                            let __field0 = match match _serde::de::SeqAccess::next_element::<
                                Option<String>,
                            >(&mut __seq)
                            {
                                _serde::export::Ok(__val) => __val,
                                _serde::export::Err(__err) => {
                                    return _serde::export::Err(__err);
                                }
                            } {
                                _serde::export::Some(__value) => __value,
                                _serde::export::None => {
                                    return _serde::export::Err(_serde::de::Error::invalid_length(
                                        0usize,
                                        &"struct OpSystem with 3 elements",
                                    ));
                                }
                            };
                            let __field1 = match match _serde::de::SeqAccess::next_element::<r#type>(
                                &mut __seq,
                            ) {
                                _serde::export::Ok(__val) => __val,
                                _serde::export::Err(__err) => {
                                    return _serde::export::Err(__err);
                                }
                            } {
                                _serde::export::Some(__value) => __value,
                                _serde::export::None => {
                                    return _serde::export::Err(_serde::de::Error::invalid_length(
                                        1usize,
                                        &"struct OpSystem with 3 elements",
                                    ));
                                }
                            };
                            let __field2 = match match _serde::de::SeqAccess::next_element::<
                                Vec<boot>,
                            >(&mut __seq)
                            {
                                _serde::export::Ok(__val) => __val,
                                _serde::export::Err(__err) => {
                                    return _serde::export::Err(__err);
                                }
                            } {
                                _serde::export::Some(__value) => __value,
                                _serde::export::None => {
                                    return _serde::export::Err(_serde::de::Error::invalid_length(
                                        2usize,
                                        &"struct OpSystem with 3 elements",
                                    ));
                                }
                            };
                            _serde::export::Ok(OpSystem {
                                firmware: __field0,
                                r#type: __field1,
                                boot: __field2,
                            })
                        }
                        #[inline]
                        fn visit_map<__A>(
                            self,
                            mut __map: __A,
                        ) -> _serde::export::Result<Self::Value, __A::Error>
                        where
                            __A: _serde::de::MapAccess<'de>,
                        {
                            let mut __field0: _serde::export::Option<Option<String>> =
                                _serde::export::None;
                            let mut __field1: _serde::export::Option<r#type> = _serde::export::None;
                            let mut __field2: _serde::export::Option<Vec<boot>> =
                                _serde::export::None;
                            while let _serde::export::Some(__key) =
                                match _serde::de::MapAccess::next_key::<__Field>(&mut __map) {
                                    _serde::export::Ok(__val) => __val,
                                    _serde::export::Err(__err) => {
                                        return _serde::export::Err(__err);
                                    }
                                }
                            {
                                match __key {
                                    __Field::__field0 => {
                                        if _serde::export::Option::is_some(&__field0) {
                                            return _serde::export::Err(
                                                <__A::Error as _serde::de::Error>::duplicate_field(
                                                    "firmware",
                                                ),
                                            );
                                        }
                                        __field0 = _serde::export::Some(
                                            match _serde::de::MapAccess::next_value::<Option<String>>(
                                                &mut __map,
                                            ) {
                                                _serde::export::Ok(__val) => __val,
                                                _serde::export::Err(__err) => {
                                                    return _serde::export::Err(__err);
                                                }
                                            },
                                        );
                                    }
                                    __Field::__field1 => {
                                        if _serde::export::Option::is_some(&__field1) {
                                            return _serde::export::Err(
                                                <__A::Error as _serde::de::Error>::duplicate_field(
                                                    "type",
                                                ),
                                            );
                                        }
                                        __field1 = _serde::export::Some(
                                            match _serde::de::MapAccess::next_value::<r#type>(
                                                &mut __map,
                                            ) {
                                                _serde::export::Ok(__val) => __val,
                                                _serde::export::Err(__err) => {
                                                    return _serde::export::Err(__err);
                                                }
                                            },
                                        );
                                    }
                                    __Field::__field2 => {
                                        if _serde::export::Option::is_some(&__field2) {
                                            return _serde::export::Err(
                                                <__A::Error as _serde::de::Error>::duplicate_field(
                                                    "boot",
                                                ),
                                            );
                                        }
                                        __field2 = _serde::export::Some(
                                            match _serde::de::MapAccess::next_value::<Vec<boot>>(
                                                &mut __map,
                                            ) {
                                                _serde::export::Ok(__val) => __val,
                                                _serde::export::Err(__err) => {
                                                    return _serde::export::Err(__err);
                                                }
                                            },
                                        );
                                    }
                                    _ => {
                                        let _ = match _serde::de::MapAccess::next_value::<
                                            _serde::de::IgnoredAny,
                                        >(
                                            &mut __map
                                        ) {
                                            _serde::export::Ok(__val) => __val,
                                            _serde::export::Err(__err) => {
                                                return _serde::export::Err(__err);
                                            }
                                        };
                                    }
                                }
                            }
                            let __field0 = match __field0 {
                                _serde::export::Some(__field0) => __field0,
                                _serde::export::None => {
                                    match _serde::private::de::missing_field("firmware") {
                                        _serde::export::Ok(__val) => __val,
                                        _serde::export::Err(__err) => {
                                            return _serde::export::Err(__err);
                                        }
                                    }
                                }
                            };
                            let __field1 = match __field1 {
                                _serde::export::Some(__field1) => __field1,
                                _serde::export::None => {
                                    match _serde::private::de::missing_field("type") {
                                        _serde::export::Ok(__val) => __val,
                                        _serde::export::Err(__err) => {
                                            return _serde::export::Err(__err);
                                        }
                                    }
                                }
                            };
                            let __field2 = match __field2 {
                                _serde::export::Some(__field2) => __field2,
                                _serde::export::None => {
                                    match _serde::private::de::missing_field("boot") {
                                        _serde::export::Ok(__val) => __val,
                                        _serde::export::Err(__err) => {
                                            return _serde::export::Err(__err);
                                        }
                                    }
                                }
                            };
                            _serde::export::Ok(OpSystem {
                                firmware: __field0,
                                r#type: __field1,
                                boot: __field2,
                            })
                        }
                    }
                    const FIELDS: &'static [&'static str] = &["firmware", "type", "boot"];
                    _serde::Deserializer::deserialize_struct(
                        __deserializer,
                        "OpSystem",
                        FIELDS,
                        __Visitor {
                            marker: _serde::export::PhantomData::<OpSystem>,
                            lifetime: _serde::export::PhantomData,
                        },
                    )
                }
            }
        };
        #[xml(tag = "controller")]
        pub struct Controller {
            #[xml(attr = "type")]
            pub attrib_type: Option<String>,
            #[xml(attr = "index")]
            pub index: u32,
            #[xml(attr = "model")]
            pub model: Option<String>,
            #[xml(child = "address")]
            pub address: Address,
        }
        impl strong_xml::XmlWrite for Controller {
            fn to_writer<W: std::io::Write>(
                &self,
                mut writer: &mut strong_xml::XmlWriter<W>,
            ) -> strong_xml::XmlResult<()> {
                let Controller {
                    attrib_type: __self_attrib_type,
                    index: __self_index,
                    model: __self_model,
                    address: __self_address,
                } = self;
                writer.write_element_start("controller")?;
                if let Some(__value) = __self_attrib_type {
                    writer.write_attribute("type", &{
                        let res = ::alloc::fmt::format(::core::fmt::Arguments::new_v1(
                            &[""],
                            &match (&__value,) {
                                (arg0,) => [::core::fmt::ArgumentV1::new(
                                    arg0,
                                    ::core::fmt::Display::fmt,
                                )],
                            },
                        ));
                        res
                    })?;
                }
                let __value = __self_index;
                writer.write_attribute("index", &{
                    let res = ::alloc::fmt::format(::core::fmt::Arguments::new_v1(
                        &[""],
                        &match (&__value,) {
                            (arg0,) => [::core::fmt::ArgumentV1::new(
                                arg0,
                                ::core::fmt::Display::fmt,
                            )],
                        },
                    ));
                    res
                })?;
                if let Some(__value) = __self_model {
                    writer.write_attribute("model", &{
                        let res = ::alloc::fmt::format(::core::fmt::Arguments::new_v1(
                            &[""],
                            &match (&__value,) {
                                (arg0,) => [::core::fmt::ArgumentV1::new(
                                    arg0,
                                    ::core::fmt::Display::fmt,
                                )],
                            },
                        ));
                        res
                    })?;
                }
                if false {
                    writer.write_element_end_empty()?;
                } else {
                    writer.write_element_end_open()?;
                    &__self_address.to_writer(&mut writer)?;
                    writer.write_element_end_close("controller")?;
                }
                Ok(())
            }
        }
        impl<'__input> strong_xml::XmlRead<'__input> for Controller {
            fn from_reader(
                mut reader: &mut strong_xml::XmlReader<'__input>,
            ) -> strong_xml::XmlResult<Self> {
                use strong_xml::xmlparser::{ElementEnd, Token, Tokenizer};
                use strong_xml::XmlError;
                let mut __self_attrib_type = None;
                let mut __self_index = None;
                let mut __self_model = None;
                let mut __self_address = None;
                reader.read_till_element_start("controller")?;
                while let Some((__key, __value)) = reader.find_attribute()? {
                    match __key {
                        "type" => {
                            __self_attrib_type = Some(
                                <String as std::str::FromStr>::from_str(&__value)
                                    .map_err(|e| XmlError::FromStr(e.into()))?,
                            );
                        }
                        "index" => {
                            __self_index = Some(
                                <u32 as std::str::FromStr>::from_str(&__value)
                                    .map_err(|e| XmlError::FromStr(e.into()))?,
                            );
                        }
                        "model" => {
                            __self_model = Some(
                                <String as std::str::FromStr>::from_str(&__value)
                                    .map_err(|e| XmlError::FromStr(e.into()))?,
                            );
                        }
                        key => {}
                    }
                }
                if let Token::ElementEnd {
                    end: ElementEnd::Empty,
                    ..
                } = reader.next().unwrap()?
                {
                    let __res = Controller {
                        attrib_type: __self_attrib_type,
                        index: __self_index.ok_or(XmlError::MissingField {
                            name: "Controller".to_owned(),
                            field: "index".to_owned(),
                        })?,
                        model: __self_model,
                        address: __self_address.ok_or(XmlError::MissingField {
                            name: "Controller".to_owned(),
                            field: "address".to_owned(),
                        })?,
                    };
                    return Ok(__res);
                }
                while let Some(__tag) = reader.find_element_start(Some("controller"))? {
                    match __tag {
                        "address" => {
                            __self_address =
                                Some(<Address as strong_xml::XmlRead>::from_reader(reader)?);
                        }
                        tag => {
                            reader.next();
                            reader.read_to_end(tag)?;
                        }
                    }
                }
                let __res = Controller {
                    attrib_type: __self_attrib_type,
                    index: __self_index.ok_or(XmlError::MissingField {
                        name: "Controller".to_owned(),
                        field: "index".to_owned(),
                    })?,
                    model: __self_model,
                    address: __self_address.ok_or(XmlError::MissingField {
                        name: "Controller".to_owned(),
                        field: "address".to_owned(),
                    })?,
                };
                return Ok(__res);
            }
        }
        impl ::core::marker::StructuralPartialEq for Controller {}
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::cmp::PartialEq for Controller {
            #[inline]
            fn eq(&self, other: &Controller) -> bool {
                match *other {
                    Controller {
                        attrib_type: ref __self_1_0,
                        index: ref __self_1_1,
                        model: ref __self_1_2,
                        address: ref __self_1_3,
                    } => match *self {
                        Controller {
                            attrib_type: ref __self_0_0,
                            index: ref __self_0_1,
                            model: ref __self_0_2,
                            address: ref __self_0_3,
                        } => {
                            (*__self_0_0) == (*__self_1_0)
                                && (*__self_0_1) == (*__self_1_1)
                                && (*__self_0_2) == (*__self_1_2)
                                && (*__self_0_3) == (*__self_1_3)
                        }
                    },
                }
            }
            #[inline]
            fn ne(&self, other: &Controller) -> bool {
                match *other {
                    Controller {
                        attrib_type: ref __self_1_0,
                        index: ref __self_1_1,
                        model: ref __self_1_2,
                        address: ref __self_1_3,
                    } => match *self {
                        Controller {
                            attrib_type: ref __self_0_0,
                            index: ref __self_0_1,
                            model: ref __self_0_2,
                            address: ref __self_0_3,
                        } => {
                            (*__self_0_0) != (*__self_1_0)
                                || (*__self_0_1) != (*__self_1_1)
                                || (*__self_0_2) != (*__self_1_2)
                                || (*__self_0_3) != (*__self_1_3)
                        }
                    },
                }
            }
        }
        impl ::core::marker::StructuralEq for Controller {}
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::cmp::Eq for Controller {
            #[inline]
            #[doc(hidden)]
            fn assert_receiver_is_total_eq(&self) -> () {
                {
                    let _: ::core::cmp::AssertParamIsEq<Option<String>>;
                    let _: ::core::cmp::AssertParamIsEq<u32>;
                    let _: ::core::cmp::AssertParamIsEq<Option<String>>;
                    let _: ::core::cmp::AssertParamIsEq<Address>;
                }
            }
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::fmt::Debug for Controller {
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                match *self {
                    Controller {
                        attrib_type: ref __self_0_0,
                        index: ref __self_0_1,
                        model: ref __self_0_2,
                        address: ref __self_0_3,
                    } => {
                        let mut debug_trait_builder = f.debug_struct("Controller");
                        let _ = debug_trait_builder.field("attrib_type", &&(*__self_0_0));
                        let _ = debug_trait_builder.field("index", &&(*__self_0_1));
                        let _ = debug_trait_builder.field("model", &&(*__self_0_2));
                        let _ = debug_trait_builder.field("address", &&(*__self_0_3));
                        debug_trait_builder.finish()
                    }
                }
            }
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::clone::Clone for Controller {
            #[inline]
            fn clone(&self) -> Controller {
                match *self {
                    Controller {
                        attrib_type: ref __self_0_0,
                        index: ref __self_0_1,
                        model: ref __self_0_2,
                        address: ref __self_0_3,
                    } => Controller {
                        attrib_type: ::core::clone::Clone::clone(&(*__self_0_0)),
                        index: ::core::clone::Clone::clone(&(*__self_0_1)),
                        model: ::core::clone::Clone::clone(&(*__self_0_2)),
                        address: ::core::clone::Clone::clone(&(*__self_0_3)),
                    },
                }
            }
        }
        #[doc(hidden)]
        #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
        const _: () = {
            #[allow(rust_2018_idioms, clippy::useless_attribute)]
            extern crate serde as _serde;
            #[automatically_derived]
            impl _serde::Serialize for Controller {
                fn serialize<__S>(
                    &self,
                    __serializer: __S,
                ) -> _serde::export::Result<__S::Ok, __S::Error>
                where
                    __S: _serde::Serializer,
                {
                    let mut __serde_state = match _serde::Serializer::serialize_struct(
                        __serializer,
                        "Controller",
                        false as usize + 1 + 1 + 1 + 1,
                    ) {
                        _serde::export::Ok(__val) => __val,
                        _serde::export::Err(__err) => {
                            return _serde::export::Err(__err);
                        }
                    };
                    match _serde::ser::SerializeStruct::serialize_field(
                        &mut __serde_state,
                        "attrib_type",
                        &self.attrib_type,
                    ) {
                        _serde::export::Ok(__val) => __val,
                        _serde::export::Err(__err) => {
                            return _serde::export::Err(__err);
                        }
                    };
                    match _serde::ser::SerializeStruct::serialize_field(
                        &mut __serde_state,
                        "index",
                        &self.index,
                    ) {
                        _serde::export::Ok(__val) => __val,
                        _serde::export::Err(__err) => {
                            return _serde::export::Err(__err);
                        }
                    };
                    match _serde::ser::SerializeStruct::serialize_field(
                        &mut __serde_state,
                        "model",
                        &self.model,
                    ) {
                        _serde::export::Ok(__val) => __val,
                        _serde::export::Err(__err) => {
                            return _serde::export::Err(__err);
                        }
                    };
                    match _serde::ser::SerializeStruct::serialize_field(
                        &mut __serde_state,
                        "address",
                        &self.address,
                    ) {
                        _serde::export::Ok(__val) => __val,
                        _serde::export::Err(__err) => {
                            return _serde::export::Err(__err);
                        }
                    };
                    _serde::ser::SerializeStruct::end(__serde_state)
                }
            }
        };
        #[doc(hidden)]
        #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
        const _: () = {
            #[allow(rust_2018_idioms, clippy::useless_attribute)]
            extern crate serde as _serde;
            #[automatically_derived]
            impl<'de> _serde::Deserialize<'de> for Controller {
                fn deserialize<__D>(__deserializer: __D) -> _serde::export::Result<Self, __D::Error>
                where
                    __D: _serde::Deserializer<'de>,
                {
                    #[allow(non_camel_case_types)]
                    enum __Field {
                        __field0,
                        __field1,
                        __field2,
                        __field3,
                        __ignore,
                    }
                    struct __FieldVisitor;
                    impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                        type Value = __Field;
                        fn expecting(
                            &self,
                            __formatter: &mut _serde::export::Formatter,
                        ) -> _serde::export::fmt::Result {
                            _serde::export::Formatter::write_str(__formatter, "field identifier")
                        }
                        fn visit_u64<__E>(
                            self,
                            __value: u64,
                        ) -> _serde::export::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                0u64 => _serde::export::Ok(__Field::__field0),
                                1u64 => _serde::export::Ok(__Field::__field1),
                                2u64 => _serde::export::Ok(__Field::__field2),
                                3u64 => _serde::export::Ok(__Field::__field3),
                                _ => _serde::export::Err(_serde::de::Error::invalid_value(
                                    _serde::de::Unexpected::Unsigned(__value),
                                    &"field index 0 <= i < 4",
                                )),
                            }
                        }
                        fn visit_str<__E>(
                            self,
                            __value: &str,
                        ) -> _serde::export::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                "attrib_type" => _serde::export::Ok(__Field::__field0),
                                "index" => _serde::export::Ok(__Field::__field1),
                                "model" => _serde::export::Ok(__Field::__field2),
                                "address" => _serde::export::Ok(__Field::__field3),
                                _ => _serde::export::Ok(__Field::__ignore),
                            }
                        }
                        fn visit_bytes<__E>(
                            self,
                            __value: &[u8],
                        ) -> _serde::export::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                b"attrib_type" => _serde::export::Ok(__Field::__field0),
                                b"index" => _serde::export::Ok(__Field::__field1),
                                b"model" => _serde::export::Ok(__Field::__field2),
                                b"address" => _serde::export::Ok(__Field::__field3),
                                _ => _serde::export::Ok(__Field::__ignore),
                            }
                        }
                    }
                    impl<'de> _serde::Deserialize<'de> for __Field {
                        #[inline]
                        fn deserialize<__D>(
                            __deserializer: __D,
                        ) -> _serde::export::Result<Self, __D::Error>
                        where
                            __D: _serde::Deserializer<'de>,
                        {
                            _serde::Deserializer::deserialize_identifier(
                                __deserializer,
                                __FieldVisitor,
                            )
                        }
                    }
                    struct __Visitor<'de> {
                        marker: _serde::export::PhantomData<Controller>,
                        lifetime: _serde::export::PhantomData<&'de ()>,
                    }
                    impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                        type Value = Controller;
                        fn expecting(
                            &self,
                            __formatter: &mut _serde::export::Formatter,
                        ) -> _serde::export::fmt::Result {
                            _serde::export::Formatter::write_str(__formatter, "struct Controller")
                        }
                        #[inline]
                        fn visit_seq<__A>(
                            self,
                            mut __seq: __A,
                        ) -> _serde::export::Result<Self::Value, __A::Error>
                        where
                            __A: _serde::de::SeqAccess<'de>,
                        {
                            let __field0 = match match _serde::de::SeqAccess::next_element::<
                                Option<String>,
                            >(&mut __seq)
                            {
                                _serde::export::Ok(__val) => __val,
                                _serde::export::Err(__err) => {
                                    return _serde::export::Err(__err);
                                }
                            } {
                                _serde::export::Some(__value) => __value,
                                _serde::export::None => {
                                    return _serde::export::Err(_serde::de::Error::invalid_length(
                                        0usize,
                                        &"struct Controller with 4 elements",
                                    ));
                                }
                            };
                            let __field1 = match match _serde::de::SeqAccess::next_element::<u32>(
                                &mut __seq,
                            ) {
                                _serde::export::Ok(__val) => __val,
                                _serde::export::Err(__err) => {
                                    return _serde::export::Err(__err);
                                }
                            } {
                                _serde::export::Some(__value) => __value,
                                _serde::export::None => {
                                    return _serde::export::Err(_serde::de::Error::invalid_length(
                                        1usize,
                                        &"struct Controller with 4 elements",
                                    ));
                                }
                            };
                            let __field2 = match match _serde::de::SeqAccess::next_element::<
                                Option<String>,
                            >(&mut __seq)
                            {
                                _serde::export::Ok(__val) => __val,
                                _serde::export::Err(__err) => {
                                    return _serde::export::Err(__err);
                                }
                            } {
                                _serde::export::Some(__value) => __value,
                                _serde::export::None => {
                                    return _serde::export::Err(_serde::de::Error::invalid_length(
                                        2usize,
                                        &"struct Controller with 4 elements",
                                    ));
                                }
                            };
                            let __field3 = match match _serde::de::SeqAccess::next_element::<Address>(
                                &mut __seq,
                            ) {
                                _serde::export::Ok(__val) => __val,
                                _serde::export::Err(__err) => {
                                    return _serde::export::Err(__err);
                                }
                            } {
                                _serde::export::Some(__value) => __value,
                                _serde::export::None => {
                                    return _serde::export::Err(_serde::de::Error::invalid_length(
                                        3usize,
                                        &"struct Controller with 4 elements",
                                    ));
                                }
                            };
                            _serde::export::Ok(Controller {
                                attrib_type: __field0,
                                index: __field1,
                                model: __field2,
                                address: __field3,
                            })
                        }
                        #[inline]
                        fn visit_map<__A>(
                            self,
                            mut __map: __A,
                        ) -> _serde::export::Result<Self::Value, __A::Error>
                        where
                            __A: _serde::de::MapAccess<'de>,
                        {
                            let mut __field0: _serde::export::Option<Option<String>> =
                                _serde::export::None;
                            let mut __field1: _serde::export::Option<u32> = _serde::export::None;
                            let mut __field2: _serde::export::Option<Option<String>> =
                                _serde::export::None;
                            let mut __field3: _serde::export::Option<Address> =
                                _serde::export::None;
                            while let _serde::export::Some(__key) =
                                match _serde::de::MapAccess::next_key::<__Field>(&mut __map) {
                                    _serde::export::Ok(__val) => __val,
                                    _serde::export::Err(__err) => {
                                        return _serde::export::Err(__err);
                                    }
                                }
                            {
                                match __key {
                                    __Field::__field0 => {
                                        if _serde::export::Option::is_some(&__field0) {
                                            return _serde::export::Err(
                                                <__A::Error as _serde::de::Error>::duplicate_field(
                                                    "attrib_type",
                                                ),
                                            );
                                        }
                                        __field0 = _serde::export::Some(
                                            match _serde::de::MapAccess::next_value::<Option<String>>(
                                                &mut __map,
                                            ) {
                                                _serde::export::Ok(__val) => __val,
                                                _serde::export::Err(__err) => {
                                                    return _serde::export::Err(__err);
                                                }
                                            },
                                        );
                                    }
                                    __Field::__field1 => {
                                        if _serde::export::Option::is_some(&__field1) {
                                            return _serde::export::Err(
                                                <__A::Error as _serde::de::Error>::duplicate_field(
                                                    "index",
                                                ),
                                            );
                                        }
                                        __field1 = _serde::export::Some(
                                            match _serde::de::MapAccess::next_value::<u32>(
                                                &mut __map,
                                            ) {
                                                _serde::export::Ok(__val) => __val,
                                                _serde::export::Err(__err) => {
                                                    return _serde::export::Err(__err);
                                                }
                                            },
                                        );
                                    }
                                    __Field::__field2 => {
                                        if _serde::export::Option::is_some(&__field2) {
                                            return _serde::export::Err(
                                                <__A::Error as _serde::de::Error>::duplicate_field(
                                                    "model",
                                                ),
                                            );
                                        }
                                        __field2 = _serde::export::Some(
                                            match _serde::de::MapAccess::next_value::<Option<String>>(
                                                &mut __map,
                                            ) {
                                                _serde::export::Ok(__val) => __val,
                                                _serde::export::Err(__err) => {
                                                    return _serde::export::Err(__err);
                                                }
                                            },
                                        );
                                    }
                                    __Field::__field3 => {
                                        if _serde::export::Option::is_some(&__field3) {
                                            return _serde::export::Err(
                                                <__A::Error as _serde::de::Error>::duplicate_field(
                                                    "address",
                                                ),
                                            );
                                        }
                                        __field3 = _serde::export::Some(
                                            match _serde::de::MapAccess::next_value::<Address>(
                                                &mut __map,
                                            ) {
                                                _serde::export::Ok(__val) => __val,
                                                _serde::export::Err(__err) => {
                                                    return _serde::export::Err(__err);
                                                }
                                            },
                                        );
                                    }
                                    _ => {
                                        let _ = match _serde::de::MapAccess::next_value::<
                                            _serde::de::IgnoredAny,
                                        >(
                                            &mut __map
                                        ) {
                                            _serde::export::Ok(__val) => __val,
                                            _serde::export::Err(__err) => {
                                                return _serde::export::Err(__err);
                                            }
                                        };
                                    }
                                }
                            }
                            let __field0 = match __field0 {
                                _serde::export::Some(__field0) => __field0,
                                _serde::export::None => {
                                    match _serde::private::de::missing_field("attrib_type") {
                                        _serde::export::Ok(__val) => __val,
                                        _serde::export::Err(__err) => {
                                            return _serde::export::Err(__err);
                                        }
                                    }
                                }
                            };
                            let __field1 = match __field1 {
                                _serde::export::Some(__field1) => __field1,
                                _serde::export::None => {
                                    match _serde::private::de::missing_field("index") {
                                        _serde::export::Ok(__val) => __val,
                                        _serde::export::Err(__err) => {
                                            return _serde::export::Err(__err);
                                        }
                                    }
                                }
                            };
                            let __field2 = match __field2 {
                                _serde::export::Some(__field2) => __field2,
                                _serde::export::None => {
                                    match _serde::private::de::missing_field("model") {
                                        _serde::export::Ok(__val) => __val,
                                        _serde::export::Err(__err) => {
                                            return _serde::export::Err(__err);
                                        }
                                    }
                                }
                            };
                            let __field3 = match __field3 {
                                _serde::export::Some(__field3) => __field3,
                                _serde::export::None => {
                                    match _serde::private::de::missing_field("address") {
                                        _serde::export::Ok(__val) => __val,
                                        _serde::export::Err(__err) => {
                                            return _serde::export::Err(__err);
                                        }
                                    }
                                }
                            };
                            _serde::export::Ok(Controller {
                                attrib_type: __field0,
                                index: __field1,
                                model: __field2,
                                address: __field3,
                            })
                        }
                    }
                    const FIELDS: &'static [&'static str] =
                        &["attrib_type", "index", "model", "address"];
                    _serde::Deserializer::deserialize_struct(
                        __deserializer,
                        "Controller",
                        FIELDS,
                        __Visitor {
                            marker: _serde::export::PhantomData::<Controller>,
                            lifetime: _serde::export::PhantomData,
                        },
                    )
                }
            }
        };
        #[xml(tag = "devices")]
        pub struct Devices {
            #[xml(child = "disk")]
            pub disks: Vec<Disk>,
            #[xml(child = "controller")]
            pub controllers: Vec<Controller>,
            #[xml(text)]
            text: String,
        }
        impl<'__input> strong_xml::XmlRead<'__input> for Devices {
            fn from_reader(
                mut reader: &mut strong_xml::XmlReader<'__input>,
            ) -> strong_xml::XmlResult<Self> {
                use strong_xml::xmlparser::{ElementEnd, Token, Tokenizer};
                use strong_xml::XmlError;
                let mut __self_disks = Vec::new();
                let mut __self_controllers = Vec::new();
                let __self_text;
                reader.read_till_element_start("devices")?;
                while let Some((__key, __value)) = reader.find_attribute()? {
                    match __key {
                        key => {}
                    }
                }
                let __value = reader.read_text("devices")?;
                __self_text = Some(
                    <String as std::str::FromStr>::from_str(&__value)
                        .map_err(|e| XmlError::FromStr(e.into()))?,
                );
                let __res = Devices {
                    disks: __self_disks,
                    controllers: __self_controllers,
                    text: __self_text.ok_or(XmlError::MissingField {
                        name: "Devices".to_owned(),
                        field: "text".to_owned(),
                    })?,
                };
                return Ok(__res);
            }
        }
        impl strong_xml::XmlWrite for Devices {
            fn to_writer<W: std::io::Write>(
                &self,
                mut writer: &mut strong_xml::XmlWriter<W>,
            ) -> strong_xml::XmlResult<()> {
                let Devices {
                    disks: __self_disks,
                    controllers: __self_controllers,
                    text: __self_text,
                } = self;
                writer.write_element_start("devices")?;
                writer.write_element_end_open()?;
                let __value = &__self_text;
                writer.write_text(&{
                    let res = ::alloc::fmt::format(::core::fmt::Arguments::new_v1(
                        &[""],
                        &match (&__value,) {
                            (arg0,) => [::core::fmt::ArgumentV1::new(
                                arg0,
                                ::core::fmt::Display::fmt,
                            )],
                        },
                    ));
                    res
                })?;
                writer.write_element_end_close("devices")?;
                Ok(())
            }
        }
        impl ::core::marker::StructuralPartialEq for Devices {}
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::cmp::PartialEq for Devices {
            #[inline]
            fn eq(&self, other: &Devices) -> bool {
                match *other {
                    Devices {
                        disks: ref __self_1_0,
                        controllers: ref __self_1_1,
                        text: ref __self_1_2,
                    } => match *self {
                        Devices {
                            disks: ref __self_0_0,
                            controllers: ref __self_0_1,
                            text: ref __self_0_2,
                        } => {
                            (*__self_0_0) == (*__self_1_0)
                                && (*__self_0_1) == (*__self_1_1)
                                && (*__self_0_2) == (*__self_1_2)
                        }
                    },
                }
            }
            #[inline]
            fn ne(&self, other: &Devices) -> bool {
                match *other {
                    Devices {
                        disks: ref __self_1_0,
                        controllers: ref __self_1_1,
                        text: ref __self_1_2,
                    } => match *self {
                        Devices {
                            disks: ref __self_0_0,
                            controllers: ref __self_0_1,
                            text: ref __self_0_2,
                        } => {
                            (*__self_0_0) != (*__self_1_0)
                                || (*__self_0_1) != (*__self_1_1)
                                || (*__self_0_2) != (*__self_1_2)
                        }
                    },
                }
            }
        }
        impl ::core::marker::StructuralEq for Devices {}
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::cmp::Eq for Devices {
            #[inline]
            #[doc(hidden)]
            fn assert_receiver_is_total_eq(&self) -> () {
                {
                    let _: ::core::cmp::AssertParamIsEq<Vec<Disk>>;
                    let _: ::core::cmp::AssertParamIsEq<Vec<Controller>>;
                    let _: ::core::cmp::AssertParamIsEq<String>;
                }
            }
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::fmt::Debug for Devices {
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                match *self {
                    Devices {
                        disks: ref __self_0_0,
                        controllers: ref __self_0_1,
                        text: ref __self_0_2,
                    } => {
                        let mut debug_trait_builder = f.debug_struct("Devices");
                        let _ = debug_trait_builder.field("disks", &&(*__self_0_0));
                        let _ = debug_trait_builder.field("controllers", &&(*__self_0_1));
                        let _ = debug_trait_builder.field("text", &&(*__self_0_2));
                        debug_trait_builder.finish()
                    }
                }
            }
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::clone::Clone for Devices {
            #[inline]
            fn clone(&self) -> Devices {
                match *self {
                    Devices {
                        disks: ref __self_0_0,
                        controllers: ref __self_0_1,
                        text: ref __self_0_2,
                    } => Devices {
                        disks: ::core::clone::Clone::clone(&(*__self_0_0)),
                        controllers: ::core::clone::Clone::clone(&(*__self_0_1)),
                        text: ::core::clone::Clone::clone(&(*__self_0_2)),
                    },
                }
            }
        }
        #[doc(hidden)]
        #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
        const _: () = {
            #[allow(rust_2018_idioms, clippy::useless_attribute)]
            extern crate serde as _serde;
            #[automatically_derived]
            impl _serde::Serialize for Devices {
                fn serialize<__S>(
                    &self,
                    __serializer: __S,
                ) -> _serde::export::Result<__S::Ok, __S::Error>
                where
                    __S: _serde::Serializer,
                {
                    let mut __serde_state = match _serde::Serializer::serialize_struct(
                        __serializer,
                        "Devices",
                        false as usize + 1 + 1 + 1,
                    ) {
                        _serde::export::Ok(__val) => __val,
                        _serde::export::Err(__err) => {
                            return _serde::export::Err(__err);
                        }
                    };
                    match _serde::ser::SerializeStruct::serialize_field(
                        &mut __serde_state,
                        "disks",
                        &self.disks,
                    ) {
                        _serde::export::Ok(__val) => __val,
                        _serde::export::Err(__err) => {
                            return _serde::export::Err(__err);
                        }
                    };
                    match _serde::ser::SerializeStruct::serialize_field(
                        &mut __serde_state,
                        "controllers",
                        &self.controllers,
                    ) {
                        _serde::export::Ok(__val) => __val,
                        _serde::export::Err(__err) => {
                            return _serde::export::Err(__err);
                        }
                    };
                    match _serde::ser::SerializeStruct::serialize_field(
                        &mut __serde_state,
                        "text",
                        &self.text,
                    ) {
                        _serde::export::Ok(__val) => __val,
                        _serde::export::Err(__err) => {
                            return _serde::export::Err(__err);
                        }
                    };
                    _serde::ser::SerializeStruct::end(__serde_state)
                }
            }
        };
        #[doc(hidden)]
        #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
        const _: () = {
            #[allow(rust_2018_idioms, clippy::useless_attribute)]
            extern crate serde as _serde;
            #[automatically_derived]
            impl<'de> _serde::Deserialize<'de> for Devices {
                fn deserialize<__D>(__deserializer: __D) -> _serde::export::Result<Self, __D::Error>
                where
                    __D: _serde::Deserializer<'de>,
                {
                    #[allow(non_camel_case_types)]
                    enum __Field {
                        __field0,
                        __field1,
                        __field2,
                        __ignore,
                    }
                    struct __FieldVisitor;
                    impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                        type Value = __Field;
                        fn expecting(
                            &self,
                            __formatter: &mut _serde::export::Formatter,
                        ) -> _serde::export::fmt::Result {
                            _serde::export::Formatter::write_str(__formatter, "field identifier")
                        }
                        fn visit_u64<__E>(
                            self,
                            __value: u64,
                        ) -> _serde::export::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                0u64 => _serde::export::Ok(__Field::__field0),
                                1u64 => _serde::export::Ok(__Field::__field1),
                                2u64 => _serde::export::Ok(__Field::__field2),
                                _ => _serde::export::Err(_serde::de::Error::invalid_value(
                                    _serde::de::Unexpected::Unsigned(__value),
                                    &"field index 0 <= i < 3",
                                )),
                            }
                        }
                        fn visit_str<__E>(
                            self,
                            __value: &str,
                        ) -> _serde::export::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                "disks" => _serde::export::Ok(__Field::__field0),
                                "controllers" => _serde::export::Ok(__Field::__field1),
                                "text" => _serde::export::Ok(__Field::__field2),
                                _ => _serde::export::Ok(__Field::__ignore),
                            }
                        }
                        fn visit_bytes<__E>(
                            self,
                            __value: &[u8],
                        ) -> _serde::export::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                b"disks" => _serde::export::Ok(__Field::__field0),
                                b"controllers" => _serde::export::Ok(__Field::__field1),
                                b"text" => _serde::export::Ok(__Field::__field2),
                                _ => _serde::export::Ok(__Field::__ignore),
                            }
                        }
                    }
                    impl<'de> _serde::Deserialize<'de> for __Field {
                        #[inline]
                        fn deserialize<__D>(
                            __deserializer: __D,
                        ) -> _serde::export::Result<Self, __D::Error>
                        where
                            __D: _serde::Deserializer<'de>,
                        {
                            _serde::Deserializer::deserialize_identifier(
                                __deserializer,
                                __FieldVisitor,
                            )
                        }
                    }
                    struct __Visitor<'de> {
                        marker: _serde::export::PhantomData<Devices>,
                        lifetime: _serde::export::PhantomData<&'de ()>,
                    }
                    impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                        type Value = Devices;
                        fn expecting(
                            &self,
                            __formatter: &mut _serde::export::Formatter,
                        ) -> _serde::export::fmt::Result {
                            _serde::export::Formatter::write_str(__formatter, "struct Devices")
                        }
                        #[inline]
                        fn visit_seq<__A>(
                            self,
                            mut __seq: __A,
                        ) -> _serde::export::Result<Self::Value, __A::Error>
                        where
                            __A: _serde::de::SeqAccess<'de>,
                        {
                            let __field0 = match match _serde::de::SeqAccess::next_element::<
                                Vec<Disk>,
                            >(&mut __seq)
                            {
                                _serde::export::Ok(__val) => __val,
                                _serde::export::Err(__err) => {
                                    return _serde::export::Err(__err);
                                }
                            } {
                                _serde::export::Some(__value) => __value,
                                _serde::export::None => {
                                    return _serde::export::Err(_serde::de::Error::invalid_length(
                                        0usize,
                                        &"struct Devices with 3 elements",
                                    ));
                                }
                            };
                            let __field1 = match match _serde::de::SeqAccess::next_element::<
                                Vec<Controller>,
                            >(&mut __seq)
                            {
                                _serde::export::Ok(__val) => __val,
                                _serde::export::Err(__err) => {
                                    return _serde::export::Err(__err);
                                }
                            } {
                                _serde::export::Some(__value) => __value,
                                _serde::export::None => {
                                    return _serde::export::Err(_serde::de::Error::invalid_length(
                                        1usize,
                                        &"struct Devices with 3 elements",
                                    ));
                                }
                            };
                            let __field2 = match match _serde::de::SeqAccess::next_element::<String>(
                                &mut __seq,
                            ) {
                                _serde::export::Ok(__val) => __val,
                                _serde::export::Err(__err) => {
                                    return _serde::export::Err(__err);
                                }
                            } {
                                _serde::export::Some(__value) => __value,
                                _serde::export::None => {
                                    return _serde::export::Err(_serde::de::Error::invalid_length(
                                        2usize,
                                        &"struct Devices with 3 elements",
                                    ));
                                }
                            };
                            _serde::export::Ok(Devices {
                                disks: __field0,
                                controllers: __field1,
                                text: __field2,
                            })
                        }
                        #[inline]
                        fn visit_map<__A>(
                            self,
                            mut __map: __A,
                        ) -> _serde::export::Result<Self::Value, __A::Error>
                        where
                            __A: _serde::de::MapAccess<'de>,
                        {
                            let mut __field0: _serde::export::Option<Vec<Disk>> =
                                _serde::export::None;
                            let mut __field1: _serde::export::Option<Vec<Controller>> =
                                _serde::export::None;
                            let mut __field2: _serde::export::Option<String> = _serde::export::None;
                            while let _serde::export::Some(__key) =
                                match _serde::de::MapAccess::next_key::<__Field>(&mut __map) {
                                    _serde::export::Ok(__val) => __val,
                                    _serde::export::Err(__err) => {
                                        return _serde::export::Err(__err);
                                    }
                                }
                            {
                                match __key {
                                    __Field::__field0 => {
                                        if _serde::export::Option::is_some(&__field0) {
                                            return _serde::export::Err(
                                                <__A::Error as _serde::de::Error>::duplicate_field(
                                                    "disks",
                                                ),
                                            );
                                        }
                                        __field0 = _serde::export::Some(
                                            match _serde::de::MapAccess::next_value::<Vec<Disk>>(
                                                &mut __map,
                                            ) {
                                                _serde::export::Ok(__val) => __val,
                                                _serde::export::Err(__err) => {
                                                    return _serde::export::Err(__err);
                                                }
                                            },
                                        );
                                    }
                                    __Field::__field1 => {
                                        if _serde::export::Option::is_some(&__field1) {
                                            return _serde::export::Err(
                                                <__A::Error as _serde::de::Error>::duplicate_field(
                                                    "controllers",
                                                ),
                                            );
                                        }
                                        __field1 = _serde::export::Some(
                                            match _serde::de::MapAccess::next_value::<Vec<Controller>>(
                                                &mut __map,
                                            ) {
                                                _serde::export::Ok(__val) => __val,
                                                _serde::export::Err(__err) => {
                                                    return _serde::export::Err(__err);
                                                }
                                            },
                                        );
                                    }
                                    __Field::__field2 => {
                                        if _serde::export::Option::is_some(&__field2) {
                                            return _serde::export::Err(
                                                <__A::Error as _serde::de::Error>::duplicate_field(
                                                    "text",
                                                ),
                                            );
                                        }
                                        __field2 = _serde::export::Some(
                                            match _serde::de::MapAccess::next_value::<String>(
                                                &mut __map,
                                            ) {
                                                _serde::export::Ok(__val) => __val,
                                                _serde::export::Err(__err) => {
                                                    return _serde::export::Err(__err);
                                                }
                                            },
                                        );
                                    }
                                    _ => {
                                        let _ = match _serde::de::MapAccess::next_value::<
                                            _serde::de::IgnoredAny,
                                        >(
                                            &mut __map
                                        ) {
                                            _serde::export::Ok(__val) => __val,
                                            _serde::export::Err(__err) => {
                                                return _serde::export::Err(__err);
                                            }
                                        };
                                    }
                                }
                            }
                            let __field0 = match __field0 {
                                _serde::export::Some(__field0) => __field0,
                                _serde::export::None => {
                                    match _serde::private::de::missing_field("disks") {
                                        _serde::export::Ok(__val) => __val,
                                        _serde::export::Err(__err) => {
                                            return _serde::export::Err(__err);
                                        }
                                    }
                                }
                            };
                            let __field1 = match __field1 {
                                _serde::export::Some(__field1) => __field1,
                                _serde::export::None => {
                                    match _serde::private::de::missing_field("controllers") {
                                        _serde::export::Ok(__val) => __val,
                                        _serde::export::Err(__err) => {
                                            return _serde::export::Err(__err);
                                        }
                                    }
                                }
                            };
                            let __field2 = match __field2 {
                                _serde::export::Some(__field2) => __field2,
                                _serde::export::None => {
                                    match _serde::private::de::missing_field("text") {
                                        _serde::export::Ok(__val) => __val,
                                        _serde::export::Err(__err) => {
                                            return _serde::export::Err(__err);
                                        }
                                    }
                                }
                            };
                            _serde::export::Ok(Devices {
                                disks: __field0,
                                controllers: __field1,
                                text: __field2,
                            })
                        }
                    }
                    const FIELDS: &'static [&'static str] = &["disks", "controllers", "text"];
                    _serde::Deserializer::deserialize_struct(
                        __deserializer,
                        "Devices",
                        FIELDS,
                        __Visitor {
                            marker: _serde::export::PhantomData::<Devices>,
                            lifetime: _serde::export::PhantomData,
                        },
                    )
                }
            }
        };
        #[xml(tag = "domain")]
        pub struct DomainConfig {
            #[xml(attr = "type")]
            pub r#type: String,
            #[xml(attr = "id")]
            pub id: Option<u32>,
            #[xml(child = "name")]
            pub name: Option<name>,
            #[xml(child = "uuid")]
            pub uuid: uuid,
            #[xml(child = "genid")]
            pub genid: Option<genid>,
            #[xml(child = "title")]
            pub title: Option<title>,
            #[xml(child = "description")]
            pub description: Option<description>,
            #[xml(child = "memory")]
            pub memory: memory,
            #[xml(child = "vcpu")]
            pub vcpu: vcpu,
            #[xml(child = "os")]
            pub os: OpSystem,
            #[xml(child = "features")]
            pub features: Option<Features>,
            #[xml(child = "cpu")]
            pub cpu: Option<CPU>,
            #[xml(child = "clock")]
            pub clock: Option<Clock>,
            #[xml(child = "on_poweroff")]
            pub on_poweroff: Option<on_poweroff>,
            #[xml(child = "on_reboot")]
            pub on_reboot: Option<on_reboot>,
            #[xml(child = "on_crash")]
            pub on_crash: Option<on_crash>,
            #[xml(child = "pm")]
            pub pm: Option<PM>,
        }
        impl strong_xml::XmlWrite for DomainConfig {
            fn to_writer<W: std::io::Write>(
                &self,
                mut writer: &mut strong_xml::XmlWriter<W>,
            ) -> strong_xml::XmlResult<()> {
                let DomainConfig {
                    r#type: __self_type,
                    id: __self_id,
                    name: __self_name,
                    uuid: __self_uuid,
                    genid: __self_genid,
                    title: __self_title,
                    description: __self_description,
                    memory: __self_memory,
                    vcpu: __self_vcpu,
                    os: __self_os,
                    features: __self_features,
                    cpu: __self_cpu,
                    clock: __self_clock,
                    on_poweroff: __self_on_poweroff,
                    on_reboot: __self_on_reboot,
                    on_crash: __self_on_crash,
                    pm: __self_pm,
                } = self;
                writer.write_element_start("domain")?;
                let __value = __self_type;
                writer.write_attribute("type", &{
                    let res = ::alloc::fmt::format(::core::fmt::Arguments::new_v1(
                        &[""],
                        &match (&__value,) {
                            (arg0,) => [::core::fmt::ArgumentV1::new(
                                arg0,
                                ::core::fmt::Display::fmt,
                            )],
                        },
                    ));
                    res
                })?;
                if let Some(__value) = __self_id {
                    writer.write_attribute("id", &{
                        let res = ::alloc::fmt::format(::core::fmt::Arguments::new_v1(
                            &[""],
                            &match (&__value,) {
                                (arg0,) => [::core::fmt::ArgumentV1::new(
                                    arg0,
                                    ::core::fmt::Display::fmt,
                                )],
                            },
                        ));
                        res
                    })?;
                }
                if false
                    && __self_name.is_none()
                    && __self_genid.is_none()
                    && __self_title.is_none()
                    && __self_description.is_none()
                    && __self_features.is_none()
                    && __self_cpu.is_none()
                    && __self_clock.is_none()
                    && __self_on_poweroff.is_none()
                    && __self_on_reboot.is_none()
                    && __self_on_crash.is_none()
                    && __self_pm.is_none()
                {
                    writer.write_element_end_empty()?;
                } else {
                    writer.write_element_end_open()?;
                    if let Some(ref ele) = __self_name {
                        ele.to_writer(&mut writer)?;
                    }
                    &__self_uuid.to_writer(&mut writer)?;
                    if let Some(ref ele) = __self_genid {
                        ele.to_writer(&mut writer)?;
                    }
                    if let Some(ref ele) = __self_title {
                        ele.to_writer(&mut writer)?;
                    }
                    if let Some(ref ele) = __self_description {
                        ele.to_writer(&mut writer)?;
                    }
                    &__self_memory.to_writer(&mut writer)?;
                    &__self_vcpu.to_writer(&mut writer)?;
                    &__self_os.to_writer(&mut writer)?;
                    if let Some(ref ele) = __self_features {
                        ele.to_writer(&mut writer)?;
                    }
                    if let Some(ref ele) = __self_cpu {
                        ele.to_writer(&mut writer)?;
                    }
                    if let Some(ref ele) = __self_clock {
                        ele.to_writer(&mut writer)?;
                    }
                    if let Some(ref ele) = __self_on_poweroff {
                        ele.to_writer(&mut writer)?;
                    }
                    if let Some(ref ele) = __self_on_reboot {
                        ele.to_writer(&mut writer)?;
                    }
                    if let Some(ref ele) = __self_on_crash {
                        ele.to_writer(&mut writer)?;
                    }
                    if let Some(ref ele) = __self_pm {
                        ele.to_writer(&mut writer)?;
                    }
                    writer.write_element_end_close("domain")?;
                }
                Ok(())
            }
        }
        impl<'__input> strong_xml::XmlRead<'__input> for DomainConfig {
            fn from_reader(
                mut reader: &mut strong_xml::XmlReader<'__input>,
            ) -> strong_xml::XmlResult<Self> {
                use strong_xml::xmlparser::{ElementEnd, Token, Tokenizer};
                use strong_xml::XmlError;
                let mut __self_type = None;
                let mut __self_id = None;
                let mut __self_name = None;
                let mut __self_uuid = None;
                let mut __self_genid = None;
                let mut __self_title = None;
                let mut __self_description = None;
                let mut __self_memory = None;
                let mut __self_vcpu = None;
                let mut __self_os = None;
                let mut __self_features = None;
                let mut __self_cpu = None;
                let mut __self_clock = None;
                let mut __self_on_poweroff = None;
                let mut __self_on_reboot = None;
                let mut __self_on_crash = None;
                let mut __self_pm = None;
                reader.read_till_element_start("domain")?;
                while let Some((__key, __value)) = reader.find_attribute()? {
                    match __key {
                        "type" => {
                            __self_type = Some(
                                <String as std::str::FromStr>::from_str(&__value)
                                    .map_err(|e| XmlError::FromStr(e.into()))?,
                            );
                        }
                        "id" => {
                            __self_id = Some(
                                <u32 as std::str::FromStr>::from_str(&__value)
                                    .map_err(|e| XmlError::FromStr(e.into()))?,
                            );
                        }
                        key => {}
                    }
                }
                if let Token::ElementEnd {
                    end: ElementEnd::Empty,
                    ..
                } = reader.next().unwrap()?
                {
                    let __res = DomainConfig {
                        r#type: __self_type.ok_or(XmlError::MissingField {
                            name: "DomainConfig".to_owned(),
                            field: "r#type".to_owned(),
                        })?,
                        id: __self_id,
                        name: __self_name,
                        uuid: __self_uuid.ok_or(XmlError::MissingField {
                            name: "DomainConfig".to_owned(),
                            field: "uuid".to_owned(),
                        })?,
                        genid: __self_genid,
                        title: __self_title,
                        description: __self_description,
                        memory: __self_memory.ok_or(XmlError::MissingField {
                            name: "DomainConfig".to_owned(),
                            field: "memory".to_owned(),
                        })?,
                        vcpu: __self_vcpu.ok_or(XmlError::MissingField {
                            name: "DomainConfig".to_owned(),
                            field: "vcpu".to_owned(),
                        })?,
                        os: __self_os.ok_or(XmlError::MissingField {
                            name: "DomainConfig".to_owned(),
                            field: "os".to_owned(),
                        })?,
                        features: __self_features,
                        cpu: __self_cpu,
                        clock: __self_clock,
                        on_poweroff: __self_on_poweroff,
                        on_reboot: __self_on_reboot,
                        on_crash: __self_on_crash,
                        pm: __self_pm,
                    };
                    return Ok(__res);
                }
                while let Some(__tag) = reader.find_element_start(Some("domain"))? {
                    match __tag {
                        "name" => {
                            __self_name = Some(<name as strong_xml::XmlRead>::from_reader(reader)?);
                        }
                        "uuid" => {
                            __self_uuid = Some(<uuid as strong_xml::XmlRead>::from_reader(reader)?);
                        }
                        "genid" => {
                            __self_genid =
                                Some(<genid as strong_xml::XmlRead>::from_reader(reader)?);
                        }
                        "title" => {
                            __self_title =
                                Some(<title as strong_xml::XmlRead>::from_reader(reader)?);
                        }
                        "description" => {
                            __self_description =
                                Some(<description as strong_xml::XmlRead>::from_reader(reader)?);
                        }
                        "memory" => {
                            __self_memory =
                                Some(<memory as strong_xml::XmlRead>::from_reader(reader)?);
                        }
                        "vcpu" => {
                            __self_vcpu = Some(<vcpu as strong_xml::XmlRead>::from_reader(reader)?);
                        }
                        "os" => {
                            __self_os =
                                Some(<OpSystem as strong_xml::XmlRead>::from_reader(reader)?);
                        }
                        "features" => {
                            __self_features =
                                Some(<Features as strong_xml::XmlRead>::from_reader(reader)?);
                        }
                        "cpu" => {
                            __self_cpu = Some(<CPU as strong_xml::XmlRead>::from_reader(reader)?);
                        }
                        "clock" => {
                            __self_clock =
                                Some(<Clock as strong_xml::XmlRead>::from_reader(reader)?);
                        }
                        "on_poweroff" => {
                            __self_on_poweroff =
                                Some(<on_poweroff as strong_xml::XmlRead>::from_reader(reader)?);
                        }
                        "on_reboot" => {
                            __self_on_reboot =
                                Some(<on_reboot as strong_xml::XmlRead>::from_reader(reader)?);
                        }
                        "on_crash" => {
                            __self_on_crash =
                                Some(<on_crash as strong_xml::XmlRead>::from_reader(reader)?);
                        }
                        "pm" => {
                            __self_pm = Some(<PM as strong_xml::XmlRead>::from_reader(reader)?);
                        }
                        tag => {
                            reader.next();
                            reader.read_to_end(tag)?;
                        }
                    }
                }
                let __res = DomainConfig {
                    r#type: __self_type.ok_or(XmlError::MissingField {
                        name: "DomainConfig".to_owned(),
                        field: "r#type".to_owned(),
                    })?,
                    id: __self_id,
                    name: __self_name,
                    uuid: __self_uuid.ok_or(XmlError::MissingField {
                        name: "DomainConfig".to_owned(),
                        field: "uuid".to_owned(),
                    })?,
                    genid: __self_genid,
                    title: __self_title,
                    description: __self_description,
                    memory: __self_memory.ok_or(XmlError::MissingField {
                        name: "DomainConfig".to_owned(),
                        field: "memory".to_owned(),
                    })?,
                    vcpu: __self_vcpu.ok_or(XmlError::MissingField {
                        name: "DomainConfig".to_owned(),
                        field: "vcpu".to_owned(),
                    })?,
                    os: __self_os.ok_or(XmlError::MissingField {
                        name: "DomainConfig".to_owned(),
                        field: "os".to_owned(),
                    })?,
                    features: __self_features,
                    cpu: __self_cpu,
                    clock: __self_clock,
                    on_poweroff: __self_on_poweroff,
                    on_reboot: __self_on_reboot,
                    on_crash: __self_on_crash,
                    pm: __self_pm,
                };
                return Ok(__res);
            }
        }
        impl ::core::marker::StructuralPartialEq for DomainConfig {}
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::cmp::PartialEq for DomainConfig {
            #[inline]
            fn eq(&self, other: &DomainConfig) -> bool {
                match *other {
                    DomainConfig {
                        r#type: ref __self_1_0,
                        id: ref __self_1_1,
                        name: ref __self_1_2,
                        uuid: ref __self_1_3,
                        genid: ref __self_1_4,
                        title: ref __self_1_5,
                        description: ref __self_1_6,
                        memory: ref __self_1_7,
                        vcpu: ref __self_1_8,
                        os: ref __self_1_9,
                        features: ref __self_1_10,
                        cpu: ref __self_1_11,
                        clock: ref __self_1_12,
                        on_poweroff: ref __self_1_13,
                        on_reboot: ref __self_1_14,
                        on_crash: ref __self_1_15,
                        pm: ref __self_1_16,
                    } => match *self {
                        DomainConfig {
                            r#type: ref __self_0_0,
                            id: ref __self_0_1,
                            name: ref __self_0_2,
                            uuid: ref __self_0_3,
                            genid: ref __self_0_4,
                            title: ref __self_0_5,
                            description: ref __self_0_6,
                            memory: ref __self_0_7,
                            vcpu: ref __self_0_8,
                            os: ref __self_0_9,
                            features: ref __self_0_10,
                            cpu: ref __self_0_11,
                            clock: ref __self_0_12,
                            on_poweroff: ref __self_0_13,
                            on_reboot: ref __self_0_14,
                            on_crash: ref __self_0_15,
                            pm: ref __self_0_16,
                        } => {
                            (*__self_0_0) == (*__self_1_0)
                                && (*__self_0_1) == (*__self_1_1)
                                && (*__self_0_2) == (*__self_1_2)
                                && (*__self_0_3) == (*__self_1_3)
                                && (*__self_0_4) == (*__self_1_4)
                                && (*__self_0_5) == (*__self_1_5)
                                && (*__self_0_6) == (*__self_1_6)
                                && (*__self_0_7) == (*__self_1_7)
                                && (*__self_0_8) == (*__self_1_8)
                                && (*__self_0_9) == (*__self_1_9)
                                && (*__self_0_10) == (*__self_1_10)
                                && (*__self_0_11) == (*__self_1_11)
                                && (*__self_0_12) == (*__self_1_12)
                                && (*__self_0_13) == (*__self_1_13)
                                && (*__self_0_14) == (*__self_1_14)
                                && (*__self_0_15) == (*__self_1_15)
                                && (*__self_0_16) == (*__self_1_16)
                        }
                    },
                }
            }
            #[inline]
            fn ne(&self, other: &DomainConfig) -> bool {
                match *other {
                    DomainConfig {
                        r#type: ref __self_1_0,
                        id: ref __self_1_1,
                        name: ref __self_1_2,
                        uuid: ref __self_1_3,
                        genid: ref __self_1_4,
                        title: ref __self_1_5,
                        description: ref __self_1_6,
                        memory: ref __self_1_7,
                        vcpu: ref __self_1_8,
                        os: ref __self_1_9,
                        features: ref __self_1_10,
                        cpu: ref __self_1_11,
                        clock: ref __self_1_12,
                        on_poweroff: ref __self_1_13,
                        on_reboot: ref __self_1_14,
                        on_crash: ref __self_1_15,
                        pm: ref __self_1_16,
                    } => match *self {
                        DomainConfig {
                            r#type: ref __self_0_0,
                            id: ref __self_0_1,
                            name: ref __self_0_2,
                            uuid: ref __self_0_3,
                            genid: ref __self_0_4,
                            title: ref __self_0_5,
                            description: ref __self_0_6,
                            memory: ref __self_0_7,
                            vcpu: ref __self_0_8,
                            os: ref __self_0_9,
                            features: ref __self_0_10,
                            cpu: ref __self_0_11,
                            clock: ref __self_0_12,
                            on_poweroff: ref __self_0_13,
                            on_reboot: ref __self_0_14,
                            on_crash: ref __self_0_15,
                            pm: ref __self_0_16,
                        } => {
                            (*__self_0_0) != (*__self_1_0)
                                || (*__self_0_1) != (*__self_1_1)
                                || (*__self_0_2) != (*__self_1_2)
                                || (*__self_0_3) != (*__self_1_3)
                                || (*__self_0_4) != (*__self_1_4)
                                || (*__self_0_5) != (*__self_1_5)
                                || (*__self_0_6) != (*__self_1_6)
                                || (*__self_0_7) != (*__self_1_7)
                                || (*__self_0_8) != (*__self_1_8)
                                || (*__self_0_9) != (*__self_1_9)
                                || (*__self_0_10) != (*__self_1_10)
                                || (*__self_0_11) != (*__self_1_11)
                                || (*__self_0_12) != (*__self_1_12)
                                || (*__self_0_13) != (*__self_1_13)
                                || (*__self_0_14) != (*__self_1_14)
                                || (*__self_0_15) != (*__self_1_15)
                                || (*__self_0_16) != (*__self_1_16)
                        }
                    },
                }
            }
        }
        impl ::core::marker::StructuralEq for DomainConfig {}
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::cmp::Eq for DomainConfig {
            #[inline]
            #[doc(hidden)]
            fn assert_receiver_is_total_eq(&self) -> () {
                {
                    let _: ::core::cmp::AssertParamIsEq<String>;
                    let _: ::core::cmp::AssertParamIsEq<Option<u32>>;
                    let _: ::core::cmp::AssertParamIsEq<Option<name>>;
                    let _: ::core::cmp::AssertParamIsEq<uuid>;
                    let _: ::core::cmp::AssertParamIsEq<Option<genid>>;
                    let _: ::core::cmp::AssertParamIsEq<Option<title>>;
                    let _: ::core::cmp::AssertParamIsEq<Option<description>>;
                    let _: ::core::cmp::AssertParamIsEq<memory>;
                    let _: ::core::cmp::AssertParamIsEq<vcpu>;
                    let _: ::core::cmp::AssertParamIsEq<OpSystem>;
                    let _: ::core::cmp::AssertParamIsEq<Option<Features>>;
                    let _: ::core::cmp::AssertParamIsEq<Option<CPU>>;
                    let _: ::core::cmp::AssertParamIsEq<Option<Clock>>;
                    let _: ::core::cmp::AssertParamIsEq<Option<on_poweroff>>;
                    let _: ::core::cmp::AssertParamIsEq<Option<on_reboot>>;
                    let _: ::core::cmp::AssertParamIsEq<Option<on_crash>>;
                    let _: ::core::cmp::AssertParamIsEq<Option<PM>>;
                }
            }
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::fmt::Debug for DomainConfig {
            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
                match *self {
                    DomainConfig {
                        r#type: ref __self_0_0,
                        id: ref __self_0_1,
                        name: ref __self_0_2,
                        uuid: ref __self_0_3,
                        genid: ref __self_0_4,
                        title: ref __self_0_5,
                        description: ref __self_0_6,
                        memory: ref __self_0_7,
                        vcpu: ref __self_0_8,
                        os: ref __self_0_9,
                        features: ref __self_0_10,
                        cpu: ref __self_0_11,
                        clock: ref __self_0_12,
                        on_poweroff: ref __self_0_13,
                        on_reboot: ref __self_0_14,
                        on_crash: ref __self_0_15,
                        pm: ref __self_0_16,
                    } => {
                        let mut debug_trait_builder = f.debug_struct("DomainConfig");
                        let _ = debug_trait_builder.field("type", &&(*__self_0_0));
                        let _ = debug_trait_builder.field("id", &&(*__self_0_1));
                        let _ = debug_trait_builder.field("name", &&(*__self_0_2));
                        let _ = debug_trait_builder.field("uuid", &&(*__self_0_3));
                        let _ = debug_trait_builder.field("genid", &&(*__self_0_4));
                        let _ = debug_trait_builder.field("title", &&(*__self_0_5));
                        let _ = debug_trait_builder.field("description", &&(*__self_0_6));
                        let _ = debug_trait_builder.field("memory", &&(*__self_0_7));
                        let _ = debug_trait_builder.field("vcpu", &&(*__self_0_8));
                        let _ = debug_trait_builder.field("os", &&(*__self_0_9));
                        let _ = debug_trait_builder.field("features", &&(*__self_0_10));
                        let _ = debug_trait_builder.field("cpu", &&(*__self_0_11));
                        let _ = debug_trait_builder.field("clock", &&(*__self_0_12));
                        let _ = debug_trait_builder.field("on_poweroff", &&(*__self_0_13));
                        let _ = debug_trait_builder.field("on_reboot", &&(*__self_0_14));
                        let _ = debug_trait_builder.field("on_crash", &&(*__self_0_15));
                        let _ = debug_trait_builder.field("pm", &&(*__self_0_16));
                        debug_trait_builder.finish()
                    }
                }
            }
        }
        #[automatically_derived]
        #[allow(unused_qualifications)]
        impl ::core::clone::Clone for DomainConfig {
            #[inline]
            fn clone(&self) -> DomainConfig {
                match *self {
                    DomainConfig {
                        r#type: ref __self_0_0,
                        id: ref __self_0_1,
                        name: ref __self_0_2,
                        uuid: ref __self_0_3,
                        genid: ref __self_0_4,
                        title: ref __self_0_5,
                        description: ref __self_0_6,
                        memory: ref __self_0_7,
                        vcpu: ref __self_0_8,
                        os: ref __self_0_9,
                        features: ref __self_0_10,
                        cpu: ref __self_0_11,
                        clock: ref __self_0_12,
                        on_poweroff: ref __self_0_13,
                        on_reboot: ref __self_0_14,
                        on_crash: ref __self_0_15,
                        pm: ref __self_0_16,
                    } => DomainConfig {
                        r#type: ::core::clone::Clone::clone(&(*__self_0_0)),
                        id: ::core::clone::Clone::clone(&(*__self_0_1)),
                        name: ::core::clone::Clone::clone(&(*__self_0_2)),
                        uuid: ::core::clone::Clone::clone(&(*__self_0_3)),
                        genid: ::core::clone::Clone::clone(&(*__self_0_4)),
                        title: ::core::clone::Clone::clone(&(*__self_0_5)),
                        description: ::core::clone::Clone::clone(&(*__self_0_6)),
                        memory: ::core::clone::Clone::clone(&(*__self_0_7)),
                        vcpu: ::core::clone::Clone::clone(&(*__self_0_8)),
                        os: ::core::clone::Clone::clone(&(*__self_0_9)),
                        features: ::core::clone::Clone::clone(&(*__self_0_10)),
                        cpu: ::core::clone::Clone::clone(&(*__self_0_11)),
                        clock: ::core::clone::Clone::clone(&(*__self_0_12)),
                        on_poweroff: ::core::clone::Clone::clone(&(*__self_0_13)),
                        on_reboot: ::core::clone::Clone::clone(&(*__self_0_14)),
                        on_crash: ::core::clone::Clone::clone(&(*__self_0_15)),
                        pm: ::core::clone::Clone::clone(&(*__self_0_16)),
                    },
                }
            }
        }
        #[doc(hidden)]
        #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
        const _: () = {
            #[allow(rust_2018_idioms, clippy::useless_attribute)]
            extern crate serde as _serde;
            #[automatically_derived]
            impl _serde::Serialize for DomainConfig {
                fn serialize<__S>(
                    &self,
                    __serializer: __S,
                ) -> _serde::export::Result<__S::Ok, __S::Error>
                where
                    __S: _serde::Serializer,
                {
                    let mut __serde_state = match _serde::Serializer::serialize_struct(
                        __serializer,
                        "DomainConfig",
                        false as usize
                            + 1
                            + 1
                            + 1
                            + 1
                            + 1
                            + 1
                            + 1
                            + 1
                            + 1
                            + 1
                            + 1
                            + 1
                            + 1
                            + 1
                            + 1
                            + 1
                            + 1,
                    ) {
                        _serde::export::Ok(__val) => __val,
                        _serde::export::Err(__err) => {
                            return _serde::export::Err(__err);
                        }
                    };
                    match _serde::ser::SerializeStruct::serialize_field(
                        &mut __serde_state,
                        "type",
                        &self.r#type,
                    ) {
                        _serde::export::Ok(__val) => __val,
                        _serde::export::Err(__err) => {
                            return _serde::export::Err(__err);
                        }
                    };
                    match _serde::ser::SerializeStruct::serialize_field(
                        &mut __serde_state,
                        "id",
                        &self.id,
                    ) {
                        _serde::export::Ok(__val) => __val,
                        _serde::export::Err(__err) => {
                            return _serde::export::Err(__err);
                        }
                    };
                    match _serde::ser::SerializeStruct::serialize_field(
                        &mut __serde_state,
                        "name",
                        &self.name,
                    ) {
                        _serde::export::Ok(__val) => __val,
                        _serde::export::Err(__err) => {
                            return _serde::export::Err(__err);
                        }
                    };
                    match _serde::ser::SerializeStruct::serialize_field(
                        &mut __serde_state,
                        "uuid",
                        &self.uuid,
                    ) {
                        _serde::export::Ok(__val) => __val,
                        _serde::export::Err(__err) => {
                            return _serde::export::Err(__err);
                        }
                    };
                    match _serde::ser::SerializeStruct::serialize_field(
                        &mut __serde_state,
                        "genid",
                        &self.genid,
                    ) {
                        _serde::export::Ok(__val) => __val,
                        _serde::export::Err(__err) => {
                            return _serde::export::Err(__err);
                        }
                    };
                    match _serde::ser::SerializeStruct::serialize_field(
                        &mut __serde_state,
                        "title",
                        &self.title,
                    ) {
                        _serde::export::Ok(__val) => __val,
                        _serde::export::Err(__err) => {
                            return _serde::export::Err(__err);
                        }
                    };
                    match _serde::ser::SerializeStruct::serialize_field(
                        &mut __serde_state,
                        "description",
                        &self.description,
                    ) {
                        _serde::export::Ok(__val) => __val,
                        _serde::export::Err(__err) => {
                            return _serde::export::Err(__err);
                        }
                    };
                    match _serde::ser::SerializeStruct::serialize_field(
                        &mut __serde_state,
                        "memory",
                        &self.memory,
                    ) {
                        _serde::export::Ok(__val) => __val,
                        _serde::export::Err(__err) => {
                            return _serde::export::Err(__err);
                        }
                    };
                    match _serde::ser::SerializeStruct::serialize_field(
                        &mut __serde_state,
                        "vcpu",
                        &self.vcpu,
                    ) {
                        _serde::export::Ok(__val) => __val,
                        _serde::export::Err(__err) => {
                            return _serde::export::Err(__err);
                        }
                    };
                    match _serde::ser::SerializeStruct::serialize_field(
                        &mut __serde_state,
                        "os",
                        &self.os,
                    ) {
                        _serde::export::Ok(__val) => __val,
                        _serde::export::Err(__err) => {
                            return _serde::export::Err(__err);
                        }
                    };
                    match _serde::ser::SerializeStruct::serialize_field(
                        &mut __serde_state,
                        "features",
                        &self.features,
                    ) {
                        _serde::export::Ok(__val) => __val,
                        _serde::export::Err(__err) => {
                            return _serde::export::Err(__err);
                        }
                    };
                    match _serde::ser::SerializeStruct::serialize_field(
                        &mut __serde_state,
                        "cpu",
                        &self.cpu,
                    ) {
                        _serde::export::Ok(__val) => __val,
                        _serde::export::Err(__err) => {
                            return _serde::export::Err(__err);
                        }
                    };
                    match _serde::ser::SerializeStruct::serialize_field(
                        &mut __serde_state,
                        "clock",
                        &self.clock,
                    ) {
                        _serde::export::Ok(__val) => __val,
                        _serde::export::Err(__err) => {
                            return _serde::export::Err(__err);
                        }
                    };
                    match _serde::ser::SerializeStruct::serialize_field(
                        &mut __serde_state,
                        "on_poweroff",
                        &self.on_poweroff,
                    ) {
                        _serde::export::Ok(__val) => __val,
                        _serde::export::Err(__err) => {
                            return _serde::export::Err(__err);
                        }
                    };
                    match _serde::ser::SerializeStruct::serialize_field(
                        &mut __serde_state,
                        "on_reboot",
                        &self.on_reboot,
                    ) {
                        _serde::export::Ok(__val) => __val,
                        _serde::export::Err(__err) => {
                            return _serde::export::Err(__err);
                        }
                    };
                    match _serde::ser::SerializeStruct::serialize_field(
                        &mut __serde_state,
                        "on_crash",
                        &self.on_crash,
                    ) {
                        _serde::export::Ok(__val) => __val,
                        _serde::export::Err(__err) => {
                            return _serde::export::Err(__err);
                        }
                    };
                    match _serde::ser::SerializeStruct::serialize_field(
                        &mut __serde_state,
                        "pm",
                        &self.pm,
                    ) {
                        _serde::export::Ok(__val) => __val,
                        _serde::export::Err(__err) => {
                            return _serde::export::Err(__err);
                        }
                    };
                    _serde::ser::SerializeStruct::end(__serde_state)
                }
            }
        };
        #[doc(hidden)]
        #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
        const _: () = {
            #[allow(rust_2018_idioms, clippy::useless_attribute)]
            extern crate serde as _serde;
            #[automatically_derived]
            impl<'de> _serde::Deserialize<'de> for DomainConfig {
                fn deserialize<__D>(__deserializer: __D) -> _serde::export::Result<Self, __D::Error>
                where
                    __D: _serde::Deserializer<'de>,
                {
                    #[allow(non_camel_case_types)]
                    enum __Field {
                        __field0,
                        __field1,
                        __field2,
                        __field3,
                        __field4,
                        __field5,
                        __field6,
                        __field7,
                        __field8,
                        __field9,
                        __field10,
                        __field11,
                        __field12,
                        __field13,
                        __field14,
                        __field15,
                        __field16,
                        __ignore,
                    }
                    struct __FieldVisitor;
                    impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                        type Value = __Field;
                        fn expecting(
                            &self,
                            __formatter: &mut _serde::export::Formatter,
                        ) -> _serde::export::fmt::Result {
                            _serde::export::Formatter::write_str(__formatter, "field identifier")
                        }
                        fn visit_u64<__E>(
                            self,
                            __value: u64,
                        ) -> _serde::export::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                0u64 => _serde::export::Ok(__Field::__field0),
                                1u64 => _serde::export::Ok(__Field::__field1),
                                2u64 => _serde::export::Ok(__Field::__field2),
                                3u64 => _serde::export::Ok(__Field::__field3),
                                4u64 => _serde::export::Ok(__Field::__field4),
                                5u64 => _serde::export::Ok(__Field::__field5),
                                6u64 => _serde::export::Ok(__Field::__field6),
                                7u64 => _serde::export::Ok(__Field::__field7),
                                8u64 => _serde::export::Ok(__Field::__field8),
                                9u64 => _serde::export::Ok(__Field::__field9),
                                10u64 => _serde::export::Ok(__Field::__field10),
                                11u64 => _serde::export::Ok(__Field::__field11),
                                12u64 => _serde::export::Ok(__Field::__field12),
                                13u64 => _serde::export::Ok(__Field::__field13),
                                14u64 => _serde::export::Ok(__Field::__field14),
                                15u64 => _serde::export::Ok(__Field::__field15),
                                16u64 => _serde::export::Ok(__Field::__field16),
                                _ => _serde::export::Err(_serde::de::Error::invalid_value(
                                    _serde::de::Unexpected::Unsigned(__value),
                                    &"field index 0 <= i < 17",
                                )),
                            }
                        }
                        fn visit_str<__E>(
                            self,
                            __value: &str,
                        ) -> _serde::export::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                "type" => _serde::export::Ok(__Field::__field0),
                                "id" => _serde::export::Ok(__Field::__field1),
                                "name" => _serde::export::Ok(__Field::__field2),
                                "uuid" => _serde::export::Ok(__Field::__field3),
                                "genid" => _serde::export::Ok(__Field::__field4),
                                "title" => _serde::export::Ok(__Field::__field5),
                                "description" => _serde::export::Ok(__Field::__field6),
                                "memory" => _serde::export::Ok(__Field::__field7),
                                "vcpu" => _serde::export::Ok(__Field::__field8),
                                "os" => _serde::export::Ok(__Field::__field9),
                                "features" => _serde::export::Ok(__Field::__field10),
                                "cpu" => _serde::export::Ok(__Field::__field11),
                                "clock" => _serde::export::Ok(__Field::__field12),
                                "on_poweroff" => _serde::export::Ok(__Field::__field13),
                                "on_reboot" => _serde::export::Ok(__Field::__field14),
                                "on_crash" => _serde::export::Ok(__Field::__field15),
                                "pm" => _serde::export::Ok(__Field::__field16),
                                _ => _serde::export::Ok(__Field::__ignore),
                            }
                        }
                        fn visit_bytes<__E>(
                            self,
                            __value: &[u8],
                        ) -> _serde::export::Result<Self::Value, __E>
                        where
                            __E: _serde::de::Error,
                        {
                            match __value {
                                b"type" => _serde::export::Ok(__Field::__field0),
                                b"id" => _serde::export::Ok(__Field::__field1),
                                b"name" => _serde::export::Ok(__Field::__field2),
                                b"uuid" => _serde::export::Ok(__Field::__field3),
                                b"genid" => _serde::export::Ok(__Field::__field4),
                                b"title" => _serde::export::Ok(__Field::__field5),
                                b"description" => _serde::export::Ok(__Field::__field6),
                                b"memory" => _serde::export::Ok(__Field::__field7),
                                b"vcpu" => _serde::export::Ok(__Field::__field8),
                                b"os" => _serde::export::Ok(__Field::__field9),
                                b"features" => _serde::export::Ok(__Field::__field10),
                                b"cpu" => _serde::export::Ok(__Field::__field11),
                                b"clock" => _serde::export::Ok(__Field::__field12),
                                b"on_poweroff" => _serde::export::Ok(__Field::__field13),
                                b"on_reboot" => _serde::export::Ok(__Field::__field14),
                                b"on_crash" => _serde::export::Ok(__Field::__field15),
                                b"pm" => _serde::export::Ok(__Field::__field16),
                                _ => _serde::export::Ok(__Field::__ignore),
                            }
                        }
                    }
                    impl<'de> _serde::Deserialize<'de> for __Field {
                        #[inline]
                        fn deserialize<__D>(
                            __deserializer: __D,
                        ) -> _serde::export::Result<Self, __D::Error>
                        where
                            __D: _serde::Deserializer<'de>,
                        {
                            _serde::Deserializer::deserialize_identifier(
                                __deserializer,
                                __FieldVisitor,
                            )
                        }
                    }
                    struct __Visitor<'de> {
                        marker: _serde::export::PhantomData<DomainConfig>,
                        lifetime: _serde::export::PhantomData<&'de ()>,
                    }
                    impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                        type Value = DomainConfig;
                        fn expecting(
                            &self,
                            __formatter: &mut _serde::export::Formatter,
                        ) -> _serde::export::fmt::Result {
                            _serde::export::Formatter::write_str(__formatter, "struct DomainConfig")
                        }
                        #[inline]
                        fn visit_seq<__A>(
                            self,
                            mut __seq: __A,
                        ) -> _serde::export::Result<Self::Value, __A::Error>
                        where
                            __A: _serde::de::SeqAccess<'de>,
                        {
                            let __field0 = match match _serde::de::SeqAccess::next_element::<String>(
                                &mut __seq,
                            ) {
                                _serde::export::Ok(__val) => __val,
                                _serde::export::Err(__err) => {
                                    return _serde::export::Err(__err);
                                }
                            } {
                                _serde::export::Some(__value) => __value,
                                _serde::export::None => {
                                    return _serde::export::Err(_serde::de::Error::invalid_length(
                                        0usize,
                                        &"struct DomainConfig with 17 elements",
                                    ));
                                }
                            };
                            let __field1 = match match _serde::de::SeqAccess::next_element::<
                                Option<u32>,
                            >(&mut __seq)
                            {
                                _serde::export::Ok(__val) => __val,
                                _serde::export::Err(__err) => {
                                    return _serde::export::Err(__err);
                                }
                            } {
                                _serde::export::Some(__value) => __value,
                                _serde::export::None => {
                                    return _serde::export::Err(_serde::de::Error::invalid_length(
                                        1usize,
                                        &"struct DomainConfig with 17 elements",
                                    ));
                                }
                            };
                            let __field2 = match match _serde::de::SeqAccess::next_element::<
                                Option<name>,
                            >(&mut __seq)
                            {
                                _serde::export::Ok(__val) => __val,
                                _serde::export::Err(__err) => {
                                    return _serde::export::Err(__err);
                                }
                            } {
                                _serde::export::Some(__value) => __value,
                                _serde::export::None => {
                                    return _serde::export::Err(_serde::de::Error::invalid_length(
                                        2usize,
                                        &"struct DomainConfig with 17 elements",
                                    ));
                                }
                            };
                            let __field3 =
                                match match _serde::de::SeqAccess::next_element::<uuid>(&mut __seq)
                                {
                                    _serde::export::Ok(__val) => __val,
                                    _serde::export::Err(__err) => {
                                        return _serde::export::Err(__err);
                                    }
                                } {
                                    _serde::export::Some(__value) => __value,
                                    _serde::export::None => {
                                        return _serde::export::Err(
                                            _serde::de::Error::invalid_length(
                                                3usize,
                                                &"struct DomainConfig with 17 elements",
                                            ),
                                        );
                                    }
                                };
                            let __field4 = match match _serde::de::SeqAccess::next_element::<
                                Option<genid>,
                            >(&mut __seq)
                            {
                                _serde::export::Ok(__val) => __val,
                                _serde::export::Err(__err) => {
                                    return _serde::export::Err(__err);
                                }
                            } {
                                _serde::export::Some(__value) => __value,
                                _serde::export::None => {
                                    return _serde::export::Err(_serde::de::Error::invalid_length(
                                        4usize,
                                        &"struct DomainConfig with 17 elements",
                                    ));
                                }
                            };
                            let __field5 = match match _serde::de::SeqAccess::next_element::<
                                Option<title>,
                            >(&mut __seq)
                            {
                                _serde::export::Ok(__val) => __val,
                                _serde::export::Err(__err) => {
                                    return _serde::export::Err(__err);
                                }
                            } {
                                _serde::export::Some(__value) => __value,
                                _serde::export::None => {
                                    return _serde::export::Err(_serde::de::Error::invalid_length(
                                        5usize,
                                        &"struct DomainConfig with 17 elements",
                                    ));
                                }
                            };
                            let __field6 = match match _serde::de::SeqAccess::next_element::<
                                Option<description>,
                            >(&mut __seq)
                            {
                                _serde::export::Ok(__val) => __val,
                                _serde::export::Err(__err) => {
                                    return _serde::export::Err(__err);
                                }
                            } {
                                _serde::export::Some(__value) => __value,
                                _serde::export::None => {
                                    return _serde::export::Err(_serde::de::Error::invalid_length(
                                        6usize,
                                        &"struct DomainConfig with 17 elements",
                                    ));
                                }
                            };
                            let __field7 = match match _serde::de::SeqAccess::next_element::<memory>(
                                &mut __seq,
                            ) {
                                _serde::export::Ok(__val) => __val,
                                _serde::export::Err(__err) => {
                                    return _serde::export::Err(__err);
                                }
                            } {
                                _serde::export::Some(__value) => __value,
                                _serde::export::None => {
                                    return _serde::export::Err(_serde::de::Error::invalid_length(
                                        7usize,
                                        &"struct DomainConfig with 17 elements",
                                    ));
                                }
                            };
                            let __field8 =
                                match match _serde::de::SeqAccess::next_element::<vcpu>(&mut __seq)
                                {
                                    _serde::export::Ok(__val) => __val,
                                    _serde::export::Err(__err) => {
                                        return _serde::export::Err(__err);
                                    }
                                } {
                                    _serde::export::Some(__value) => __value,
                                    _serde::export::None => {
                                        return _serde::export::Err(
                                            _serde::de::Error::invalid_length(
                                                8usize,
                                                &"struct DomainConfig with 17 elements",
                                            ),
                                        );
                                    }
                                };
                            let __field9 = match match _serde::de::SeqAccess::next_element::<OpSystem>(
                                &mut __seq,
                            ) {
                                _serde::export::Ok(__val) => __val,
                                _serde::export::Err(__err) => {
                                    return _serde::export::Err(__err);
                                }
                            } {
                                _serde::export::Some(__value) => __value,
                                _serde::export::None => {
                                    return _serde::export::Err(_serde::de::Error::invalid_length(
                                        9usize,
                                        &"struct DomainConfig with 17 elements",
                                    ));
                                }
                            };
                            let __field10 = match match _serde::de::SeqAccess::next_element::<
                                Option<Features>,
                            >(&mut __seq)
                            {
                                _serde::export::Ok(__val) => __val,
                                _serde::export::Err(__err) => {
                                    return _serde::export::Err(__err);
                                }
                            } {
                                _serde::export::Some(__value) => __value,
                                _serde::export::None => {
                                    return _serde::export::Err(_serde::de::Error::invalid_length(
                                        10usize,
                                        &"struct DomainConfig with 17 elements",
                                    ));
                                }
                            };
                            let __field11 = match match _serde::de::SeqAccess::next_element::<
                                Option<CPU>,
                            >(&mut __seq)
                            {
                                _serde::export::Ok(__val) => __val,
                                _serde::export::Err(__err) => {
                                    return _serde::export::Err(__err);
                                }
                            } {
                                _serde::export::Some(__value) => __value,
                                _serde::export::None => {
                                    return _serde::export::Err(_serde::de::Error::invalid_length(
                                        11usize,
                                        &"struct DomainConfig with 17 elements",
                                    ));
                                }
                            };
                            let __field12 = match match _serde::de::SeqAccess::next_element::<
                                Option<Clock>,
                            >(&mut __seq)
                            {
                                _serde::export::Ok(__val) => __val,
                                _serde::export::Err(__err) => {
                                    return _serde::export::Err(__err);
                                }
                            } {
                                _serde::export::Some(__value) => __value,
                                _serde::export::None => {
                                    return _serde::export::Err(_serde::de::Error::invalid_length(
                                        12usize,
                                        &"struct DomainConfig with 17 elements",
                                    ));
                                }
                            };
                            let __field13 = match match _serde::de::SeqAccess::next_element::<
                                Option<on_poweroff>,
                            >(&mut __seq)
                            {
                                _serde::export::Ok(__val) => __val,
                                _serde::export::Err(__err) => {
                                    return _serde::export::Err(__err);
                                }
                            } {
                                _serde::export::Some(__value) => __value,
                                _serde::export::None => {
                                    return _serde::export::Err(_serde::de::Error::invalid_length(
                                        13usize,
                                        &"struct DomainConfig with 17 elements",
                                    ));
                                }
                            };
                            let __field14 = match match _serde::de::SeqAccess::next_element::<
                                Option<on_reboot>,
                            >(&mut __seq)
                            {
                                _serde::export::Ok(__val) => __val,
                                _serde::export::Err(__err) => {
                                    return _serde::export::Err(__err);
                                }
                            } {
                                _serde::export::Some(__value) => __value,
                                _serde::export::None => {
                                    return _serde::export::Err(_serde::de::Error::invalid_length(
                                        14usize,
                                        &"struct DomainConfig with 17 elements",
                                    ));
                                }
                            };
                            let __field15 = match match _serde::de::SeqAccess::next_element::<
                                Option<on_crash>,
                            >(&mut __seq)
                            {
                                _serde::export::Ok(__val) => __val,
                                _serde::export::Err(__err) => {
                                    return _serde::export::Err(__err);
                                }
                            } {
                                _serde::export::Some(__value) => __value,
                                _serde::export::None => {
                                    return _serde::export::Err(_serde::de::Error::invalid_length(
                                        15usize,
                                        &"struct DomainConfig with 17 elements",
                                    ));
                                }
                            };
                            let __field16 = match match _serde::de::SeqAccess::next_element::<
                                Option<PM>,
                            >(&mut __seq)
                            {
                                _serde::export::Ok(__val) => __val,
                                _serde::export::Err(__err) => {
                                    return _serde::export::Err(__err);
                                }
                            } {
                                _serde::export::Some(__value) => __value,
                                _serde::export::None => {
                                    return _serde::export::Err(_serde::de::Error::invalid_length(
                                        16usize,
                                        &"struct DomainConfig with 17 elements",
                                    ));
                                }
                            };
                            _serde::export::Ok(DomainConfig {
                                r#type: __field0,
                                id: __field1,
                                name: __field2,
                                uuid: __field3,
                                genid: __field4,
                                title: __field5,
                                description: __field6,
                                memory: __field7,
                                vcpu: __field8,
                                os: __field9,
                                features: __field10,
                                cpu: __field11,
                                clock: __field12,
                                on_poweroff: __field13,
                                on_reboot: __field14,
                                on_crash: __field15,
                                pm: __field16,
                            })
                        }
                        #[inline]
                        fn visit_map<__A>(
                            self,
                            mut __map: __A,
                        ) -> _serde::export::Result<Self::Value, __A::Error>
                        where
                            __A: _serde::de::MapAccess<'de>,
                        {
                            let mut __field0: _serde::export::Option<String> = _serde::export::None;
                            let mut __field1: _serde::export::Option<Option<u32>> =
                                _serde::export::None;
                            let mut __field2: _serde::export::Option<Option<name>> =
                                _serde::export::None;
                            let mut __field3: _serde::export::Option<uuid> = _serde::export::None;
                            let mut __field4: _serde::export::Option<Option<genid>> =
                                _serde::export::None;
                            let mut __field5: _serde::export::Option<Option<title>> =
                                _serde::export::None;
                            let mut __field6: _serde::export::Option<Option<description>> =
                                _serde::export::None;
                            let mut __field7: _serde::export::Option<memory> = _serde::export::None;
                            let mut __field8: _serde::export::Option<vcpu> = _serde::export::None;
                            let mut __field9: _serde::export::Option<OpSystem> =
                                _serde::export::None;
                            let mut __field10: _serde::export::Option<Option<Features>> =
                                _serde::export::None;
                            let mut __field11: _serde::export::Option<Option<CPU>> =
                                _serde::export::None;
                            let mut __field12: _serde::export::Option<Option<Clock>> =
                                _serde::export::None;
                            let mut __field13: _serde::export::Option<Option<on_poweroff>> =
                                _serde::export::None;
                            let mut __field14: _serde::export::Option<Option<on_reboot>> =
                                _serde::export::None;
                            let mut __field15: _serde::export::Option<Option<on_crash>> =
                                _serde::export::None;
                            let mut __field16: _serde::export::Option<Option<PM>> =
                                _serde::export::None;
                            while let _serde::export::Some(__key) =
                                match _serde::de::MapAccess::next_key::<__Field>(&mut __map) {
                                    _serde::export::Ok(__val) => __val,
                                    _serde::export::Err(__err) => {
                                        return _serde::export::Err(__err);
                                    }
                                }
                            {
                                match __key {
                                    __Field::__field0 => {
                                        if _serde::export::Option::is_some(&__field0) {
                                            return _serde::export::Err(
                                                <__A::Error as _serde::de::Error>::duplicate_field(
                                                    "type",
                                                ),
                                            );
                                        }
                                        __field0 = _serde::export::Some(
                                            match _serde::de::MapAccess::next_value::<String>(
                                                &mut __map,
                                            ) {
                                                _serde::export::Ok(__val) => __val,
                                                _serde::export::Err(__err) => {
                                                    return _serde::export::Err(__err);
                                                }
                                            },
                                        );
                                    }
                                    __Field::__field1 => {
                                        if _serde::export::Option::is_some(&__field1) {
                                            return _serde::export::Err(
                                                <__A::Error as _serde::de::Error>::duplicate_field(
                                                    "id",
                                                ),
                                            );
                                        }
                                        __field1 = _serde::export::Some(
                                            match _serde::de::MapAccess::next_value::<Option<u32>>(
                                                &mut __map,
                                            ) {
                                                _serde::export::Ok(__val) => __val,
                                                _serde::export::Err(__err) => {
                                                    return _serde::export::Err(__err);
                                                }
                                            },
                                        );
                                    }
                                    __Field::__field2 => {
                                        if _serde::export::Option::is_some(&__field2) {
                                            return _serde::export::Err(
                                                <__A::Error as _serde::de::Error>::duplicate_field(
                                                    "name",
                                                ),
                                            );
                                        }
                                        __field2 = _serde::export::Some(
                                            match _serde::de::MapAccess::next_value::<Option<name>>(
                                                &mut __map,
                                            ) {
                                                _serde::export::Ok(__val) => __val,
                                                _serde::export::Err(__err) => {
                                                    return _serde::export::Err(__err);
                                                }
                                            },
                                        );
                                    }
                                    __Field::__field3 => {
                                        if _serde::export::Option::is_some(&__field3) {
                                            return _serde::export::Err(
                                                <__A::Error as _serde::de::Error>::duplicate_field(
                                                    "uuid",
                                                ),
                                            );
                                        }
                                        __field3 = _serde::export::Some(
                                            match _serde::de::MapAccess::next_value::<uuid>(
                                                &mut __map,
                                            ) {
                                                _serde::export::Ok(__val) => __val,
                                                _serde::export::Err(__err) => {
                                                    return _serde::export::Err(__err);
                                                }
                                            },
                                        );
                                    }
                                    __Field::__field4 => {
                                        if _serde::export::Option::is_some(&__field4) {
                                            return _serde::export::Err(
                                                <__A::Error as _serde::de::Error>::duplicate_field(
                                                    "genid",
                                                ),
                                            );
                                        }
                                        __field4 = _serde::export::Some(
                                            match _serde::de::MapAccess::next_value::<Option<genid>>(
                                                &mut __map,
                                            ) {
                                                _serde::export::Ok(__val) => __val,
                                                _serde::export::Err(__err) => {
                                                    return _serde::export::Err(__err);
                                                }
                                            },
                                        );
                                    }
                                    __Field::__field5 => {
                                        if _serde::export::Option::is_some(&__field5) {
                                            return _serde::export::Err(
                                                <__A::Error as _serde::de::Error>::duplicate_field(
                                                    "title",
                                                ),
                                            );
                                        }
                                        __field5 = _serde::export::Some(
                                            match _serde::de::MapAccess::next_value::<Option<title>>(
                                                &mut __map,
                                            ) {
                                                _serde::export::Ok(__val) => __val,
                                                _serde::export::Err(__err) => {
                                                    return _serde::export::Err(__err);
                                                }
                                            },
                                        );
                                    }
                                    __Field::__field6 => {
                                        if _serde::export::Option::is_some(&__field6) {
                                            return _serde::export::Err(
                                                <__A::Error as _serde::de::Error>::duplicate_field(
                                                    "description",
                                                ),
                                            );
                                        }
                                        __field6 = _serde::export::Some(
                                            match _serde::de::MapAccess::next_value::<
                                                Option<description>,
                                            >(
                                                &mut __map
                                            ) {
                                                _serde::export::Ok(__val) => __val,
                                                _serde::export::Err(__err) => {
                                                    return _serde::export::Err(__err);
                                                }
                                            },
                                        );
                                    }
                                    __Field::__field7 => {
                                        if _serde::export::Option::is_some(&__field7) {
                                            return _serde::export::Err(
                                                <__A::Error as _serde::de::Error>::duplicate_field(
                                                    "memory",
                                                ),
                                            );
                                        }
                                        __field7 = _serde::export::Some(
                                            match _serde::de::MapAccess::next_value::<memory>(
                                                &mut __map,
                                            ) {
                                                _serde::export::Ok(__val) => __val,
                                                _serde::export::Err(__err) => {
                                                    return _serde::export::Err(__err);
                                                }
                                            },
                                        );
                                    }
                                    __Field::__field8 => {
                                        if _serde::export::Option::is_some(&__field8) {
                                            return _serde::export::Err(
                                                <__A::Error as _serde::de::Error>::duplicate_field(
                                                    "vcpu",
                                                ),
                                            );
                                        }
                                        __field8 = _serde::export::Some(
                                            match _serde::de::MapAccess::next_value::<vcpu>(
                                                &mut __map,
                                            ) {
                                                _serde::export::Ok(__val) => __val,
                                                _serde::export::Err(__err) => {
                                                    return _serde::export::Err(__err);
                                                }
                                            },
                                        );
                                    }
                                    __Field::__field9 => {
                                        if _serde::export::Option::is_some(&__field9) {
                                            return _serde::export::Err(
                                                <__A::Error as _serde::de::Error>::duplicate_field(
                                                    "os",
                                                ),
                                            );
                                        }
                                        __field9 = _serde::export::Some(
                                            match _serde::de::MapAccess::next_value::<OpSystem>(
                                                &mut __map,
                                            ) {
                                                _serde::export::Ok(__val) => __val,
                                                _serde::export::Err(__err) => {
                                                    return _serde::export::Err(__err);
                                                }
                                            },
                                        );
                                    }
                                    __Field::__field10 => {
                                        if _serde::export::Option::is_some(&__field10) {
                                            return _serde::export::Err(
                                                <__A::Error as _serde::de::Error>::duplicate_field(
                                                    "features",
                                                ),
                                            );
                                        }
                                        __field10 = _serde::export::Some(
                                            match _serde::de::MapAccess::next_value::<
                                                Option<Features>,
                                            >(
                                                &mut __map
                                            ) {
                                                _serde::export::Ok(__val) => __val,
                                                _serde::export::Err(__err) => {
                                                    return _serde::export::Err(__err);
                                                }
                                            },
                                        );
                                    }
                                    __Field::__field11 => {
                                        if _serde::export::Option::is_some(&__field11) {
                                            return _serde::export::Err(
                                                <__A::Error as _serde::de::Error>::duplicate_field(
                                                    "cpu",
                                                ),
                                            );
                                        }
                                        __field11 = _serde::export::Some(
                                            match _serde::de::MapAccess::next_value::<Option<CPU>>(
                                                &mut __map,
                                            ) {
                                                _serde::export::Ok(__val) => __val,
                                                _serde::export::Err(__err) => {
                                                    return _serde::export::Err(__err);
                                                }
                                            },
                                        );
                                    }
                                    __Field::__field12 => {
                                        if _serde::export::Option::is_some(&__field12) {
                                            return _serde::export::Err(
                                                <__A::Error as _serde::de::Error>::duplicate_field(
                                                    "clock",
                                                ),
                                            );
                                        }
                                        __field12 = _serde::export::Some(
                                            match _serde::de::MapAccess::next_value::<Option<Clock>>(
                                                &mut __map,
                                            ) {
                                                _serde::export::Ok(__val) => __val,
                                                _serde::export::Err(__err) => {
                                                    return _serde::export::Err(__err);
                                                }
                                            },
                                        );
                                    }
                                    __Field::__field13 => {
                                        if _serde::export::Option::is_some(&__field13) {
                                            return _serde::export::Err(
                                                <__A::Error as _serde::de::Error>::duplicate_field(
                                                    "on_poweroff",
                                                ),
                                            );
                                        }
                                        __field13 = _serde::export::Some(
                                            match _serde::de::MapAccess::next_value::<
                                                Option<on_poweroff>,
                                            >(
                                                &mut __map
                                            ) {
                                                _serde::export::Ok(__val) => __val,
                                                _serde::export::Err(__err) => {
                                                    return _serde::export::Err(__err);
                                                }
                                            },
                                        );
                                    }
                                    __Field::__field14 => {
                                        if _serde::export::Option::is_some(&__field14) {
                                            return _serde::export::Err(
                                                <__A::Error as _serde::de::Error>::duplicate_field(
                                                    "on_reboot",
                                                ),
                                            );
                                        }
                                        __field14 = _serde::export::Some(
                                            match _serde::de::MapAccess::next_value::<
                                                Option<on_reboot>,
                                            >(
                                                &mut __map
                                            ) {
                                                _serde::export::Ok(__val) => __val,
                                                _serde::export::Err(__err) => {
                                                    return _serde::export::Err(__err);
                                                }
                                            },
                                        );
                                    }
                                    __Field::__field15 => {
                                        if _serde::export::Option::is_some(&__field15) {
                                            return _serde::export::Err(
                                                <__A::Error as _serde::de::Error>::duplicate_field(
                                                    "on_crash",
                                                ),
                                            );
                                        }
                                        __field15 = _serde::export::Some(
                                            match _serde::de::MapAccess::next_value::<
                                                Option<on_crash>,
                                            >(
                                                &mut __map
                                            ) {
                                                _serde::export::Ok(__val) => __val,
                                                _serde::export::Err(__err) => {
                                                    return _serde::export::Err(__err);
                                                }
                                            },
                                        );
                                    }
                                    __Field::__field16 => {
                                        if _serde::export::Option::is_some(&__field16) {
                                            return _serde::export::Err(
                                                <__A::Error as _serde::de::Error>::duplicate_field(
                                                    "pm",
                                                ),
                                            );
                                        }
                                        __field16 = _serde::export::Some(
                                            match _serde::de::MapAccess::next_value::<Option<PM>>(
                                                &mut __map,
                                            ) {
                                                _serde::export::Ok(__val) => __val,
                                                _serde::export::Err(__err) => {
                                                    return _serde::export::Err(__err);
                                                }
                                            },
                                        );
                                    }
                                    _ => {
                                        let _ = match _serde::de::MapAccess::next_value::<
                                            _serde::de::IgnoredAny,
                                        >(
                                            &mut __map
                                        ) {
                                            _serde::export::Ok(__val) => __val,
                                            _serde::export::Err(__err) => {
                                                return _serde::export::Err(__err);
                                            }
                                        };
                                    }
                                }
                            }
                            let __field0 = match __field0 {
                                _serde::export::Some(__field0) => __field0,
                                _serde::export::None => {
                                    match _serde::private::de::missing_field("type") {
                                        _serde::export::Ok(__val) => __val,
                                        _serde::export::Err(__err) => {
                                            return _serde::export::Err(__err);
                                        }
                                    }
                                }
                            };
                            let __field1 = match __field1 {
                                _serde::export::Some(__field1) => __field1,
                                _serde::export::None => {
                                    match _serde::private::de::missing_field("id") {
                                        _serde::export::Ok(__val) => __val,
                                        _serde::export::Err(__err) => {
                                            return _serde::export::Err(__err);
                                        }
                                    }
                                }
                            };
                            let __field2 = match __field2 {
                                _serde::export::Some(__field2) => __field2,
                                _serde::export::None => {
                                    match _serde::private::de::missing_field("name") {
                                        _serde::export::Ok(__val) => __val,
                                        _serde::export::Err(__err) => {
                                            return _serde::export::Err(__err);
                                        }
                                    }
                                }
                            };
                            let __field3 = match __field3 {
                                _serde::export::Some(__field3) => __field3,
                                _serde::export::None => {
                                    match _serde::private::de::missing_field("uuid") {
                                        _serde::export::Ok(__val) => __val,
                                        _serde::export::Err(__err) => {
                                            return _serde::export::Err(__err);
                                        }
                                    }
                                }
                            };
                            let __field4 = match __field4 {
                                _serde::export::Some(__field4) => __field4,
                                _serde::export::None => {
                                    match _serde::private::de::missing_field("genid") {
                                        _serde::export::Ok(__val) => __val,
                                        _serde::export::Err(__err) => {
                                            return _serde::export::Err(__err);
                                        }
                                    }
                                }
                            };
                            let __field5 = match __field5 {
                                _serde::export::Some(__field5) => __field5,
                                _serde::export::None => {
                                    match _serde::private::de::missing_field("title") {
                                        _serde::export::Ok(__val) => __val,
                                        _serde::export::Err(__err) => {
                                            return _serde::export::Err(__err);
                                        }
                                    }
                                }
                            };
                            let __field6 = match __field6 {
                                _serde::export::Some(__field6) => __field6,
                                _serde::export::None => {
                                    match _serde::private::de::missing_field("description") {
                                        _serde::export::Ok(__val) => __val,
                                        _serde::export::Err(__err) => {
                                            return _serde::export::Err(__err);
                                        }
                                    }
                                }
                            };
                            let __field7 = match __field7 {
                                _serde::export::Some(__field7) => __field7,
                                _serde::export::None => {
                                    match _serde::private::de::missing_field("memory") {
                                        _serde::export::Ok(__val) => __val,
                                        _serde::export::Err(__err) => {
                                            return _serde::export::Err(__err);
                                        }
                                    }
                                }
                            };
                            let __field8 = match __field8 {
                                _serde::export::Some(__field8) => __field8,
                                _serde::export::None => {
                                    match _serde::private::de::missing_field("vcpu") {
                                        _serde::export::Ok(__val) => __val,
                                        _serde::export::Err(__err) => {
                                            return _serde::export::Err(__err);
                                        }
                                    }
                                }
                            };
                            let __field9 = match __field9 {
                                _serde::export::Some(__field9) => __field9,
                                _serde::export::None => {
                                    match _serde::private::de::missing_field("os") {
                                        _serde::export::Ok(__val) => __val,
                                        _serde::export::Err(__err) => {
                                            return _serde::export::Err(__err);
                                        }
                                    }
                                }
                            };
                            let __field10 = match __field10 {
                                _serde::export::Some(__field10) => __field10,
                                _serde::export::None => {
                                    match _serde::private::de::missing_field("features") {
                                        _serde::export::Ok(__val) => __val,
                                        _serde::export::Err(__err) => {
                                            return _serde::export::Err(__err);
                                        }
                                    }
                                }
                            };
                            let __field11 = match __field11 {
                                _serde::export::Some(__field11) => __field11,
                                _serde::export::None => {
                                    match _serde::private::de::missing_field("cpu") {
                                        _serde::export::Ok(__val) => __val,
                                        _serde::export::Err(__err) => {
                                            return _serde::export::Err(__err);
                                        }
                                    }
                                }
                            };
                            let __field12 = match __field12 {
                                _serde::export::Some(__field12) => __field12,
                                _serde::export::None => {
                                    match _serde::private::de::missing_field("clock") {
                                        _serde::export::Ok(__val) => __val,
                                        _serde::export::Err(__err) => {
                                            return _serde::export::Err(__err);
                                        }
                                    }
                                }
                            };
                            let __field13 = match __field13 {
                                _serde::export::Some(__field13) => __field13,
                                _serde::export::None => {
                                    match _serde::private::de::missing_field("on_poweroff") {
                                        _serde::export::Ok(__val) => __val,
                                        _serde::export::Err(__err) => {
                                            return _serde::export::Err(__err);
                                        }
                                    }
                                }
                            };
                            let __field14 = match __field14 {
                                _serde::export::Some(__field14) => __field14,
                                _serde::export::None => {
                                    match _serde::private::de::missing_field("on_reboot") {
                                        _serde::export::Ok(__val) => __val,
                                        _serde::export::Err(__err) => {
                                            return _serde::export::Err(__err);
                                        }
                                    }
                                }
                            };
                            let __field15 = match __field15 {
                                _serde::export::Some(__field15) => __field15,
                                _serde::export::None => {
                                    match _serde::private::de::missing_field("on_crash") {
                                        _serde::export::Ok(__val) => __val,
                                        _serde::export::Err(__err) => {
                                            return _serde::export::Err(__err);
                                        }
                                    }
                                }
                            };
                            let __field16 = match __field16 {
                                _serde::export::Some(__field16) => __field16,
                                _serde::export::None => {
                                    match _serde::private::de::missing_field("pm") {
                                        _serde::export::Ok(__val) => __val,
                                        _serde::export::Err(__err) => {
                                            return _serde::export::Err(__err);
                                        }
                                    }
                                }
                            };
                            _serde::export::Ok(DomainConfig {
                                r#type: __field0,
                                id: __field1,
                                name: __field2,
                                uuid: __field3,
                                genid: __field4,
                                title: __field5,
                                description: __field6,
                                memory: __field7,
                                vcpu: __field8,
                                os: __field9,
                                features: __field10,
                                cpu: __field11,
                                clock: __field12,
                                on_poweroff: __field13,
                                on_reboot: __field14,
                                on_crash: __field15,
                                pm: __field16,
                            })
                        }
                    }
                    const FIELDS: &'static [&'static str] = &[
                        "type",
                        "id",
                        "name",
                        "uuid",
                        "genid",
                        "title",
                        "description",
                        "memory",
                        "vcpu",
                        "os",
                        "features",
                        "cpu",
                        "clock",
                        "on_poweroff",
                        "on_reboot",
                        "on_crash",
                        "pm",
                    ];
                    _serde::Deserializer::deserialize_struct(
                        __deserializer,
                        "DomainConfig",
                        FIELDS,
                        __Visitor {
                            marker: _serde::export::PhantomData::<DomainConfig>,
                            lifetime: _serde::export::PhantomData,
                        },
                    )
                }
            }
        };
        impl DomainConfig {
            pub fn mut_os(&mut self) -> &mut OpSystem {
                &mut self.os
            }
            pub fn os(&self) -> &OpSystem {
                &self.os
            }
        }
    }
    use derive_more::{Display};
    use crate::{EnvData, EnvType, ExecEnv, RemoteEnv};
    use networking::NetworkError;
    use std::convert::TryInto;
    use std::error::Error;
    use std::str::FromStr;
    pub struct VirtualEnv {
        key: [u8; 16],
        code: Vec<u8>,
        env: RemoteEnv,
    }
    impl VirtualEnv {
        pub fn empty(env_type: EnvType) -> Result<Self, NetworkError> {
            Ok(Self {
                key: [0; 16],
                code: Vec::new(),
                env: RemoteEnv::init(env_type)?,
            })
        }
        pub fn load(mut self, code: &[u8], key: &[u8]) -> Result<Self, NetworkError> {
            self.key = key.try_into()?;
            self.code.extend_from_slice(code);
            Ok(self)
        }
    }
    impl EnvData for VirtualEnv {
        fn trusted(&self) -> bool {
            self.env.trusted()
        }
        fn os_name(&self) -> &str {
            self.env.os_name()
        }
        fn arch_name(&self) -> &str {
            self.env.arch_name()
        }
        fn total_mem(&self) -> u64 {
            self.env.total_mem()
        }
        fn cpu_count(&self) -> u16 {
            self.env.cpu_count()
        }
        fn cpu_speed(&self) -> u16 {
            self.env.cpu_speed()
        }
    }
    impl ExecEnv for VirtualEnv {
        type Error = NetworkError;
    }
    pub struct NativeEnv {
        env: RemoteEnv,
    }
    impl NativeEnv {}
    impl ExecEnv for NativeEnv {
        type Error = NetworkError;
    }
    impl EnvData for NativeEnv {
        fn trusted(&self) -> bool {
            self.env.trusted()
        }
        fn os_name(&self) -> &str {
            self.env.os_name()
        }
        fn arch_name(&self) -> &str {
            self.env.arch_name()
        }
        fn total_mem(&self) -> u64 {
            self.env.total_mem()
        }
        fn cpu_count(&self) -> u16 {
            self.env.cpu_count()
        }
        fn cpu_speed(&self) -> u16 {
            self.env.cpu_speed()
        }
    }
    /// contains definitions for various data sizes
    pub enum Unit {
        /// kibibytes
        KiB,
        /// membibytes
        MiB,
        /// gibibytes
        GiB,
        /// tibibytes
        TiB,
        /// pebibytes
        PiB,
        /// kilabytes
        KB,
        /// megabayes
        MB,
        /// gigabytes
        GB,
        /// terabytes
        TB,
        /// petabytes
        PB,
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::fmt::Debug for Unit {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            match (&*self,) {
                (&Unit::KiB,) => {
                    let mut debug_trait_builder = f.debug_tuple("KiB");
                    debug_trait_builder.finish()
                }
                (&Unit::MiB,) => {
                    let mut debug_trait_builder = f.debug_tuple("MiB");
                    debug_trait_builder.finish()
                }
                (&Unit::GiB,) => {
                    let mut debug_trait_builder = f.debug_tuple("GiB");
                    debug_trait_builder.finish()
                }
                (&Unit::TiB,) => {
                    let mut debug_trait_builder = f.debug_tuple("TiB");
                    debug_trait_builder.finish()
                }
                (&Unit::PiB,) => {
                    let mut debug_trait_builder = f.debug_tuple("PiB");
                    debug_trait_builder.finish()
                }
                (&Unit::KB,) => {
                    let mut debug_trait_builder = f.debug_tuple("KB");
                    debug_trait_builder.finish()
                }
                (&Unit::MB,) => {
                    let mut debug_trait_builder = f.debug_tuple("MB");
                    debug_trait_builder.finish()
                }
                (&Unit::GB,) => {
                    let mut debug_trait_builder = f.debug_tuple("GB");
                    debug_trait_builder.finish()
                }
                (&Unit::TB,) => {
                    let mut debug_trait_builder = f.debug_tuple("TB");
                    debug_trait_builder.finish()
                }
                (&Unit::PB,) => {
                    let mut debug_trait_builder = f.debug_tuple("PB");
                    debug_trait_builder.finish()
                }
            }
        }
    }
    impl ::core::fmt::Display for Unit {
        #[allow(unused_variables)]
        #[inline]
        fn fmt(
            &self,
            _derive_more_display_formatter: &mut ::core::fmt::Formatter,
        ) -> ::core::fmt::Result {
            match self {
                Unit::KiB => _derive_more_display_formatter.write_str("KiB"),
                Unit::MiB => _derive_more_display_formatter.write_str("MiB"),
                Unit::GiB => _derive_more_display_formatter.write_str("GiB"),
                Unit::TiB => _derive_more_display_formatter.write_str("TiB"),
                Unit::PiB => _derive_more_display_formatter.write_str("PiB"),
                Unit::KB => _derive_more_display_formatter.write_str("KB"),
                Unit::MB => _derive_more_display_formatter.write_str("MB"),
                Unit::GB => _derive_more_display_formatter.write_str("GB"),
                Unit::TB => _derive_more_display_formatter.write_str("TB"),
                Unit::PB => _derive_more_display_formatter.write_str("PB"),
                _ => Ok(()),
            }
        }
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::clone::Clone for Unit {
        #[inline]
        fn clone(&self) -> Unit {
            {
                *self
            }
        }
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::marker::Copy for Unit {}
    #[doc(hidden)]
    #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
    const _: () = {
        #[allow(rust_2018_idioms, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl _serde::Serialize for Unit {
            fn serialize<__S>(
                &self,
                __serializer: __S,
            ) -> _serde::export::Result<__S::Ok, __S::Error>
            where
                __S: _serde::Serializer,
            {
                match *self {
                    Unit::KiB => _serde::Serializer::serialize_unit_variant(
                        __serializer,
                        "Unit",
                        0u32,
                        "KiB",
                    ),
                    Unit::MiB => _serde::Serializer::serialize_unit_variant(
                        __serializer,
                        "Unit",
                        1u32,
                        "MiB",
                    ),
                    Unit::GiB => _serde::Serializer::serialize_unit_variant(
                        __serializer,
                        "Unit",
                        2u32,
                        "GiB",
                    ),
                    Unit::TiB => _serde::Serializer::serialize_unit_variant(
                        __serializer,
                        "Unit",
                        3u32,
                        "TiB",
                    ),
                    Unit::PiB => _serde::Serializer::serialize_unit_variant(
                        __serializer,
                        "Unit",
                        4u32,
                        "PiB",
                    ),
                    Unit::KB => {
                        _serde::Serializer::serialize_unit_variant(__serializer, "Unit", 5u32, "KB")
                    }
                    Unit::MB => {
                        _serde::Serializer::serialize_unit_variant(__serializer, "Unit", 6u32, "MB")
                    }
                    Unit::GB => {
                        _serde::Serializer::serialize_unit_variant(__serializer, "Unit", 7u32, "GB")
                    }
                    Unit::TB => {
                        _serde::Serializer::serialize_unit_variant(__serializer, "Unit", 8u32, "TB")
                    }
                    Unit::PB => {
                        _serde::Serializer::serialize_unit_variant(__serializer, "Unit", 9u32, "PB")
                    }
                }
            }
        }
    };
    #[doc(hidden)]
    #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
    const _: () = {
        #[allow(rust_2018_idioms, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl<'de> _serde::Deserialize<'de> for Unit {
            fn deserialize<__D>(__deserializer: __D) -> _serde::export::Result<Self, __D::Error>
            where
                __D: _serde::Deserializer<'de>,
            {
                #[allow(non_camel_case_types)]
                enum __Field {
                    __field0,
                    __field1,
                    __field2,
                    __field3,
                    __field4,
                    __field5,
                    __field6,
                    __field7,
                    __field8,
                    __field9,
                }
                struct __FieldVisitor;
                impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                    type Value = __Field;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::export::Formatter,
                    ) -> _serde::export::fmt::Result {
                        _serde::export::Formatter::write_str(__formatter, "variant identifier")
                    }
                    fn visit_u64<__E>(
                        self,
                        __value: u64,
                    ) -> _serde::export::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            0u64 => _serde::export::Ok(__Field::__field0),
                            1u64 => _serde::export::Ok(__Field::__field1),
                            2u64 => _serde::export::Ok(__Field::__field2),
                            3u64 => _serde::export::Ok(__Field::__field3),
                            4u64 => _serde::export::Ok(__Field::__field4),
                            5u64 => _serde::export::Ok(__Field::__field5),
                            6u64 => _serde::export::Ok(__Field::__field6),
                            7u64 => _serde::export::Ok(__Field::__field7),
                            8u64 => _serde::export::Ok(__Field::__field8),
                            9u64 => _serde::export::Ok(__Field::__field9),
                            _ => _serde::export::Err(_serde::de::Error::invalid_value(
                                _serde::de::Unexpected::Unsigned(__value),
                                &"variant index 0 <= i < 10",
                            )),
                        }
                    }
                    fn visit_str<__E>(
                        self,
                        __value: &str,
                    ) -> _serde::export::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            "KiB" => _serde::export::Ok(__Field::__field0),
                            "MiB" => _serde::export::Ok(__Field::__field1),
                            "GiB" => _serde::export::Ok(__Field::__field2),
                            "TiB" => _serde::export::Ok(__Field::__field3),
                            "PiB" => _serde::export::Ok(__Field::__field4),
                            "KB" => _serde::export::Ok(__Field::__field5),
                            "MB" => _serde::export::Ok(__Field::__field6),
                            "GB" => _serde::export::Ok(__Field::__field7),
                            "TB" => _serde::export::Ok(__Field::__field8),
                            "PB" => _serde::export::Ok(__Field::__field9),
                            _ => _serde::export::Err(_serde::de::Error::unknown_variant(
                                __value, VARIANTS,
                            )),
                        }
                    }
                    fn visit_bytes<__E>(
                        self,
                        __value: &[u8],
                    ) -> _serde::export::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            b"KiB" => _serde::export::Ok(__Field::__field0),
                            b"MiB" => _serde::export::Ok(__Field::__field1),
                            b"GiB" => _serde::export::Ok(__Field::__field2),
                            b"TiB" => _serde::export::Ok(__Field::__field3),
                            b"PiB" => _serde::export::Ok(__Field::__field4),
                            b"KB" => _serde::export::Ok(__Field::__field5),
                            b"MB" => _serde::export::Ok(__Field::__field6),
                            b"GB" => _serde::export::Ok(__Field::__field7),
                            b"TB" => _serde::export::Ok(__Field::__field8),
                            b"PB" => _serde::export::Ok(__Field::__field9),
                            _ => {
                                let __value = &_serde::export::from_utf8_lossy(__value);
                                _serde::export::Err(_serde::de::Error::unknown_variant(
                                    __value, VARIANTS,
                                ))
                            }
                        }
                    }
                }
                impl<'de> _serde::Deserialize<'de> for __Field {
                    #[inline]
                    fn deserialize<__D>(
                        __deserializer: __D,
                    ) -> _serde::export::Result<Self, __D::Error>
                    where
                        __D: _serde::Deserializer<'de>,
                    {
                        _serde::Deserializer::deserialize_identifier(__deserializer, __FieldVisitor)
                    }
                }
                struct __Visitor<'de> {
                    marker: _serde::export::PhantomData<Unit>,
                    lifetime: _serde::export::PhantomData<&'de ()>,
                }
                impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                    type Value = Unit;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::export::Formatter,
                    ) -> _serde::export::fmt::Result {
                        _serde::export::Formatter::write_str(__formatter, "enum Unit")
                    }
                    fn visit_enum<__A>(
                        self,
                        __data: __A,
                    ) -> _serde::export::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::EnumAccess<'de>,
                    {
                        match match _serde::de::EnumAccess::variant(__data) {
                            _serde::export::Ok(__val) => __val,
                            _serde::export::Err(__err) => {
                                return _serde::export::Err(__err);
                            }
                        } {
                            (__Field::__field0, __variant) => {
                                match _serde::de::VariantAccess::unit_variant(__variant) {
                                    _serde::export::Ok(__val) => __val,
                                    _serde::export::Err(__err) => {
                                        return _serde::export::Err(__err);
                                    }
                                };
                                _serde::export::Ok(Unit::KiB)
                            }
                            (__Field::__field1, __variant) => {
                                match _serde::de::VariantAccess::unit_variant(__variant) {
                                    _serde::export::Ok(__val) => __val,
                                    _serde::export::Err(__err) => {
                                        return _serde::export::Err(__err);
                                    }
                                };
                                _serde::export::Ok(Unit::MiB)
                            }
                            (__Field::__field2, __variant) => {
                                match _serde::de::VariantAccess::unit_variant(__variant) {
                                    _serde::export::Ok(__val) => __val,
                                    _serde::export::Err(__err) => {
                                        return _serde::export::Err(__err);
                                    }
                                };
                                _serde::export::Ok(Unit::GiB)
                            }
                            (__Field::__field3, __variant) => {
                                match _serde::de::VariantAccess::unit_variant(__variant) {
                                    _serde::export::Ok(__val) => __val,
                                    _serde::export::Err(__err) => {
                                        return _serde::export::Err(__err);
                                    }
                                };
                                _serde::export::Ok(Unit::TiB)
                            }
                            (__Field::__field4, __variant) => {
                                match _serde::de::VariantAccess::unit_variant(__variant) {
                                    _serde::export::Ok(__val) => __val,
                                    _serde::export::Err(__err) => {
                                        return _serde::export::Err(__err);
                                    }
                                };
                                _serde::export::Ok(Unit::PiB)
                            }
                            (__Field::__field5, __variant) => {
                                match _serde::de::VariantAccess::unit_variant(__variant) {
                                    _serde::export::Ok(__val) => __val,
                                    _serde::export::Err(__err) => {
                                        return _serde::export::Err(__err);
                                    }
                                };
                                _serde::export::Ok(Unit::KB)
                            }
                            (__Field::__field6, __variant) => {
                                match _serde::de::VariantAccess::unit_variant(__variant) {
                                    _serde::export::Ok(__val) => __val,
                                    _serde::export::Err(__err) => {
                                        return _serde::export::Err(__err);
                                    }
                                };
                                _serde::export::Ok(Unit::MB)
                            }
                            (__Field::__field7, __variant) => {
                                match _serde::de::VariantAccess::unit_variant(__variant) {
                                    _serde::export::Ok(__val) => __val,
                                    _serde::export::Err(__err) => {
                                        return _serde::export::Err(__err);
                                    }
                                };
                                _serde::export::Ok(Unit::GB)
                            }
                            (__Field::__field8, __variant) => {
                                match _serde::de::VariantAccess::unit_variant(__variant) {
                                    _serde::export::Ok(__val) => __val,
                                    _serde::export::Err(__err) => {
                                        return _serde::export::Err(__err);
                                    }
                                };
                                _serde::export::Ok(Unit::TB)
                            }
                            (__Field::__field9, __variant) => {
                                match _serde::de::VariantAccess::unit_variant(__variant) {
                                    _serde::export::Ok(__val) => __val,
                                    _serde::export::Err(__err) => {
                                        return _serde::export::Err(__err);
                                    }
                                };
                                _serde::export::Ok(Unit::PB)
                            }
                        }
                    }
                }
                const VARIANTS: &'static [&'static str] = &[
                    "KiB", "MiB", "GiB", "TiB", "PiB", "KB", "MB", "GB", "TB", "PB",
                ];
                _serde::Deserializer::deserialize_enum(
                    __deserializer,
                    "Unit",
                    VARIANTS,
                    __Visitor {
                        marker: _serde::export::PhantomData::<Unit>,
                        lifetime: _serde::export::PhantomData,
                    },
                )
            }
        }
    };
    impl ::core::marker::StructuralPartialEq for Unit {}
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::cmp::PartialEq for Unit {
        #[inline]
        fn eq(&self, other: &Unit) -> bool {
            {
                let __self_vi = unsafe { ::core::intrinsics::discriminant_value(&*self) };
                let __arg_1_vi = unsafe { ::core::intrinsics::discriminant_value(&*other) };
                if true && __self_vi == __arg_1_vi {
                    match (&*self, &*other) {
                        _ => true,
                    }
                } else {
                    false
                }
            }
        }
    }
    impl ::core::marker::StructuralEq for Unit {}
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::cmp::Eq for Unit {
        #[inline]
        #[doc(hidden)]
        fn assert_receiver_is_total_eq(&self) -> () {
            {}
        }
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::cmp::PartialOrd for Unit {
        #[inline]
        fn partial_cmp(&self, other: &Unit) -> ::core::option::Option<::core::cmp::Ordering> {
            {
                let __self_vi = unsafe { ::core::intrinsics::discriminant_value(&*self) };
                let __arg_1_vi = unsafe { ::core::intrinsics::discriminant_value(&*other) };
                if true && __self_vi == __arg_1_vi {
                    match (&*self, &*other) {
                        _ => ::core::option::Option::Some(::core::cmp::Ordering::Equal),
                    }
                } else {
                    __self_vi.partial_cmp(&__arg_1_vi)
                }
            }
        }
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::cmp::Ord for Unit {
        #[inline]
        fn cmp(&self, other: &Unit) -> ::core::cmp::Ordering {
            {
                let __self_vi = unsafe { ::core::intrinsics::discriminant_value(&*self) };
                let __arg_1_vi = unsafe { ::core::intrinsics::discriminant_value(&*other) };
                if true && __self_vi == __arg_1_vi {
                    match (&*self, &*other) {
                        _ => ::core::cmp::Ordering::Equal,
                    }
                } else {
                    __self_vi.cmp(&__arg_1_vi)
                }
            }
        }
    }
    impl FromStr for Unit {
        type Err = UnitErr;
        fn from_str(s: &str) -> Result<Self, Self::Err> {
            Ok(match s {
                "KiB" => Unit::KiB,
                "MiB" => Unit::MiB,
                "GiB" => Unit::GiB,
                "TiB" => Unit::TiB,
                "PiB" => Unit::PiB,
                "KB" => Unit::KB,
                "MB" => Unit::MB,
                "GB" => Unit::GB,
                "TB" => Unit::TB,
                "PB" => Unit::PB,
                _ => return Err(UnitErr::UnknownFormat),
            })
        }
    }
    pub enum UnitErr {
        UnknownFormat,
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::fmt::Debug for UnitErr {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            match (&*self,) {
                (&UnitErr::UnknownFormat,) => {
                    let mut debug_trait_builder = f.debug_tuple("UnknownFormat");
                    debug_trait_builder.finish()
                }
            }
        }
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::clone::Clone for UnitErr {
        #[inline]
        fn clone(&self) -> UnitErr {
            {
                *self
            }
        }
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::marker::Copy for UnitErr {}
    #[doc(hidden)]
    #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
    const _: () = {
        #[allow(rust_2018_idioms, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl _serde::Serialize for UnitErr {
            fn serialize<__S>(
                &self,
                __serializer: __S,
            ) -> _serde::export::Result<__S::Ok, __S::Error>
            where
                __S: _serde::Serializer,
            {
                match *self {
                    UnitErr::UnknownFormat => _serde::Serializer::serialize_unit_variant(
                        __serializer,
                        "UnitErr",
                        0u32,
                        "UnknownFormat",
                    ),
                }
            }
        }
    };
    #[doc(hidden)]
    #[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
    const _: () = {
        #[allow(rust_2018_idioms, clippy::useless_attribute)]
        extern crate serde as _serde;
        #[automatically_derived]
        impl<'de> _serde::Deserialize<'de> for UnitErr {
            fn deserialize<__D>(__deserializer: __D) -> _serde::export::Result<Self, __D::Error>
            where
                __D: _serde::Deserializer<'de>,
            {
                #[allow(non_camel_case_types)]
                enum __Field {
                    __field0,
                }
                struct __FieldVisitor;
                impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                    type Value = __Field;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::export::Formatter,
                    ) -> _serde::export::fmt::Result {
                        _serde::export::Formatter::write_str(__formatter, "variant identifier")
                    }
                    fn visit_u64<__E>(
                        self,
                        __value: u64,
                    ) -> _serde::export::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            0u64 => _serde::export::Ok(__Field::__field0),
                            _ => _serde::export::Err(_serde::de::Error::invalid_value(
                                _serde::de::Unexpected::Unsigned(__value),
                                &"variant index 0 <= i < 1",
                            )),
                        }
                    }
                    fn visit_str<__E>(
                        self,
                        __value: &str,
                    ) -> _serde::export::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            "UnknownFormat" => _serde::export::Ok(__Field::__field0),
                            _ => _serde::export::Err(_serde::de::Error::unknown_variant(
                                __value, VARIANTS,
                            )),
                        }
                    }
                    fn visit_bytes<__E>(
                        self,
                        __value: &[u8],
                    ) -> _serde::export::Result<Self::Value, __E>
                    where
                        __E: _serde::de::Error,
                    {
                        match __value {
                            b"UnknownFormat" => _serde::export::Ok(__Field::__field0),
                            _ => {
                                let __value = &_serde::export::from_utf8_lossy(__value);
                                _serde::export::Err(_serde::de::Error::unknown_variant(
                                    __value, VARIANTS,
                                ))
                            }
                        }
                    }
                }
                impl<'de> _serde::Deserialize<'de> for __Field {
                    #[inline]
                    fn deserialize<__D>(
                        __deserializer: __D,
                    ) -> _serde::export::Result<Self, __D::Error>
                    where
                        __D: _serde::Deserializer<'de>,
                    {
                        _serde::Deserializer::deserialize_identifier(__deserializer, __FieldVisitor)
                    }
                }
                struct __Visitor<'de> {
                    marker: _serde::export::PhantomData<UnitErr>,
                    lifetime: _serde::export::PhantomData<&'de ()>,
                }
                impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                    type Value = UnitErr;
                    fn expecting(
                        &self,
                        __formatter: &mut _serde::export::Formatter,
                    ) -> _serde::export::fmt::Result {
                        _serde::export::Formatter::write_str(__formatter, "enum UnitErr")
                    }
                    fn visit_enum<__A>(
                        self,
                        __data: __A,
                    ) -> _serde::export::Result<Self::Value, __A::Error>
                    where
                        __A: _serde::de::EnumAccess<'de>,
                    {
                        match match _serde::de::EnumAccess::variant(__data) {
                            _serde::export::Ok(__val) => __val,
                            _serde::export::Err(__err) => {
                                return _serde::export::Err(__err);
                            }
                        } {
                            (__Field::__field0, __variant) => {
                                match _serde::de::VariantAccess::unit_variant(__variant) {
                                    _serde::export::Ok(__val) => __val,
                                    _serde::export::Err(__err) => {
                                        return _serde::export::Err(__err);
                                    }
                                };
                                _serde::export::Ok(UnitErr::UnknownFormat)
                            }
                        }
                    }
                }
                const VARIANTS: &'static [&'static str] = &["UnknownFormat"];
                _serde::Deserializer::deserialize_enum(
                    __deserializer,
                    "UnitErr",
                    VARIANTS,
                    __Visitor {
                        marker: _serde::export::PhantomData::<UnitErr>,
                        lifetime: _serde::export::PhantomData,
                    },
                )
            }
        }
    };
    impl ::core::marker::StructuralPartialEq for UnitErr {}
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::cmp::PartialEq for UnitErr {
        #[inline]
        fn eq(&self, other: &UnitErr) -> bool {
            match (&*self, &*other) {
                _ => true,
            }
        }
    }
    impl ::core::marker::StructuralEq for UnitErr {}
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::cmp::Eq for UnitErr {
        #[inline]
        #[doc(hidden)]
        fn assert_receiver_is_total_eq(&self) -> () {
            {}
        }
    }
    impl ::core::fmt::Display for UnitErr {
        #[allow(unused_variables)]
        #[inline]
        fn fmt(
            &self,
            _derive_more_display_formatter: &mut ::core::fmt::Formatter,
        ) -> ::core::fmt::Result {
            match self {
                UnitErr::UnknownFormat => _derive_more_display_formatter.write_str("UnknownFormat"),
                _ => Ok(()),
            }
        }
    }
    impl Error for UnitErr {}
}
use networking::{
    asyncronous::AsyncStream, syncronous::SyncStream, ArtificeConfig, ArtificePeer, LongHash,
    NetworkError, NetworkHash,
};
use std::collections::HashMap;
/// the first two environemnts that will be implemented are MeSHE using Paillier, and Trusted, or execution directly on the host
pub enum EnvType {
    Inherit,
    Paillier,
    Other(String),
}
#[automatically_derived]
#[allow(unused_qualifications)]
impl ::core::fmt::Debug for EnvType {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        match (&*self,) {
            (&EnvType::Inherit,) => {
                let mut debug_trait_builder = f.debug_tuple("Inherit");
                debug_trait_builder.finish()
            }
            (&EnvType::Paillier,) => {
                let mut debug_trait_builder = f.debug_tuple("Paillier");
                debug_trait_builder.finish()
            }
            (&EnvType::Other(ref __self_0),) => {
                let mut debug_trait_builder = f.debug_tuple("Other");
                let _ = debug_trait_builder.field(&&(*__self_0));
                debug_trait_builder.finish()
            }
        }
    }
}
#[automatically_derived]
#[allow(unused_qualifications)]
impl ::core::clone::Clone for EnvType {
    #[inline]
    fn clone(&self) -> EnvType {
        match (&*self,) {
            (&EnvType::Inherit,) => EnvType::Inherit,
            (&EnvType::Paillier,) => EnvType::Paillier,
            (&EnvType::Other(ref __self_0),) => {
                EnvType::Other(::core::clone::Clone::clone(&(*__self_0)))
            }
        }
    }
}
impl ::core::marker::StructuralPartialEq for EnvType {}
#[automatically_derived]
#[allow(unused_qualifications)]
impl ::core::cmp::PartialEq for EnvType {
    #[inline]
    fn eq(&self, other: &EnvType) -> bool {
        {
            let __self_vi = unsafe { ::core::intrinsics::discriminant_value(&*self) };
            let __arg_1_vi = unsafe { ::core::intrinsics::discriminant_value(&*other) };
            if true && __self_vi == __arg_1_vi {
                match (&*self, &*other) {
                    (&EnvType::Other(ref __self_0), &EnvType::Other(ref __arg_1_0)) => {
                        (*__self_0) == (*__arg_1_0)
                    }
                    _ => true,
                }
            } else {
                false
            }
        }
    }
    #[inline]
    fn ne(&self, other: &EnvType) -> bool {
        {
            let __self_vi = unsafe { ::core::intrinsics::discriminant_value(&*self) };
            let __arg_1_vi = unsafe { ::core::intrinsics::discriminant_value(&*other) };
            if true && __self_vi == __arg_1_vi {
                match (&*self, &*other) {
                    (&EnvType::Other(ref __self_0), &EnvType::Other(ref __arg_1_0)) => {
                        (*__self_0) != (*__arg_1_0)
                    }
                    _ => false,
                }
            } else {
                true
            }
        }
    }
}
impl ::core::marker::StructuralEq for EnvType {}
#[automatically_derived]
#[allow(unused_qualifications)]
impl ::core::cmp::Eq for EnvType {
    #[inline]
    #[doc(hidden)]
    fn assert_receiver_is_total_eq(&self) -> () {
        {
            let _: ::core::cmp::AssertParamIsEq<String>;
        }
    }
}
#[doc(hidden)]
#[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
const _: () = {
    #[allow(rust_2018_idioms, clippy::useless_attribute)]
    extern crate serde as _serde;
    #[automatically_derived]
    impl _serde::Serialize for EnvType {
        fn serialize<__S>(&self, __serializer: __S) -> _serde::export::Result<__S::Ok, __S::Error>
        where
            __S: _serde::Serializer,
        {
            match *self {
                EnvType::Inherit => _serde::Serializer::serialize_unit_variant(
                    __serializer,
                    "EnvType",
                    0u32,
                    "Inherit",
                ),
                EnvType::Paillier => _serde::Serializer::serialize_unit_variant(
                    __serializer,
                    "EnvType",
                    1u32,
                    "Paillier",
                ),
                EnvType::Other(ref __field0) => _serde::Serializer::serialize_newtype_variant(
                    __serializer,
                    "EnvType",
                    2u32,
                    "Other",
                    __field0,
                ),
            }
        }
    }
};
#[doc(hidden)]
#[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
const _: () = {
    #[allow(rust_2018_idioms, clippy::useless_attribute)]
    extern crate serde as _serde;
    #[automatically_derived]
    impl<'de> _serde::Deserialize<'de> for EnvType {
        fn deserialize<__D>(__deserializer: __D) -> _serde::export::Result<Self, __D::Error>
        where
            __D: _serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            enum __Field {
                __field0,
                __field1,
                __field2,
            }
            struct __FieldVisitor;
            impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                type Value = __Field;
                fn expecting(
                    &self,
                    __formatter: &mut _serde::export::Formatter,
                ) -> _serde::export::fmt::Result {
                    _serde::export::Formatter::write_str(__formatter, "variant identifier")
                }
                fn visit_u64<__E>(self, __value: u64) -> _serde::export::Result<Self::Value, __E>
                where
                    __E: _serde::de::Error,
                {
                    match __value {
                        0u64 => _serde::export::Ok(__Field::__field0),
                        1u64 => _serde::export::Ok(__Field::__field1),
                        2u64 => _serde::export::Ok(__Field::__field2),
                        _ => _serde::export::Err(_serde::de::Error::invalid_value(
                            _serde::de::Unexpected::Unsigned(__value),
                            &"variant index 0 <= i < 3",
                        )),
                    }
                }
                fn visit_str<__E>(self, __value: &str) -> _serde::export::Result<Self::Value, __E>
                where
                    __E: _serde::de::Error,
                {
                    match __value {
                        "Inherit" => _serde::export::Ok(__Field::__field0),
                        "Paillier" => _serde::export::Ok(__Field::__field1),
                        "Other" => _serde::export::Ok(__Field::__field2),
                        _ => _serde::export::Err(_serde::de::Error::unknown_variant(
                            __value, VARIANTS,
                        )),
                    }
                }
                fn visit_bytes<__E>(
                    self,
                    __value: &[u8],
                ) -> _serde::export::Result<Self::Value, __E>
                where
                    __E: _serde::de::Error,
                {
                    match __value {
                        b"Inherit" => _serde::export::Ok(__Field::__field0),
                        b"Paillier" => _serde::export::Ok(__Field::__field1),
                        b"Other" => _serde::export::Ok(__Field::__field2),
                        _ => {
                            let __value = &_serde::export::from_utf8_lossy(__value);
                            _serde::export::Err(_serde::de::Error::unknown_variant(
                                __value, VARIANTS,
                            ))
                        }
                    }
                }
            }
            impl<'de> _serde::Deserialize<'de> for __Field {
                #[inline]
                fn deserialize<__D>(__deserializer: __D) -> _serde::export::Result<Self, __D::Error>
                where
                    __D: _serde::Deserializer<'de>,
                {
                    _serde::Deserializer::deserialize_identifier(__deserializer, __FieldVisitor)
                }
            }
            struct __Visitor<'de> {
                marker: _serde::export::PhantomData<EnvType>,
                lifetime: _serde::export::PhantomData<&'de ()>,
            }
            impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                type Value = EnvType;
                fn expecting(
                    &self,
                    __formatter: &mut _serde::export::Formatter,
                ) -> _serde::export::fmt::Result {
                    _serde::export::Formatter::write_str(__formatter, "enum EnvType")
                }
                fn visit_enum<__A>(
                    self,
                    __data: __A,
                ) -> _serde::export::Result<Self::Value, __A::Error>
                where
                    __A: _serde::de::EnumAccess<'de>,
                {
                    match match _serde::de::EnumAccess::variant(__data) {
                        _serde::export::Ok(__val) => __val,
                        _serde::export::Err(__err) => {
                            return _serde::export::Err(__err);
                        }
                    } {
                        (__Field::__field0, __variant) => {
                            match _serde::de::VariantAccess::unit_variant(__variant) {
                                _serde::export::Ok(__val) => __val,
                                _serde::export::Err(__err) => {
                                    return _serde::export::Err(__err);
                                }
                            };
                            _serde::export::Ok(EnvType::Inherit)
                        }
                        (__Field::__field1, __variant) => {
                            match _serde::de::VariantAccess::unit_variant(__variant) {
                                _serde::export::Ok(__val) => __val,
                                _serde::export::Err(__err) => {
                                    return _serde::export::Err(__err);
                                }
                            };
                            _serde::export::Ok(EnvType::Paillier)
                        }
                        (__Field::__field2, __variant) => _serde::export::Result::map(
                            _serde::de::VariantAccess::newtype_variant::<String>(__variant),
                            EnvType::Other,
                        ),
                    }
                }
            }
            const VARIANTS: &'static [&'static str] = &["Inherit", "Paillier", "Other"];
            _serde::Deserializer::deserialize_enum(
                __deserializer,
                "EnvType",
                VARIANTS,
                __Visitor {
                    marker: _serde::export::PhantomData::<EnvType>,
                    lifetime: _serde::export::PhantomData,
                },
            )
        }
    }
};
/// data on execution environments including cpu, memory, type, architecture, system, and trust
pub trait EnvData {
    /// assume untrusted because the purpose of this project is to create artificially trusted
    /// systems, rather then knowing they are trusted by their identity
    fn trusted(&self) -> bool {
        false
    }
    fn env_type(&self) -> &EnvType {
        &EnvType::Inherit
    }
    /// the following methods don't have a default implementation
    /// because any default would be based on the local system, not the remote system
    fn os_name(&self) -> &str;
    fn arch_name(&self) -> &str;
    fn total_mem(&self) -> u64;
    fn cpu_count(&self) -> u16;
    fn cpu_speed(&self) -> u16;
}
/// struct that implements EnvData, and can be used to store info on remote hosts
pub struct RemoteEnv {
    os_name: String,
    arch_name: String,
    total_mem: u64,
    cpu_count: u16,
    cpu_speed: u16,
    env_type: EnvType,
    trusted: bool,
}
#[automatically_derived]
#[allow(unused_qualifications)]
impl ::core::fmt::Debug for RemoteEnv {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        match *self {
            RemoteEnv {
                os_name: ref __self_0_0,
                arch_name: ref __self_0_1,
                total_mem: ref __self_0_2,
                cpu_count: ref __self_0_3,
                cpu_speed: ref __self_0_4,
                env_type: ref __self_0_5,
                trusted: ref __self_0_6,
            } => {
                let mut debug_trait_builder = f.debug_struct("RemoteEnv");
                let _ = debug_trait_builder.field("os_name", &&(*__self_0_0));
                let _ = debug_trait_builder.field("arch_name", &&(*__self_0_1));
                let _ = debug_trait_builder.field("total_mem", &&(*__self_0_2));
                let _ = debug_trait_builder.field("cpu_count", &&(*__self_0_3));
                let _ = debug_trait_builder.field("cpu_speed", &&(*__self_0_4));
                let _ = debug_trait_builder.field("env_type", &&(*__self_0_5));
                let _ = debug_trait_builder.field("trusted", &&(*__self_0_6));
                debug_trait_builder.finish()
            }
        }
    }
}
#[automatically_derived]
#[allow(unused_qualifications)]
impl ::core::clone::Clone for RemoteEnv {
    #[inline]
    fn clone(&self) -> RemoteEnv {
        match *self {
            RemoteEnv {
                os_name: ref __self_0_0,
                arch_name: ref __self_0_1,
                total_mem: ref __self_0_2,
                cpu_count: ref __self_0_3,
                cpu_speed: ref __self_0_4,
                env_type: ref __self_0_5,
                trusted: ref __self_0_6,
            } => RemoteEnv {
                os_name: ::core::clone::Clone::clone(&(*__self_0_0)),
                arch_name: ::core::clone::Clone::clone(&(*__self_0_1)),
                total_mem: ::core::clone::Clone::clone(&(*__self_0_2)),
                cpu_count: ::core::clone::Clone::clone(&(*__self_0_3)),
                cpu_speed: ::core::clone::Clone::clone(&(*__self_0_4)),
                env_type: ::core::clone::Clone::clone(&(*__self_0_5)),
                trusted: ::core::clone::Clone::clone(&(*__self_0_6)),
            },
        }
    }
}
impl ::core::marker::StructuralPartialEq for RemoteEnv {}
#[automatically_derived]
#[allow(unused_qualifications)]
impl ::core::cmp::PartialEq for RemoteEnv {
    #[inline]
    fn eq(&self, other: &RemoteEnv) -> bool {
        match *other {
            RemoteEnv {
                os_name: ref __self_1_0,
                arch_name: ref __self_1_1,
                total_mem: ref __self_1_2,
                cpu_count: ref __self_1_3,
                cpu_speed: ref __self_1_4,
                env_type: ref __self_1_5,
                trusted: ref __self_1_6,
            } => match *self {
                RemoteEnv {
                    os_name: ref __self_0_0,
                    arch_name: ref __self_0_1,
                    total_mem: ref __self_0_2,
                    cpu_count: ref __self_0_3,
                    cpu_speed: ref __self_0_4,
                    env_type: ref __self_0_5,
                    trusted: ref __self_0_6,
                } => {
                    (*__self_0_0) == (*__self_1_0)
                        && (*__self_0_1) == (*__self_1_1)
                        && (*__self_0_2) == (*__self_1_2)
                        && (*__self_0_3) == (*__self_1_3)
                        && (*__self_0_4) == (*__self_1_4)
                        && (*__self_0_5) == (*__self_1_5)
                        && (*__self_0_6) == (*__self_1_6)
                }
            },
        }
    }
    #[inline]
    fn ne(&self, other: &RemoteEnv) -> bool {
        match *other {
            RemoteEnv {
                os_name: ref __self_1_0,
                arch_name: ref __self_1_1,
                total_mem: ref __self_1_2,
                cpu_count: ref __self_1_3,
                cpu_speed: ref __self_1_4,
                env_type: ref __self_1_5,
                trusted: ref __self_1_6,
            } => match *self {
                RemoteEnv {
                    os_name: ref __self_0_0,
                    arch_name: ref __self_0_1,
                    total_mem: ref __self_0_2,
                    cpu_count: ref __self_0_3,
                    cpu_speed: ref __self_0_4,
                    env_type: ref __self_0_5,
                    trusted: ref __self_0_6,
                } => {
                    (*__self_0_0) != (*__self_1_0)
                        || (*__self_0_1) != (*__self_1_1)
                        || (*__self_0_2) != (*__self_1_2)
                        || (*__self_0_3) != (*__self_1_3)
                        || (*__self_0_4) != (*__self_1_4)
                        || (*__self_0_5) != (*__self_1_5)
                        || (*__self_0_6) != (*__self_1_6)
                }
            },
        }
    }
}
impl ::core::marker::StructuralEq for RemoteEnv {}
#[automatically_derived]
#[allow(unused_qualifications)]
impl ::core::cmp::Eq for RemoteEnv {
    #[inline]
    #[doc(hidden)]
    fn assert_receiver_is_total_eq(&self) -> () {
        {
            let _: ::core::cmp::AssertParamIsEq<String>;
            let _: ::core::cmp::AssertParamIsEq<String>;
            let _: ::core::cmp::AssertParamIsEq<u64>;
            let _: ::core::cmp::AssertParamIsEq<u16>;
            let _: ::core::cmp::AssertParamIsEq<u16>;
            let _: ::core::cmp::AssertParamIsEq<EnvType>;
            let _: ::core::cmp::AssertParamIsEq<bool>;
        }
    }
}
#[doc(hidden)]
#[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
const _: () = {
    #[allow(rust_2018_idioms, clippy::useless_attribute)]
    extern crate serde as _serde;
    #[automatically_derived]
    impl _serde::Serialize for RemoteEnv {
        fn serialize<__S>(&self, __serializer: __S) -> _serde::export::Result<__S::Ok, __S::Error>
        where
            __S: _serde::Serializer,
        {
            let mut __serde_state = match _serde::Serializer::serialize_struct(
                __serializer,
                "RemoteEnv",
                false as usize + 1 + 1 + 1 + 1 + 1 + 1 + 1,
            ) {
                _serde::export::Ok(__val) => __val,
                _serde::export::Err(__err) => {
                    return _serde::export::Err(__err);
                }
            };
            match _serde::ser::SerializeStruct::serialize_field(
                &mut __serde_state,
                "os_name",
                &self.os_name,
            ) {
                _serde::export::Ok(__val) => __val,
                _serde::export::Err(__err) => {
                    return _serde::export::Err(__err);
                }
            };
            match _serde::ser::SerializeStruct::serialize_field(
                &mut __serde_state,
                "arch_name",
                &self.arch_name,
            ) {
                _serde::export::Ok(__val) => __val,
                _serde::export::Err(__err) => {
                    return _serde::export::Err(__err);
                }
            };
            match _serde::ser::SerializeStruct::serialize_field(
                &mut __serde_state,
                "total_mem",
                &self.total_mem,
            ) {
                _serde::export::Ok(__val) => __val,
                _serde::export::Err(__err) => {
                    return _serde::export::Err(__err);
                }
            };
            match _serde::ser::SerializeStruct::serialize_field(
                &mut __serde_state,
                "cpu_count",
                &self.cpu_count,
            ) {
                _serde::export::Ok(__val) => __val,
                _serde::export::Err(__err) => {
                    return _serde::export::Err(__err);
                }
            };
            match _serde::ser::SerializeStruct::serialize_field(
                &mut __serde_state,
                "cpu_speed",
                &self.cpu_speed,
            ) {
                _serde::export::Ok(__val) => __val,
                _serde::export::Err(__err) => {
                    return _serde::export::Err(__err);
                }
            };
            match _serde::ser::SerializeStruct::serialize_field(
                &mut __serde_state,
                "env_type",
                &self.env_type,
            ) {
                _serde::export::Ok(__val) => __val,
                _serde::export::Err(__err) => {
                    return _serde::export::Err(__err);
                }
            };
            match _serde::ser::SerializeStruct::serialize_field(
                &mut __serde_state,
                "trusted",
                &self.trusted,
            ) {
                _serde::export::Ok(__val) => __val,
                _serde::export::Err(__err) => {
                    return _serde::export::Err(__err);
                }
            };
            _serde::ser::SerializeStruct::end(__serde_state)
        }
    }
};
#[doc(hidden)]
#[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
const _: () = {
    #[allow(rust_2018_idioms, clippy::useless_attribute)]
    extern crate serde as _serde;
    #[automatically_derived]
    impl<'de> _serde::Deserialize<'de> for RemoteEnv {
        fn deserialize<__D>(__deserializer: __D) -> _serde::export::Result<Self, __D::Error>
        where
            __D: _serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            enum __Field {
                __field0,
                __field1,
                __field2,
                __field3,
                __field4,
                __field5,
                __field6,
                __ignore,
            }
            struct __FieldVisitor;
            impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                type Value = __Field;
                fn expecting(
                    &self,
                    __formatter: &mut _serde::export::Formatter,
                ) -> _serde::export::fmt::Result {
                    _serde::export::Formatter::write_str(__formatter, "field identifier")
                }
                fn visit_u64<__E>(self, __value: u64) -> _serde::export::Result<Self::Value, __E>
                where
                    __E: _serde::de::Error,
                {
                    match __value {
                        0u64 => _serde::export::Ok(__Field::__field0),
                        1u64 => _serde::export::Ok(__Field::__field1),
                        2u64 => _serde::export::Ok(__Field::__field2),
                        3u64 => _serde::export::Ok(__Field::__field3),
                        4u64 => _serde::export::Ok(__Field::__field4),
                        5u64 => _serde::export::Ok(__Field::__field5),
                        6u64 => _serde::export::Ok(__Field::__field6),
                        _ => _serde::export::Err(_serde::de::Error::invalid_value(
                            _serde::de::Unexpected::Unsigned(__value),
                            &"field index 0 <= i < 7",
                        )),
                    }
                }
                fn visit_str<__E>(self, __value: &str) -> _serde::export::Result<Self::Value, __E>
                where
                    __E: _serde::de::Error,
                {
                    match __value {
                        "os_name" => _serde::export::Ok(__Field::__field0),
                        "arch_name" => _serde::export::Ok(__Field::__field1),
                        "total_mem" => _serde::export::Ok(__Field::__field2),
                        "cpu_count" => _serde::export::Ok(__Field::__field3),
                        "cpu_speed" => _serde::export::Ok(__Field::__field4),
                        "env_type" => _serde::export::Ok(__Field::__field5),
                        "trusted" => _serde::export::Ok(__Field::__field6),
                        _ => _serde::export::Ok(__Field::__ignore),
                    }
                }
                fn visit_bytes<__E>(
                    self,
                    __value: &[u8],
                ) -> _serde::export::Result<Self::Value, __E>
                where
                    __E: _serde::de::Error,
                {
                    match __value {
                        b"os_name" => _serde::export::Ok(__Field::__field0),
                        b"arch_name" => _serde::export::Ok(__Field::__field1),
                        b"total_mem" => _serde::export::Ok(__Field::__field2),
                        b"cpu_count" => _serde::export::Ok(__Field::__field3),
                        b"cpu_speed" => _serde::export::Ok(__Field::__field4),
                        b"env_type" => _serde::export::Ok(__Field::__field5),
                        b"trusted" => _serde::export::Ok(__Field::__field6),
                        _ => _serde::export::Ok(__Field::__ignore),
                    }
                }
            }
            impl<'de> _serde::Deserialize<'de> for __Field {
                #[inline]
                fn deserialize<__D>(__deserializer: __D) -> _serde::export::Result<Self, __D::Error>
                where
                    __D: _serde::Deserializer<'de>,
                {
                    _serde::Deserializer::deserialize_identifier(__deserializer, __FieldVisitor)
                }
            }
            struct __Visitor<'de> {
                marker: _serde::export::PhantomData<RemoteEnv>,
                lifetime: _serde::export::PhantomData<&'de ()>,
            }
            impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                type Value = RemoteEnv;
                fn expecting(
                    &self,
                    __formatter: &mut _serde::export::Formatter,
                ) -> _serde::export::fmt::Result {
                    _serde::export::Formatter::write_str(__formatter, "struct RemoteEnv")
                }
                #[inline]
                fn visit_seq<__A>(
                    self,
                    mut __seq: __A,
                ) -> _serde::export::Result<Self::Value, __A::Error>
                where
                    __A: _serde::de::SeqAccess<'de>,
                {
                    let __field0 =
                        match match _serde::de::SeqAccess::next_element::<String>(&mut __seq) {
                            _serde::export::Ok(__val) => __val,
                            _serde::export::Err(__err) => {
                                return _serde::export::Err(__err);
                            }
                        } {
                            _serde::export::Some(__value) => __value,
                            _serde::export::None => {
                                return _serde::export::Err(_serde::de::Error::invalid_length(
                                    0usize,
                                    &"struct RemoteEnv with 7 elements",
                                ));
                            }
                        };
                    let __field1 =
                        match match _serde::de::SeqAccess::next_element::<String>(&mut __seq) {
                            _serde::export::Ok(__val) => __val,
                            _serde::export::Err(__err) => {
                                return _serde::export::Err(__err);
                            }
                        } {
                            _serde::export::Some(__value) => __value,
                            _serde::export::None => {
                                return _serde::export::Err(_serde::de::Error::invalid_length(
                                    1usize,
                                    &"struct RemoteEnv with 7 elements",
                                ));
                            }
                        };
                    let __field2 =
                        match match _serde::de::SeqAccess::next_element::<u64>(&mut __seq) {
                            _serde::export::Ok(__val) => __val,
                            _serde::export::Err(__err) => {
                                return _serde::export::Err(__err);
                            }
                        } {
                            _serde::export::Some(__value) => __value,
                            _serde::export::None => {
                                return _serde::export::Err(_serde::de::Error::invalid_length(
                                    2usize,
                                    &"struct RemoteEnv with 7 elements",
                                ));
                            }
                        };
                    let __field3 =
                        match match _serde::de::SeqAccess::next_element::<u16>(&mut __seq) {
                            _serde::export::Ok(__val) => __val,
                            _serde::export::Err(__err) => {
                                return _serde::export::Err(__err);
                            }
                        } {
                            _serde::export::Some(__value) => __value,
                            _serde::export::None => {
                                return _serde::export::Err(_serde::de::Error::invalid_length(
                                    3usize,
                                    &"struct RemoteEnv with 7 elements",
                                ));
                            }
                        };
                    let __field4 =
                        match match _serde::de::SeqAccess::next_element::<u16>(&mut __seq) {
                            _serde::export::Ok(__val) => __val,
                            _serde::export::Err(__err) => {
                                return _serde::export::Err(__err);
                            }
                        } {
                            _serde::export::Some(__value) => __value,
                            _serde::export::None => {
                                return _serde::export::Err(_serde::de::Error::invalid_length(
                                    4usize,
                                    &"struct RemoteEnv with 7 elements",
                                ));
                            }
                        };
                    let __field5 =
                        match match _serde::de::SeqAccess::next_element::<EnvType>(&mut __seq) {
                            _serde::export::Ok(__val) => __val,
                            _serde::export::Err(__err) => {
                                return _serde::export::Err(__err);
                            }
                        } {
                            _serde::export::Some(__value) => __value,
                            _serde::export::None => {
                                return _serde::export::Err(_serde::de::Error::invalid_length(
                                    5usize,
                                    &"struct RemoteEnv with 7 elements",
                                ));
                            }
                        };
                    let __field6 =
                        match match _serde::de::SeqAccess::next_element::<bool>(&mut __seq) {
                            _serde::export::Ok(__val) => __val,
                            _serde::export::Err(__err) => {
                                return _serde::export::Err(__err);
                            }
                        } {
                            _serde::export::Some(__value) => __value,
                            _serde::export::None => {
                                return _serde::export::Err(_serde::de::Error::invalid_length(
                                    6usize,
                                    &"struct RemoteEnv with 7 elements",
                                ));
                            }
                        };
                    _serde::export::Ok(RemoteEnv {
                        os_name: __field0,
                        arch_name: __field1,
                        total_mem: __field2,
                        cpu_count: __field3,
                        cpu_speed: __field4,
                        env_type: __field5,
                        trusted: __field6,
                    })
                }
                #[inline]
                fn visit_map<__A>(
                    self,
                    mut __map: __A,
                ) -> _serde::export::Result<Self::Value, __A::Error>
                where
                    __A: _serde::de::MapAccess<'de>,
                {
                    let mut __field0: _serde::export::Option<String> = _serde::export::None;
                    let mut __field1: _serde::export::Option<String> = _serde::export::None;
                    let mut __field2: _serde::export::Option<u64> = _serde::export::None;
                    let mut __field3: _serde::export::Option<u16> = _serde::export::None;
                    let mut __field4: _serde::export::Option<u16> = _serde::export::None;
                    let mut __field5: _serde::export::Option<EnvType> = _serde::export::None;
                    let mut __field6: _serde::export::Option<bool> = _serde::export::None;
                    while let _serde::export::Some(__key) =
                        match _serde::de::MapAccess::next_key::<__Field>(&mut __map) {
                            _serde::export::Ok(__val) => __val,
                            _serde::export::Err(__err) => {
                                return _serde::export::Err(__err);
                            }
                        }
                    {
                        match __key {
                            __Field::__field0 => {
                                if _serde::export::Option::is_some(&__field0) {
                                    return _serde::export::Err(
                                        <__A::Error as _serde::de::Error>::duplicate_field(
                                            "os_name",
                                        ),
                                    );
                                }
                                __field0 = _serde::export::Some(
                                    match _serde::de::MapAccess::next_value::<String>(&mut __map) {
                                        _serde::export::Ok(__val) => __val,
                                        _serde::export::Err(__err) => {
                                            return _serde::export::Err(__err);
                                        }
                                    },
                                );
                            }
                            __Field::__field1 => {
                                if _serde::export::Option::is_some(&__field1) {
                                    return _serde::export::Err(
                                        <__A::Error as _serde::de::Error>::duplicate_field(
                                            "arch_name",
                                        ),
                                    );
                                }
                                __field1 = _serde::export::Some(
                                    match _serde::de::MapAccess::next_value::<String>(&mut __map) {
                                        _serde::export::Ok(__val) => __val,
                                        _serde::export::Err(__err) => {
                                            return _serde::export::Err(__err);
                                        }
                                    },
                                );
                            }
                            __Field::__field2 => {
                                if _serde::export::Option::is_some(&__field2) {
                                    return _serde::export::Err(
                                        <__A::Error as _serde::de::Error>::duplicate_field(
                                            "total_mem",
                                        ),
                                    );
                                }
                                __field2 = _serde::export::Some(
                                    match _serde::de::MapAccess::next_value::<u64>(&mut __map) {
                                        _serde::export::Ok(__val) => __val,
                                        _serde::export::Err(__err) => {
                                            return _serde::export::Err(__err);
                                        }
                                    },
                                );
                            }
                            __Field::__field3 => {
                                if _serde::export::Option::is_some(&__field3) {
                                    return _serde::export::Err(
                                        <__A::Error as _serde::de::Error>::duplicate_field(
                                            "cpu_count",
                                        ),
                                    );
                                }
                                __field3 = _serde::export::Some(
                                    match _serde::de::MapAccess::next_value::<u16>(&mut __map) {
                                        _serde::export::Ok(__val) => __val,
                                        _serde::export::Err(__err) => {
                                            return _serde::export::Err(__err);
                                        }
                                    },
                                );
                            }
                            __Field::__field4 => {
                                if _serde::export::Option::is_some(&__field4) {
                                    return _serde::export::Err(
                                        <__A::Error as _serde::de::Error>::duplicate_field(
                                            "cpu_speed",
                                        ),
                                    );
                                }
                                __field4 = _serde::export::Some(
                                    match _serde::de::MapAccess::next_value::<u16>(&mut __map) {
                                        _serde::export::Ok(__val) => __val,
                                        _serde::export::Err(__err) => {
                                            return _serde::export::Err(__err);
                                        }
                                    },
                                );
                            }
                            __Field::__field5 => {
                                if _serde::export::Option::is_some(&__field5) {
                                    return _serde::export::Err(
                                        <__A::Error as _serde::de::Error>::duplicate_field(
                                            "env_type",
                                        ),
                                    );
                                }
                                __field5 = _serde::export::Some(
                                    match _serde::de::MapAccess::next_value::<EnvType>(&mut __map) {
                                        _serde::export::Ok(__val) => __val,
                                        _serde::export::Err(__err) => {
                                            return _serde::export::Err(__err);
                                        }
                                    },
                                );
                            }
                            __Field::__field6 => {
                                if _serde::export::Option::is_some(&__field6) {
                                    return _serde::export::Err(
                                        <__A::Error as _serde::de::Error>::duplicate_field(
                                            "trusted",
                                        ),
                                    );
                                }
                                __field6 = _serde::export::Some(
                                    match _serde::de::MapAccess::next_value::<bool>(&mut __map) {
                                        _serde::export::Ok(__val) => __val,
                                        _serde::export::Err(__err) => {
                                            return _serde::export::Err(__err);
                                        }
                                    },
                                );
                            }
                            _ => {
                                let _ = match _serde::de::MapAccess::next_value::<
                                    _serde::de::IgnoredAny,
                                >(&mut __map)
                                {
                                    _serde::export::Ok(__val) => __val,
                                    _serde::export::Err(__err) => {
                                        return _serde::export::Err(__err);
                                    }
                                };
                            }
                        }
                    }
                    let __field0 = match __field0 {
                        _serde::export::Some(__field0) => __field0,
                        _serde::export::None => match _serde::private::de::missing_field("os_name")
                        {
                            _serde::export::Ok(__val) => __val,
                            _serde::export::Err(__err) => {
                                return _serde::export::Err(__err);
                            }
                        },
                    };
                    let __field1 = match __field1 {
                        _serde::export::Some(__field1) => __field1,
                        _serde::export::None => {
                            match _serde::private::de::missing_field("arch_name") {
                                _serde::export::Ok(__val) => __val,
                                _serde::export::Err(__err) => {
                                    return _serde::export::Err(__err);
                                }
                            }
                        }
                    };
                    let __field2 = match __field2 {
                        _serde::export::Some(__field2) => __field2,
                        _serde::export::None => {
                            match _serde::private::de::missing_field("total_mem") {
                                _serde::export::Ok(__val) => __val,
                                _serde::export::Err(__err) => {
                                    return _serde::export::Err(__err);
                                }
                            }
                        }
                    };
                    let __field3 = match __field3 {
                        _serde::export::Some(__field3) => __field3,
                        _serde::export::None => {
                            match _serde::private::de::missing_field("cpu_count") {
                                _serde::export::Ok(__val) => __val,
                                _serde::export::Err(__err) => {
                                    return _serde::export::Err(__err);
                                }
                            }
                        }
                    };
                    let __field4 = match __field4 {
                        _serde::export::Some(__field4) => __field4,
                        _serde::export::None => {
                            match _serde::private::de::missing_field("cpu_speed") {
                                _serde::export::Ok(__val) => __val,
                                _serde::export::Err(__err) => {
                                    return _serde::export::Err(__err);
                                }
                            }
                        }
                    };
                    let __field5 = match __field5 {
                        _serde::export::Some(__field5) => __field5,
                        _serde::export::None => {
                            match _serde::private::de::missing_field("env_type") {
                                _serde::export::Ok(__val) => __val,
                                _serde::export::Err(__err) => {
                                    return _serde::export::Err(__err);
                                }
                            }
                        }
                    };
                    let __field6 = match __field6 {
                        _serde::export::Some(__field6) => __field6,
                        _serde::export::None => match _serde::private::de::missing_field("trusted")
                        {
                            _serde::export::Ok(__val) => __val,
                            _serde::export::Err(__err) => {
                                return _serde::export::Err(__err);
                            }
                        },
                    };
                    _serde::export::Ok(RemoteEnv {
                        os_name: __field0,
                        arch_name: __field1,
                        total_mem: __field2,
                        cpu_count: __field3,
                        cpu_speed: __field4,
                        env_type: __field5,
                        trusted: __field6,
                    })
                }
            }
            const FIELDS: &'static [&'static str] = &[
                "os_name",
                "arch_name",
                "total_mem",
                "cpu_count",
                "cpu_speed",
                "env_type",
                "trusted",
            ];
            _serde::Deserializer::deserialize_struct(
                __deserializer,
                "RemoteEnv",
                FIELDS,
                __Visitor {
                    marker: _serde::export::PhantomData::<RemoteEnv>,
                    lifetime: _serde::export::PhantomData,
                },
            )
        }
    }
};
impl RemoteEnv {
    pub fn init(env_type: EnvType) -> Result<Self, NetworkError> {
        let rust_info = rust_info::get();
        let os_name = match rust_info.target_os {
            Some(os) => os,
            None => return Err(NetworkError::UnSet(String::from("target_os not set"))),
        };
        let arch_name = match rust_info.target_arch {
            Some(arch) => arch,
            None => return Err(NetworkError::UnSet(String::from("target_arch not set"))),
        };
        let total_mem = match sys_info::mem_info() {
            Ok(mem) => mem.total,
            Err(e) => {
                return Err(NetworkError::UnSet({
                    let res = ::alloc::fmt::format(::core::fmt::Arguments::new_v1(
                        &[""],
                        &match (&e,) {
                            (arg0,) => [::core::fmt::ArgumentV1::new(
                                arg0,
                                ::core::fmt::Display::fmt,
                            )],
                        },
                    ));
                    res
                }))
            }
        };
        let cpu_count = match sys_info::cpu_num() {
            Ok(num) => num as u16,
            Err(e) => {
                return Err(NetworkError::UnSet({
                    let res = ::alloc::fmt::format(::core::fmt::Arguments::new_v1(
                        &[""],
                        &match (&e,) {
                            (arg0,) => [::core::fmt::ArgumentV1::new(
                                arg0,
                                ::core::fmt::Display::fmt,
                            )],
                        },
                    ));
                    res
                }))
            }
        };
        let cpu_speed = match sys_info::cpu_speed() {
            Ok(speed) => speed as u16,
            Err(e) => {
                return Err(NetworkError::UnSet({
                    let res = ::alloc::fmt::format(::core::fmt::Arguments::new_v1(
                        &[""],
                        &match (&e,) {
                            (arg0,) => [::core::fmt::ArgumentV1::new(
                                arg0,
                                ::core::fmt::Display::fmt,
                            )],
                        },
                    ));
                    res
                }))
            }
        };
        Ok(Self {
            os_name,
            arch_name,
            total_mem,
            cpu_count,
            cpu_speed,
            env_type,
            trusted: false,
        })
    }
    /// use to set trusted to true, default is false
    pub fn set_trusted(mut self, trusted: bool) -> Self {
        self.trusted = trusted;
        self
    }
}
/// used to keep track of env data + extra data on localhost
pub struct HostEnv {
    core: RemoteEnv,
    config: ArtificeConfig,
    public: bool,
}
#[automatically_derived]
#[allow(unused_qualifications)]
impl ::core::fmt::Debug for HostEnv {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        match *self {
            HostEnv {
                core: ref __self_0_0,
                config: ref __self_0_1,
                public: ref __self_0_2,
            } => {
                let mut debug_trait_builder = f.debug_struct("HostEnv");
                let _ = debug_trait_builder.field("core", &&(*__self_0_0));
                let _ = debug_trait_builder.field("config", &&(*__self_0_1));
                let _ = debug_trait_builder.field("public", &&(*__self_0_2));
                debug_trait_builder.finish()
            }
        }
    }
}
#[automatically_derived]
#[allow(unused_qualifications)]
impl ::core::clone::Clone for HostEnv {
    #[inline]
    fn clone(&self) -> HostEnv {
        match *self {
            HostEnv {
                core: ref __self_0_0,
                config: ref __self_0_1,
                public: ref __self_0_2,
            } => HostEnv {
                core: ::core::clone::Clone::clone(&(*__self_0_0)),
                config: ::core::clone::Clone::clone(&(*__self_0_1)),
                public: ::core::clone::Clone::clone(&(*__self_0_2)),
            },
        }
    }
}
impl ::core::marker::StructuralPartialEq for HostEnv {}
#[automatically_derived]
#[allow(unused_qualifications)]
impl ::core::cmp::PartialEq for HostEnv {
    #[inline]
    fn eq(&self, other: &HostEnv) -> bool {
        match *other {
            HostEnv {
                core: ref __self_1_0,
                config: ref __self_1_1,
                public: ref __self_1_2,
            } => match *self {
                HostEnv {
                    core: ref __self_0_0,
                    config: ref __self_0_1,
                    public: ref __self_0_2,
                } => {
                    (*__self_0_0) == (*__self_1_0)
                        && (*__self_0_1) == (*__self_1_1)
                        && (*__self_0_2) == (*__self_1_2)
                }
            },
        }
    }
    #[inline]
    fn ne(&self, other: &HostEnv) -> bool {
        match *other {
            HostEnv {
                core: ref __self_1_0,
                config: ref __self_1_1,
                public: ref __self_1_2,
            } => match *self {
                HostEnv {
                    core: ref __self_0_0,
                    config: ref __self_0_1,
                    public: ref __self_0_2,
                } => {
                    (*__self_0_0) != (*__self_1_0)
                        || (*__self_0_1) != (*__self_1_1)
                        || (*__self_0_2) != (*__self_1_2)
                }
            },
        }
    }
}
impl ::core::marker::StructuralEq for HostEnv {}
#[automatically_derived]
#[allow(unused_qualifications)]
impl ::core::cmp::Eq for HostEnv {
    #[inline]
    #[doc(hidden)]
    fn assert_receiver_is_total_eq(&self) -> () {
        {
            let _: ::core::cmp::AssertParamIsEq<RemoteEnv>;
            let _: ::core::cmp::AssertParamIsEq<ArtificeConfig>;
            let _: ::core::cmp::AssertParamIsEq<bool>;
        }
    }
}
#[doc(hidden)]
#[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
const _: () = {
    #[allow(rust_2018_idioms, clippy::useless_attribute)]
    extern crate serde as _serde;
    #[automatically_derived]
    impl _serde::Serialize for HostEnv {
        fn serialize<__S>(&self, __serializer: __S) -> _serde::export::Result<__S::Ok, __S::Error>
        where
            __S: _serde::Serializer,
        {
            let mut __serde_state = match _serde::Serializer::serialize_struct(
                __serializer,
                "HostEnv",
                false as usize + 1 + 1 + 1,
            ) {
                _serde::export::Ok(__val) => __val,
                _serde::export::Err(__err) => {
                    return _serde::export::Err(__err);
                }
            };
            match _serde::ser::SerializeStruct::serialize_field(
                &mut __serde_state,
                "core",
                &self.core,
            ) {
                _serde::export::Ok(__val) => __val,
                _serde::export::Err(__err) => {
                    return _serde::export::Err(__err);
                }
            };
            match _serde::ser::SerializeStruct::serialize_field(
                &mut __serde_state,
                "config",
                &self.config,
            ) {
                _serde::export::Ok(__val) => __val,
                _serde::export::Err(__err) => {
                    return _serde::export::Err(__err);
                }
            };
            match _serde::ser::SerializeStruct::serialize_field(
                &mut __serde_state,
                "public",
                &self.public,
            ) {
                _serde::export::Ok(__val) => __val,
                _serde::export::Err(__err) => {
                    return _serde::export::Err(__err);
                }
            };
            _serde::ser::SerializeStruct::end(__serde_state)
        }
    }
};
#[doc(hidden)]
#[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
const _: () = {
    #[allow(rust_2018_idioms, clippy::useless_attribute)]
    extern crate serde as _serde;
    #[automatically_derived]
    impl<'de> _serde::Deserialize<'de> for HostEnv {
        fn deserialize<__D>(__deserializer: __D) -> _serde::export::Result<Self, __D::Error>
        where
            __D: _serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            enum __Field {
                __field0,
                __field1,
                __field2,
                __ignore,
            }
            struct __FieldVisitor;
            impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                type Value = __Field;
                fn expecting(
                    &self,
                    __formatter: &mut _serde::export::Formatter,
                ) -> _serde::export::fmt::Result {
                    _serde::export::Formatter::write_str(__formatter, "field identifier")
                }
                fn visit_u64<__E>(self, __value: u64) -> _serde::export::Result<Self::Value, __E>
                where
                    __E: _serde::de::Error,
                {
                    match __value {
                        0u64 => _serde::export::Ok(__Field::__field0),
                        1u64 => _serde::export::Ok(__Field::__field1),
                        2u64 => _serde::export::Ok(__Field::__field2),
                        _ => _serde::export::Err(_serde::de::Error::invalid_value(
                            _serde::de::Unexpected::Unsigned(__value),
                            &"field index 0 <= i < 3",
                        )),
                    }
                }
                fn visit_str<__E>(self, __value: &str) -> _serde::export::Result<Self::Value, __E>
                where
                    __E: _serde::de::Error,
                {
                    match __value {
                        "core" => _serde::export::Ok(__Field::__field0),
                        "config" => _serde::export::Ok(__Field::__field1),
                        "public" => _serde::export::Ok(__Field::__field2),
                        _ => _serde::export::Ok(__Field::__ignore),
                    }
                }
                fn visit_bytes<__E>(
                    self,
                    __value: &[u8],
                ) -> _serde::export::Result<Self::Value, __E>
                where
                    __E: _serde::de::Error,
                {
                    match __value {
                        b"core" => _serde::export::Ok(__Field::__field0),
                        b"config" => _serde::export::Ok(__Field::__field1),
                        b"public" => _serde::export::Ok(__Field::__field2),
                        _ => _serde::export::Ok(__Field::__ignore),
                    }
                }
            }
            impl<'de> _serde::Deserialize<'de> for __Field {
                #[inline]
                fn deserialize<__D>(__deserializer: __D) -> _serde::export::Result<Self, __D::Error>
                where
                    __D: _serde::Deserializer<'de>,
                {
                    _serde::Deserializer::deserialize_identifier(__deserializer, __FieldVisitor)
                }
            }
            struct __Visitor<'de> {
                marker: _serde::export::PhantomData<HostEnv>,
                lifetime: _serde::export::PhantomData<&'de ()>,
            }
            impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                type Value = HostEnv;
                fn expecting(
                    &self,
                    __formatter: &mut _serde::export::Formatter,
                ) -> _serde::export::fmt::Result {
                    _serde::export::Formatter::write_str(__formatter, "struct HostEnv")
                }
                #[inline]
                fn visit_seq<__A>(
                    self,
                    mut __seq: __A,
                ) -> _serde::export::Result<Self::Value, __A::Error>
                where
                    __A: _serde::de::SeqAccess<'de>,
                {
                    let __field0 =
                        match match _serde::de::SeqAccess::next_element::<RemoteEnv>(&mut __seq) {
                            _serde::export::Ok(__val) => __val,
                            _serde::export::Err(__err) => {
                                return _serde::export::Err(__err);
                            }
                        } {
                            _serde::export::Some(__value) => __value,
                            _serde::export::None => {
                                return _serde::export::Err(_serde::de::Error::invalid_length(
                                    0usize,
                                    &"struct HostEnv with 3 elements",
                                ));
                            }
                        };
                    let __field1 = match match _serde::de::SeqAccess::next_element::<ArtificeConfig>(
                        &mut __seq,
                    ) {
                        _serde::export::Ok(__val) => __val,
                        _serde::export::Err(__err) => {
                            return _serde::export::Err(__err);
                        }
                    } {
                        _serde::export::Some(__value) => __value,
                        _serde::export::None => {
                            return _serde::export::Err(_serde::de::Error::invalid_length(
                                1usize,
                                &"struct HostEnv with 3 elements",
                            ));
                        }
                    };
                    let __field2 =
                        match match _serde::de::SeqAccess::next_element::<bool>(&mut __seq) {
                            _serde::export::Ok(__val) => __val,
                            _serde::export::Err(__err) => {
                                return _serde::export::Err(__err);
                            }
                        } {
                            _serde::export::Some(__value) => __value,
                            _serde::export::None => {
                                return _serde::export::Err(_serde::de::Error::invalid_length(
                                    2usize,
                                    &"struct HostEnv with 3 elements",
                                ));
                            }
                        };
                    _serde::export::Ok(HostEnv {
                        core: __field0,
                        config: __field1,
                        public: __field2,
                    })
                }
                #[inline]
                fn visit_map<__A>(
                    self,
                    mut __map: __A,
                ) -> _serde::export::Result<Self::Value, __A::Error>
                where
                    __A: _serde::de::MapAccess<'de>,
                {
                    let mut __field0: _serde::export::Option<RemoteEnv> = _serde::export::None;
                    let mut __field1: _serde::export::Option<ArtificeConfig> = _serde::export::None;
                    let mut __field2: _serde::export::Option<bool> = _serde::export::None;
                    while let _serde::export::Some(__key) =
                        match _serde::de::MapAccess::next_key::<__Field>(&mut __map) {
                            _serde::export::Ok(__val) => __val,
                            _serde::export::Err(__err) => {
                                return _serde::export::Err(__err);
                            }
                        }
                    {
                        match __key {
                            __Field::__field0 => {
                                if _serde::export::Option::is_some(&__field0) {
                                    return _serde::export::Err(
                                        <__A::Error as _serde::de::Error>::duplicate_field("core"),
                                    );
                                }
                                __field0 = _serde::export::Some(
                                    match _serde::de::MapAccess::next_value::<RemoteEnv>(&mut __map)
                                    {
                                        _serde::export::Ok(__val) => __val,
                                        _serde::export::Err(__err) => {
                                            return _serde::export::Err(__err);
                                        }
                                    },
                                );
                            }
                            __Field::__field1 => {
                                if _serde::export::Option::is_some(&__field1) {
                                    return _serde::export::Err(
                                        <__A::Error as _serde::de::Error>::duplicate_field(
                                            "config",
                                        ),
                                    );
                                }
                                __field1 = _serde::export::Some(
                                    match _serde::de::MapAccess::next_value::<ArtificeConfig>(
                                        &mut __map,
                                    ) {
                                        _serde::export::Ok(__val) => __val,
                                        _serde::export::Err(__err) => {
                                            return _serde::export::Err(__err);
                                        }
                                    },
                                );
                            }
                            __Field::__field2 => {
                                if _serde::export::Option::is_some(&__field2) {
                                    return _serde::export::Err(
                                        <__A::Error as _serde::de::Error>::duplicate_field(
                                            "public",
                                        ),
                                    );
                                }
                                __field2 = _serde::export::Some(
                                    match _serde::de::MapAccess::next_value::<bool>(&mut __map) {
                                        _serde::export::Ok(__val) => __val,
                                        _serde::export::Err(__err) => {
                                            return _serde::export::Err(__err);
                                        }
                                    },
                                );
                            }
                            _ => {
                                let _ = match _serde::de::MapAccess::next_value::<
                                    _serde::de::IgnoredAny,
                                >(&mut __map)
                                {
                                    _serde::export::Ok(__val) => __val,
                                    _serde::export::Err(__err) => {
                                        return _serde::export::Err(__err);
                                    }
                                };
                            }
                        }
                    }
                    let __field0 = match __field0 {
                        _serde::export::Some(__field0) => __field0,
                        _serde::export::None => match _serde::private::de::missing_field("core") {
                            _serde::export::Ok(__val) => __val,
                            _serde::export::Err(__err) => {
                                return _serde::export::Err(__err);
                            }
                        },
                    };
                    let __field1 = match __field1 {
                        _serde::export::Some(__field1) => __field1,
                        _serde::export::None => {
                            match _serde::private::de::missing_field("config") {
                                _serde::export::Ok(__val) => __val,
                                _serde::export::Err(__err) => {
                                    return _serde::export::Err(__err);
                                }
                            }
                        }
                    };
                    let __field2 = match __field2 {
                        _serde::export::Some(__field2) => __field2,
                        _serde::export::None => {
                            match _serde::private::de::missing_field("public") {
                                _serde::export::Ok(__val) => __val,
                                _serde::export::Err(__err) => {
                                    return _serde::export::Err(__err);
                                }
                            }
                        }
                    };
                    _serde::export::Ok(HostEnv {
                        core: __field0,
                        config: __field1,
                        public: __field2,
                    })
                }
            }
            const FIELDS: &'static [&'static str] = &["core", "config", "public"];
            _serde::Deserializer::deserialize_struct(
                __deserializer,
                "HostEnv",
                FIELDS,
                __Visitor {
                    marker: _serde::export::PhantomData::<HostEnv>,
                    lifetime: _serde::export::PhantomData,
                },
            )
        }
    }
};
impl HostEnv {
    /// # Arguments
    ///
    /// config: Local ArtificeConfig click for more info
    /// env_type: passed into RemoteEnv when getting data local env
    /// public: should this env be a shared resource, not that this will only be allowed, once secure exec environments become possible
    pub fn init(
        config: ArtificeConfig,
        env_type: EnvType,
        public: bool,
    ) -> Result<Self, NetworkError> {
        let core = RemoteEnv::init(env_type)?;
        Ok(Self {
            core,
            config,
            public,
        })
    }
    /// # Arguments
    /// same arguments as init, but you have more control over the environment data passed in
    pub fn new(core: RemoteEnv, config: ArtificeConfig, public: bool) -> Self {
        Self {
            core,
            config,
            public,
        }
    }
    pub fn env_data(&self) -> &RemoteEnv {
        &self.core
    }
    pub fn mut_env_data(&mut self) -> &mut RemoteEnv {
        &mut self.core
    }
    pub fn config(&self) -> &ArtificeConfig {
        &self.config
    }
    pub fn mut_config(&mut self) -> &mut ArtificeConfig {
        &mut self.config
    }
    pub fn is_public(&self) -> bool {
        self.public
    }
    pub fn set_public(&mut self, public: bool) {
        self.public = public;
    }
}
impl EnvData for HostEnv {
    fn trusted(&self) -> bool {
        self.core.trusted()
    }
    fn os_name(&self) -> &str {
        self.core.os_name()
    }
    fn arch_name(&self) -> &str {
        self.core.arch_name()
    }
    fn total_mem(&self) -> u64 {
        self.core.total_mem()
    }
    fn cpu_count(&self) -> u16 {
        self.core.cpu_count()
    }
    fn cpu_speed(&self) -> u16 {
        self.core.cpu_speed()
    }
}
/// used to hold information on remote  systems, by keeping track of EnvData, and a ArtificePeer
pub struct RemoteHost {
    peer: ArtificePeer,
    data: RemoteEnv,
}
#[automatically_derived]
#[allow(unused_qualifications)]
impl ::core::fmt::Debug for RemoteHost {
    fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
        match *self {
            RemoteHost {
                peer: ref __self_0_0,
                data: ref __self_0_1,
            } => {
                let mut debug_trait_builder = f.debug_struct("RemoteHost");
                let _ = debug_trait_builder.field("peer", &&(*__self_0_0));
                let _ = debug_trait_builder.field("data", &&(*__self_0_1));
                debug_trait_builder.finish()
            }
        }
    }
}
#[automatically_derived]
#[allow(unused_qualifications)]
impl ::core::clone::Clone for RemoteHost {
    #[inline]
    fn clone(&self) -> RemoteHost {
        match *self {
            RemoteHost {
                peer: ref __self_0_0,
                data: ref __self_0_1,
            } => RemoteHost {
                peer: ::core::clone::Clone::clone(&(*__self_0_0)),
                data: ::core::clone::Clone::clone(&(*__self_0_1)),
            },
        }
    }
}
impl ::core::marker::StructuralPartialEq for RemoteHost {}
#[automatically_derived]
#[allow(unused_qualifications)]
impl ::core::cmp::PartialEq for RemoteHost {
    #[inline]
    fn eq(&self, other: &RemoteHost) -> bool {
        match *other {
            RemoteHost {
                peer: ref __self_1_0,
                data: ref __self_1_1,
            } => match *self {
                RemoteHost {
                    peer: ref __self_0_0,
                    data: ref __self_0_1,
                } => (*__self_0_0) == (*__self_1_0) && (*__self_0_1) == (*__self_1_1),
            },
        }
    }
    #[inline]
    fn ne(&self, other: &RemoteHost) -> bool {
        match *other {
            RemoteHost {
                peer: ref __self_1_0,
                data: ref __self_1_1,
            } => match *self {
                RemoteHost {
                    peer: ref __self_0_0,
                    data: ref __self_0_1,
                } => (*__self_0_0) != (*__self_1_0) || (*__self_0_1) != (*__self_1_1),
            },
        }
    }
}
impl ::core::marker::StructuralEq for RemoteHost {}
#[automatically_derived]
#[allow(unused_qualifications)]
impl ::core::cmp::Eq for RemoteHost {
    #[inline]
    #[doc(hidden)]
    fn assert_receiver_is_total_eq(&self) -> () {
        {
            let _: ::core::cmp::AssertParamIsEq<ArtificePeer>;
            let _: ::core::cmp::AssertParamIsEq<RemoteEnv>;
        }
    }
}
#[doc(hidden)]
#[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
const _: () = {
    #[allow(rust_2018_idioms, clippy::useless_attribute)]
    extern crate serde as _serde;
    #[automatically_derived]
    impl _serde::Serialize for RemoteHost {
        fn serialize<__S>(&self, __serializer: __S) -> _serde::export::Result<__S::Ok, __S::Error>
        where
            __S: _serde::Serializer,
        {
            let mut __serde_state = match _serde::Serializer::serialize_struct(
                __serializer,
                "RemoteHost",
                false as usize + 1 + 1,
            ) {
                _serde::export::Ok(__val) => __val,
                _serde::export::Err(__err) => {
                    return _serde::export::Err(__err);
                }
            };
            match _serde::ser::SerializeStruct::serialize_field(
                &mut __serde_state,
                "peer",
                &self.peer,
            ) {
                _serde::export::Ok(__val) => __val,
                _serde::export::Err(__err) => {
                    return _serde::export::Err(__err);
                }
            };
            match _serde::ser::SerializeStruct::serialize_field(
                &mut __serde_state,
                "data",
                &self.data,
            ) {
                _serde::export::Ok(__val) => __val,
                _serde::export::Err(__err) => {
                    return _serde::export::Err(__err);
                }
            };
            _serde::ser::SerializeStruct::end(__serde_state)
        }
    }
};
#[doc(hidden)]
#[allow(non_upper_case_globals, unused_attributes, unused_qualifications)]
const _: () = {
    #[allow(rust_2018_idioms, clippy::useless_attribute)]
    extern crate serde as _serde;
    #[automatically_derived]
    impl<'de> _serde::Deserialize<'de> for RemoteHost {
        fn deserialize<__D>(__deserializer: __D) -> _serde::export::Result<Self, __D::Error>
        where
            __D: _serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            enum __Field {
                __field0,
                __field1,
                __ignore,
            }
            struct __FieldVisitor;
            impl<'de> _serde::de::Visitor<'de> for __FieldVisitor {
                type Value = __Field;
                fn expecting(
                    &self,
                    __formatter: &mut _serde::export::Formatter,
                ) -> _serde::export::fmt::Result {
                    _serde::export::Formatter::write_str(__formatter, "field identifier")
                }
                fn visit_u64<__E>(self, __value: u64) -> _serde::export::Result<Self::Value, __E>
                where
                    __E: _serde::de::Error,
                {
                    match __value {
                        0u64 => _serde::export::Ok(__Field::__field0),
                        1u64 => _serde::export::Ok(__Field::__field1),
                        _ => _serde::export::Err(_serde::de::Error::invalid_value(
                            _serde::de::Unexpected::Unsigned(__value),
                            &"field index 0 <= i < 2",
                        )),
                    }
                }
                fn visit_str<__E>(self, __value: &str) -> _serde::export::Result<Self::Value, __E>
                where
                    __E: _serde::de::Error,
                {
                    match __value {
                        "peer" => _serde::export::Ok(__Field::__field0),
                        "data" => _serde::export::Ok(__Field::__field1),
                        _ => _serde::export::Ok(__Field::__ignore),
                    }
                }
                fn visit_bytes<__E>(
                    self,
                    __value: &[u8],
                ) -> _serde::export::Result<Self::Value, __E>
                where
                    __E: _serde::de::Error,
                {
                    match __value {
                        b"peer" => _serde::export::Ok(__Field::__field0),
                        b"data" => _serde::export::Ok(__Field::__field1),
                        _ => _serde::export::Ok(__Field::__ignore),
                    }
                }
            }
            impl<'de> _serde::Deserialize<'de> for __Field {
                #[inline]
                fn deserialize<__D>(__deserializer: __D) -> _serde::export::Result<Self, __D::Error>
                where
                    __D: _serde::Deserializer<'de>,
                {
                    _serde::Deserializer::deserialize_identifier(__deserializer, __FieldVisitor)
                }
            }
            struct __Visitor<'de> {
                marker: _serde::export::PhantomData<RemoteHost>,
                lifetime: _serde::export::PhantomData<&'de ()>,
            }
            impl<'de> _serde::de::Visitor<'de> for __Visitor<'de> {
                type Value = RemoteHost;
                fn expecting(
                    &self,
                    __formatter: &mut _serde::export::Formatter,
                ) -> _serde::export::fmt::Result {
                    _serde::export::Formatter::write_str(__formatter, "struct RemoteHost")
                }
                #[inline]
                fn visit_seq<__A>(
                    self,
                    mut __seq: __A,
                ) -> _serde::export::Result<Self::Value, __A::Error>
                where
                    __A: _serde::de::SeqAccess<'de>,
                {
                    let __field0 =
                        match match _serde::de::SeqAccess::next_element::<ArtificePeer>(&mut __seq)
                        {
                            _serde::export::Ok(__val) => __val,
                            _serde::export::Err(__err) => {
                                return _serde::export::Err(__err);
                            }
                        } {
                            _serde::export::Some(__value) => __value,
                            _serde::export::None => {
                                return _serde::export::Err(_serde::de::Error::invalid_length(
                                    0usize,
                                    &"struct RemoteHost with 2 elements",
                                ));
                            }
                        };
                    let __field1 =
                        match match _serde::de::SeqAccess::next_element::<RemoteEnv>(&mut __seq) {
                            _serde::export::Ok(__val) => __val,
                            _serde::export::Err(__err) => {
                                return _serde::export::Err(__err);
                            }
                        } {
                            _serde::export::Some(__value) => __value,
                            _serde::export::None => {
                                return _serde::export::Err(_serde::de::Error::invalid_length(
                                    1usize,
                                    &"struct RemoteHost with 2 elements",
                                ));
                            }
                        };
                    _serde::export::Ok(RemoteHost {
                        peer: __field0,
                        data: __field1,
                    })
                }
                #[inline]
                fn visit_map<__A>(
                    self,
                    mut __map: __A,
                ) -> _serde::export::Result<Self::Value, __A::Error>
                where
                    __A: _serde::de::MapAccess<'de>,
                {
                    let mut __field0: _serde::export::Option<ArtificePeer> = _serde::export::None;
                    let mut __field1: _serde::export::Option<RemoteEnv> = _serde::export::None;
                    while let _serde::export::Some(__key) =
                        match _serde::de::MapAccess::next_key::<__Field>(&mut __map) {
                            _serde::export::Ok(__val) => __val,
                            _serde::export::Err(__err) => {
                                return _serde::export::Err(__err);
                            }
                        }
                    {
                        match __key {
                            __Field::__field0 => {
                                if _serde::export::Option::is_some(&__field0) {
                                    return _serde::export::Err(
                                        <__A::Error as _serde::de::Error>::duplicate_field("peer"),
                                    );
                                }
                                __field0 = _serde::export::Some(
                                    match _serde::de::MapAccess::next_value::<ArtificePeer>(
                                        &mut __map,
                                    ) {
                                        _serde::export::Ok(__val) => __val,
                                        _serde::export::Err(__err) => {
                                            return _serde::export::Err(__err);
                                        }
                                    },
                                );
                            }
                            __Field::__field1 => {
                                if _serde::export::Option::is_some(&__field1) {
                                    return _serde::export::Err(
                                        <__A::Error as _serde::de::Error>::duplicate_field("data"),
                                    );
                                }
                                __field1 = _serde::export::Some(
                                    match _serde::de::MapAccess::next_value::<RemoteEnv>(&mut __map)
                                    {
                                        _serde::export::Ok(__val) => __val,
                                        _serde::export::Err(__err) => {
                                            return _serde::export::Err(__err);
                                        }
                                    },
                                );
                            }
                            _ => {
                                let _ = match _serde::de::MapAccess::next_value::<
                                    _serde::de::IgnoredAny,
                                >(&mut __map)
                                {
                                    _serde::export::Ok(__val) => __val,
                                    _serde::export::Err(__err) => {
                                        return _serde::export::Err(__err);
                                    }
                                };
                            }
                        }
                    }
                    let __field0 = match __field0 {
                        _serde::export::Some(__field0) => __field0,
                        _serde::export::None => match _serde::private::de::missing_field("peer") {
                            _serde::export::Ok(__val) => __val,
                            _serde::export::Err(__err) => {
                                return _serde::export::Err(__err);
                            }
                        },
                    };
                    let __field1 = match __field1 {
                        _serde::export::Some(__field1) => __field1,
                        _serde::export::None => match _serde::private::de::missing_field("data") {
                            _serde::export::Ok(__val) => __val,
                            _serde::export::Err(__err) => {
                                return _serde::export::Err(__err);
                            }
                        },
                    };
                    _serde::export::Ok(RemoteHost {
                        peer: __field0,
                        data: __field1,
                    })
                }
            }
            const FIELDS: &'static [&'static str] = &["peer", "data"];
            _serde::Deserializer::deserialize_struct(
                __deserializer,
                "RemoteHost",
                FIELDS,
                __Visitor {
                    marker: _serde::export::PhantomData::<RemoteHost>,
                    lifetime: _serde::export::PhantomData,
                },
            )
        }
    }
};
impl RemoteHost {
    pub fn new(peer: ArtificePeer, data: RemoteEnv) -> Self {
        Self { peer, data }
    }
    pub fn peer(&self) -> &ArtificePeer {
        &self.peer
    }
    /// can be used to update data of a given peer
    pub fn mut_peer(&mut self) -> &mut ArtificePeer {
        &mut self.peer
    }
    pub fn env_data(&self) -> &RemoteEnv {
        &self.data
    }
    /// can be used to update data on a given environment
    pub fn mut_env_data(&mut self) -> &mut RemoteEnv {
        &mut self.data
    }
    /// doesn't store the stream internally because this struct should be serialize, and deserialize
    pub fn sync_connect(&self) -> Result<SyncStream, NetworkError> {
        SyncStream::connect(&self.peer)
    }
    /// doesn't store the stream internally because this struct should be serialize, and deserialize
    pub async fn async_connect(&self) -> Result<AsyncStream, NetworkError> {
        AsyncStream::connect(&self.peer).await
    }
}
impl LongHash for RemoteHost {
    fn hash(&self) -> &NetworkHash {
        self.peer.global_peer_hash()
    }
}
impl EnvData for RemoteEnv {
    fn trusted(&self) -> bool {
        self.trusted
    }
    fn env_type(&self) -> &EnvType {
        &self.env_type
    }
    fn os_name(&self) -> &str {
        &self.os_name
    }
    fn arch_name(&self) -> &str {
        &self.arch_name
    }
    fn total_mem(&self) -> u64 {
        self.total_mem
    }
    fn cpu_count(&self) -> u16 {
        self.cpu_speed
    }
    fn cpu_speed(&self) -> u16 {
        self.cpu_speed
    }
}
pub trait ExecEnv: EnvData {
    type Error: std::error::Error;
    /// check available memory count
    fn current_mem(&self) -> Result<u64, Self::Error>
    where
        Self::Error: From<sys_info::Error>,
    {
        match sys_info::mem_info() {
            Ok(mem) => Ok(mem.free),
            Err(e) => Err(e.into()),
        }
    }
    /// get data on how much cpu is being used
    fn load_avg(&self) -> Result<f64, Self::Error>
    where
        Self::Error: From<sys_info::Error>,
    {
        match sys_info::loadavg() {
            Ok(avg) => Ok(avg.fifteen),
            Err(e) => Err(e.into()),
        }
    }
}
/// this is the main struct of this library, and is used to run code on remote systems
pub struct Distributor<E: ExecEnv> {
    database: HashMap<NetworkHash, RemoteHost>,
    connections: HashMap<NetworkHash, AsyncStream>,
    env: Option<E>,
}
impl<E: ExecEnv> Distributor<E> {
    pub fn empty() -> Self {
        Self {
            database: HashMap::new(),
            env: None,
            connections: HashMap::new(),
        }
    }
    /// # Arguments
    ///
    /// database: record of peers, indexed by the global peer hash
    /// env: execution environment to use on the remote system
    pub fn load(database: HashMap<NetworkHash, RemoteHost>, env: E) -> Self {
        Self {
            database,
            env: Some(env),
            connections: HashMap::new(),
        }
    }
    /// load peers
    pub fn database(mut self, database: HashMap<NetworkHash, RemoteHost>) -> Self {
        for (name, record) in database.into_iter() {
            self.database.insert(name, record);
        }
        self
    }
    /// select execution environment
    pub fn env(mut self, env: E) -> Self {
        self.env = Some(env);
        self
    }
    /// return peers, and select execution environment
    pub fn collapse(self) -> (HashMap<NetworkHash, RemoteHost>, E) {
        (self.database, self.env.unwrap())
    }
    /// attempts to connect to remote host using the global hash of a peer
    pub async fn connect(&mut self, hash: &NetworkHash) -> Result<(), NetworkError> {
        let stream = match self.database.get(hash) {
            Some(host) => host.async_connect().await?,
            None => return Err(NetworkError::UnSet(String::from("Couldn't Find Peer"))),
        };
        self.connections.insert(*hash, stream);
        Ok(())
    }
    /// connect to list of peers
    pub async fn establish(&mut self, hashes: &[NetworkHash]) -> Result<(), NetworkError> {
        for hash in hashes {
            self.connect(&hash).await?;
        }
        Ok(())
    }
    pub fn append_incoming(&mut self, stream: AsyncStream) {
        self.connections.insert(*stream.hash(), stream);
    }
}
